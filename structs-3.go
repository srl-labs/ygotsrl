/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /root/go/pkg/mod/github.com/openconfig/ygot@v0.24.4/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/macsec/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-sr-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-reboot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp represents the /srl_nokia-network-instance/network-instance/protocols/pim/trace-options/trace/packet/packet-types/jp YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp struct {
	AllInterfaces YANGEmpty `path:"all-interfaces" module:"srl_nokia-pim"`
	Egress        *bool     `path:"egress" module:"srl_nokia-pim"`
	Ingress       *bool     `path:"ingress" module:"srl_nokia-pim"`
	InterfaceName *string   `path:"interface-name" module:"srl_nokia-pim"`
	Ipv4          *bool     `path:"ipv4" module:"srl_nokia-pim"`
	Ipv6          *bool     `path:"ipv6" module:"srl_nokia-pim"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) IsYANGGoStruct() {
}

// GetAllInterfaces retrieves the value of the leaf AllInterfaces from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllInterfaces is set, it can
// safely use t.GetAllInterfaces() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllInterfaces == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) GetAllInterfaces() YANGEmpty {
	if t == nil || t.AllInterfaces == false {
		return false
	}
	return t.AllInterfaces
}

// GetEgress retrieves the value of the leaf Egress from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Egress is set, it can
// safely use t.GetEgress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Egress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) GetEgress() bool {
	if t == nil || t.Egress == nil {
		return true
	}
	return *t.Egress
}

// GetIngress retrieves the value of the leaf Ingress from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ingress is set, it can
// safely use t.GetIngress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ingress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) GetIngress() bool {
	if t == nil || t.Ingress == nil {
		return true
	}
	return *t.Ingress
}

// GetInterfaceName retrieves the value of the leaf InterfaceName from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceName is set, it can
// safely use t.GetInterfaceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceName == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) GetInterfaceName() string {
	if t == nil || t.InterfaceName == nil {
		return ""
	}
	return *t.InterfaceName
}

// GetIpv4 retrieves the value of the leaf Ipv4 from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4 is set, it can
// safely use t.GetIpv4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4 == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) GetIpv4() bool {
	if t == nil || t.Ipv4 == nil {
		return true
	}
	return *t.Ipv4
}

// GetIpv6 retrieves the value of the leaf Ipv6 from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6 is set, it can
// safely use t.GetIpv6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6 == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) GetIpv6() bool {
	if t == nil || t.Ipv6 == nil {
		return true
	}
	return *t.Ipv6
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Egress == nil {
		var v bool = true
		t.Egress = &v
	}
	if t.Ingress == nil {
		var v bool = true
		t.Ingress = &v
	}
	if t.Ipv4 == nil {
		var v bool = true
		t.Ipv4 = &v
	}
	if t.Ipv6 == nil {
		var v bool = true
		t.Ipv6 = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp.
func (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Jp) ΛBelongingModule() string {
	return "srl_nokia-pim"
}

// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg represents the /srl_nokia-network-instance/network-instance/protocols/pim/trace-options/trace/packet/packet-types/reg YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg struct {
	AllInterfaces YANGEmpty `path:"all-interfaces" module:"srl_nokia-pim"`
	Egress        *bool     `path:"egress" module:"srl_nokia-pim"`
	Ingress       *bool     `path:"ingress" module:"srl_nokia-pim"`
	InterfaceName *string   `path:"interface-name" module:"srl_nokia-pim"`
	Ipv4          *bool     `path:"ipv4" module:"srl_nokia-pim"`
	Ipv6          *bool     `path:"ipv6" module:"srl_nokia-pim"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) IsYANGGoStruct() {
}

// GetAllInterfaces retrieves the value of the leaf AllInterfaces from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllInterfaces is set, it can
// safely use t.GetAllInterfaces() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllInterfaces == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) GetAllInterfaces() YANGEmpty {
	if t == nil || t.AllInterfaces == false {
		return false
	}
	return t.AllInterfaces
}

// GetEgress retrieves the value of the leaf Egress from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Egress is set, it can
// safely use t.GetEgress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Egress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) GetEgress() bool {
	if t == nil || t.Egress == nil {
		return true
	}
	return *t.Egress
}

// GetIngress retrieves the value of the leaf Ingress from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ingress is set, it can
// safely use t.GetIngress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ingress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) GetIngress() bool {
	if t == nil || t.Ingress == nil {
		return true
	}
	return *t.Ingress
}

// GetInterfaceName retrieves the value of the leaf InterfaceName from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceName is set, it can
// safely use t.GetInterfaceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceName == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) GetInterfaceName() string {
	if t == nil || t.InterfaceName == nil {
		return ""
	}
	return *t.InterfaceName
}

// GetIpv4 retrieves the value of the leaf Ipv4 from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4 is set, it can
// safely use t.GetIpv4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4 == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) GetIpv4() bool {
	if t == nil || t.Ipv4 == nil {
		return true
	}
	return *t.Ipv4
}

// GetIpv6 retrieves the value of the leaf Ipv6 from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6 is set, it can
// safely use t.GetIpv6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6 == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) GetIpv6() bool {
	if t == nil || t.Ipv6 == nil {
		return true
	}
	return *t.Ipv6
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Egress == nil {
		var v bool = true
		t.Egress = &v
	}
	if t.Ingress == nil {
		var v bool = true
		t.Ingress = &v
	}
	if t.Ipv4 == nil {
		var v bool = true
		t.Ipv4 = &v
	}
	if t.Ipv6 == nil {
		var v bool = true
		t.Ipv6 = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg.
func (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_Reg) ΛBelongingModule() string {
	return "srl_nokia-pim"
}

// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop represents the /srl_nokia-network-instance/network-instance/protocols/pim/trace-options/trace/packet/packet-types/reg-stop YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop struct {
	AllInterfaces YANGEmpty `path:"all-interfaces" module:"srl_nokia-pim"`
	Egress        *bool     `path:"egress" module:"srl_nokia-pim"`
	Ingress       *bool     `path:"ingress" module:"srl_nokia-pim"`
	InterfaceName *string   `path:"interface-name" module:"srl_nokia-pim"`
	Ipv4          *bool     `path:"ipv4" module:"srl_nokia-pim"`
	Ipv6          *bool     `path:"ipv6" module:"srl_nokia-pim"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) IsYANGGoStruct() {
}

// GetAllInterfaces retrieves the value of the leaf AllInterfaces from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllInterfaces is set, it can
// safely use t.GetAllInterfaces() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllInterfaces == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) GetAllInterfaces() YANGEmpty {
	if t == nil || t.AllInterfaces == false {
		return false
	}
	return t.AllInterfaces
}

// GetEgress retrieves the value of the leaf Egress from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Egress is set, it can
// safely use t.GetEgress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Egress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) GetEgress() bool {
	if t == nil || t.Egress == nil {
		return true
	}
	return *t.Egress
}

// GetIngress retrieves the value of the leaf Ingress from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ingress is set, it can
// safely use t.GetIngress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ingress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) GetIngress() bool {
	if t == nil || t.Ingress == nil {
		return true
	}
	return *t.Ingress
}

// GetInterfaceName retrieves the value of the leaf InterfaceName from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceName is set, it can
// safely use t.GetInterfaceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceName == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) GetInterfaceName() string {
	if t == nil || t.InterfaceName == nil {
		return ""
	}
	return *t.InterfaceName
}

// GetIpv4 retrieves the value of the leaf Ipv4 from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4 is set, it can
// safely use t.GetIpv4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4 == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) GetIpv4() bool {
	if t == nil || t.Ipv4 == nil {
		return true
	}
	return *t.Ipv4
}

// GetIpv6 retrieves the value of the leaf Ipv6 from the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6 is set, it can
// safely use t.GetIpv6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6 == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) GetIpv6() bool {
	if t == nil || t.Ipv6 == nil {
		return true
	}
	return *t.Ipv6
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Egress == nil {
		var v bool = true
		t.Egress = &v
	}
	if t.Ingress == nil {
		var v bool = true
		t.Ingress = &v
	}
	if t.Ipv4 == nil {
		var v bool = true
		t.Ipv4 = &v
	}
	if t.Ipv6 == nil {
		var v bool = true
		t.Ipv6 = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop.
func (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Pim_TraceOptions_Trace_Packet_PacketTypes_RegStop) ΛBelongingModule() string {
	return "srl_nokia-pim"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting represents the /srl_nokia-network-instance/network-instance/segment-routing YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting struct {
	Mpls                   *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls                   `path:"mpls" module:"srl_nokia-segment-routing" yangPresence:"true"`
	SegmentRoutingPolicies *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies `path:"segment-routing-policies" module:"srl_nokia-sr-policies" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) IsYANGGoStruct() {}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) GetOrCreateMpls() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls{}
	return t.Mpls
}

// GetOrCreateSegmentRoutingPolicies retrieves the value of the SegmentRoutingPolicies field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) GetOrCreateSegmentRoutingPolicies() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies {
	if t.SegmentRoutingPolicies != nil {
		return t.SegmentRoutingPolicies
	}
	t.SegmentRoutingPolicies = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies{}
	return t.SegmentRoutingPolicies
}

// GetMpls returns the value of the Mpls struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) GetMpls() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetSegmentRoutingPolicies returns the value of the SegmentRoutingPolicies struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting. If the receiver or the field SegmentRoutingPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) GetSegmentRoutingPolicies() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies {
	if t != nil && t.SegmentRoutingPolicies != nil {
		return t.SegmentRoutingPolicies
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Mpls.PopulateDefaults()
	t.SegmentRoutingPolicies.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting) ΛBelongingModule() string {
	return "srl_nokia-segment-routing"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls represents the /srl_nokia-network-instance/network-instance/segment-routing/mpls YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls struct {
	GlobalBlock    *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock              `path:"global-block" module:"srl_nokia-segment-routing"`
	LocalPrefixSid map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid `path:"local-prefix-sid" module:"srl_nokia-segment-routing"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) IsYANGGoStruct() {}

// NewLocalPrefixSid creates a new entry in the LocalPrefixSid list of the
// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) NewLocalPrefixSid(
	PrefixSidIndex uint8,
) (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LocalPrefixSid == nil {
		t.LocalPrefixSid = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid)
	}

	key := PrefixSidIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LocalPrefixSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LocalPrefixSid", key)
	}

	t.LocalPrefixSid[key] = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid{
		PrefixSidIndex: &PrefixSidIndex,
	}

	return t.LocalPrefixSid[key], nil
}

// RenameLocalPrefixSid renames an entry in the list LocalPrefixSid within
// the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) RenameLocalPrefixSid(oldK, newK uint8) error {
	if _, ok := t.LocalPrefixSid[newK]; ok {
		return fmt.Errorf("key %v already exists in LocalPrefixSid", newK)
	}

	e, ok := t.LocalPrefixSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LocalPrefixSid", oldK)
	}
	e.PrefixSidIndex = &newK

	t.LocalPrefixSid[newK] = e
	delete(t.LocalPrefixSid, oldK)
	return nil
}

// GetOrCreateLocalPrefixSid retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) GetOrCreateLocalPrefixSid(
	PrefixSidIndex uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid {
	key := PrefixSidIndex

	if v, ok := t.LocalPrefixSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLocalPrefixSid(PrefixSidIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLocalPrefixSid got unexpected error: %v", err))
	}
	return v
}

// GetLocalPrefixSid retrieves the value with the specified key from
// the LocalPrefixSid map field of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) GetLocalPrefixSid(
	PrefixSidIndex uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid {
	if t == nil {
		return nil
	}

	key := PrefixSidIndex

	if lm, ok := t.LocalPrefixSid[key]; ok {
		return lm
	}
	return nil
}

// DeleteLocalPrefixSid deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) DeleteLocalPrefixSid(PrefixSidIndex uint8) {
	key := PrefixSidIndex

	delete(t.LocalPrefixSid, key)
}

// AppendLocalPrefixSid appends the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid struct to the
// list LocalPrefixSid of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) AppendLocalPrefixSid(
	v *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid,
) error {
	if v.PrefixSidIndex == nil {
		return fmt.Errorf("invalid nil key received for PrefixSidIndex")
	}

	key := *v.PrefixSidIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LocalPrefixSid == nil {
		t.LocalPrefixSid = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid)
	}

	if _, ok := t.LocalPrefixSid[key]; ok {
		return fmt.Errorf("duplicate key for list LocalPrefixSid %v", key)
	}

	t.LocalPrefixSid[key] = v
	return nil
}

// GetOrCreateGlobalBlock retrieves the value of the GlobalBlock field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) GetOrCreateGlobalBlock() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock {
	if t.GlobalBlock != nil {
		return t.GlobalBlock
	}
	t.GlobalBlock = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock{}
	return t.GlobalBlock
}

// GetGlobalBlock returns the value of the GlobalBlock struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls. If the receiver or the field GlobalBlock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) GetGlobalBlock() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock {
	if t != nil && t.GlobalBlock != nil {
		return t.GlobalBlock
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.GlobalBlock.PopulateDefaults()
	for _, e := range t.LocalPrefixSid {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls) ΛBelongingModule() string {
	return "srl_nokia-segment-routing"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock represents the /srl_nokia-network-instance/network-instance/segment-routing/mpls/global-block YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock struct {
	LabelRange *string `path:"label-range" module:"srl_nokia-segment-routing"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock) IsYANGGoStruct() {}

// GetLabelRange retrieves the value of the leaf LabelRange from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelRange is set, it can
// safely use t.GetLabelRange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelRange == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock) GetLabelRange() string {
	if t == nil || t.LabelRange == nil {
		return ""
	}
	return *t.LabelRange
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_GlobalBlock) ΛBelongingModule() string {
	return "srl_nokia-segment-routing"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid represents the /srl_nokia-network-instance/network-instance/segment-routing/mpls/local-prefix-sid YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid struct {
	Interface      *string `path:"interface" module:"srl_nokia-segment-routing"`
	Ipv4LabelIndex *uint32 `path:"ipv4-label-index" module:"srl_nokia-segment-routing"`
	Ipv6LabelIndex *uint32 `path:"ipv6-label-index" module:"srl_nokia-segment-routing"`
	NodeSid        *bool   `path:"node-sid" module:"srl_nokia-segment-routing"`
	PrefixSidIndex *uint8  `path:"prefix-sid-index" module:"srl_nokia-segment-routing"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) IsYANGGoStruct() {}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetIpv4LabelIndex retrieves the value of the leaf Ipv4LabelIndex from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4LabelIndex is set, it can
// safely use t.GetIpv4LabelIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4LabelIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) GetIpv4LabelIndex() uint32 {
	if t == nil || t.Ipv4LabelIndex == nil {
		return 0
	}
	return *t.Ipv4LabelIndex
}

// GetIpv6LabelIndex retrieves the value of the leaf Ipv6LabelIndex from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6LabelIndex is set, it can
// safely use t.GetIpv6LabelIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6LabelIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) GetIpv6LabelIndex() uint32 {
	if t == nil || t.Ipv6LabelIndex == nil {
		return 0
	}
	return *t.Ipv6LabelIndex
}

// GetNodeSid retrieves the value of the leaf NodeSid from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NodeSid is set, it can
// safely use t.GetNodeSid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NodeSid == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) GetNodeSid() bool {
	if t == nil || t.NodeSid == nil {
		return true
	}
	return *t.NodeSid
}

// GetPrefixSidIndex retrieves the value of the leaf PrefixSidIndex from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixSidIndex is set, it can
// safely use t.GetPrefixSidIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixSidIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) GetPrefixSidIndex() uint8 {
	if t == nil || t.PrefixSidIndex == nil {
		return 0
	}
	return *t.PrefixSidIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.NodeSid == nil {
		var v bool = true
		t.NodeSid = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PrefixSidIndex == nil {
		return nil, fmt.Errorf("nil value for key PrefixSidIndex")
	}

	return map[string]interface{}{
		"prefix-sid-index": *t.PrefixSidIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_Mpls_LocalPrefixSid) ΛBelongingModule() string {
	return "srl_nokia-segment-routing"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies struct {
	BindingSid         *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid         `path:"binding-sid" module:"srl_nokia-sr-policies"`
	NamedPaths         *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths         `path:"named-paths" module:"srl_nokia-sr-policies"`
	ProtectionPolicies *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies `path:"protection-policies" module:"srl_nokia-sr-policies"`
	StaticPolicies     *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies     `path:"static-policies" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) IsYANGGoStruct() {
}

// GetOrCreateBindingSid retrieves the value of the BindingSid field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetOrCreateBindingSid() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid {
	if t.BindingSid != nil {
		return t.BindingSid
	}
	t.BindingSid = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid{}
	return t.BindingSid
}

// GetOrCreateNamedPaths retrieves the value of the NamedPaths field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetOrCreateNamedPaths() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths {
	if t.NamedPaths != nil {
		return t.NamedPaths
	}
	t.NamedPaths = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths{}
	return t.NamedPaths
}

// GetOrCreateProtectionPolicies retrieves the value of the ProtectionPolicies field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetOrCreateProtectionPolicies() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies {
	if t.ProtectionPolicies != nil {
		return t.ProtectionPolicies
	}
	t.ProtectionPolicies = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies{}
	return t.ProtectionPolicies
}

// GetOrCreateStaticPolicies retrieves the value of the StaticPolicies field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetOrCreateStaticPolicies() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies {
	if t.StaticPolicies != nil {
		return t.StaticPolicies
	}
	t.StaticPolicies = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies{}
	return t.StaticPolicies
}

// GetBindingSid returns the value of the BindingSid struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies. If the receiver or the field BindingSid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetBindingSid() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid {
	if t != nil && t.BindingSid != nil {
		return t.BindingSid
	}
	return nil
}

// GetNamedPaths returns the value of the NamedPaths struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies. If the receiver or the field NamedPaths is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetNamedPaths() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths {
	if t != nil && t.NamedPaths != nil {
		return t.NamedPaths
	}
	return nil
}

// GetProtectionPolicies returns the value of the ProtectionPolicies struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies. If the receiver or the field ProtectionPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetProtectionPolicies() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies {
	if t != nil && t.ProtectionPolicies != nil {
		return t.ProtectionPolicies
	}
	return nil
}

// GetStaticPolicies returns the value of the StaticPolicies struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies. If the receiver or the field StaticPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) GetStaticPolicies() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies {
	if t != nil && t.StaticPolicies != nil {
		return t.StaticPolicies
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.BindingSid.PopulateDefaults()
	t.NamedPaths.PopulateDefaults()
	t.ProtectionPolicies.PopulateDefaults()
	t.StaticPolicies.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/binding-sid YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid struct {
	StaticAssignment *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment `path:"static-assignment" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) IsYANGGoStruct() {
}

// GetOrCreateStaticAssignment retrieves the value of the StaticAssignment field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) GetOrCreateStaticAssignment() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment {
	if t.StaticAssignment != nil {
		return t.StaticAssignment
	}
	t.StaticAssignment = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment{}
	return t.StaticAssignment
}

// GetStaticAssignment returns the value of the StaticAssignment struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid. If the receiver or the field StaticAssignment is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) GetStaticAssignment() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment {
	if t != nil && t.StaticAssignment != nil {
		return t.StaticAssignment
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.StaticAssignment.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/binding-sid/static-assignment YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment struct {
	LabelRange *string `path:"label-range" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment) IsYANGGoStruct() {
}

// GetLabelRange retrieves the value of the leaf LabelRange from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LabelRange is set, it can
// safely use t.GetLabelRange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LabelRange == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment) GetLabelRange() string {
	if t == nil || t.LabelRange == nil {
		return ""
	}
	return *t.LabelRange
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_BindingSid_StaticAssignment) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/named-paths YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths struct {
	Path map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path `path:"path" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) IsYANGGoStruct() {
}

// NewPath creates a new entry in the Path list of the
// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) NewPath(
	NamedPathName string,
) (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Path == nil {
		t.Path = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path)
	}

	key := NamedPathName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Path[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Path", key)
	}

	t.Path[key] = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path{
		NamedPathName: &NamedPathName,
	}

	return t.Path[key], nil
}

// RenamePath renames an entry in the list Path within
// the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) RenamePath(oldK, newK string) error {
	if _, ok := t.Path[newK]; ok {
		return fmt.Errorf("key %v already exists in Path", newK)
	}

	e, ok := t.Path[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Path", oldK)
	}
	e.NamedPathName = &newK

	t.Path[newK] = e
	delete(t.Path, oldK)
	return nil
}

// GetOrCreatePath retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) GetOrCreatePath(
	NamedPathName string,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path {
	key := NamedPathName

	if v, ok := t.Path[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPath(NamedPathName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePath got unexpected error: %v", err))
	}
	return v
}

// GetPath retrieves the value with the specified key from
// the Path map field of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) GetPath(
	NamedPathName string,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path {
	if t == nil {
		return nil
	}

	key := NamedPathName

	if lm, ok := t.Path[key]; ok {
		return lm
	}
	return nil
}

// DeletePath deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) DeletePath(NamedPathName string) {
	key := NamedPathName

	delete(t.Path, key)
}

// AppendPath appends the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path struct to the
// list Path of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) AppendPath(
	v *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path,
) error {
	if v.NamedPathName == nil {
		return fmt.Errorf("invalid nil key received for NamedPathName")
	}

	key := *v.NamedPathName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Path == nil {
		t.Path = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path)
	}

	if _, ok := t.Path[key]; ok {
		return fmt.Errorf("duplicate key for list Path %v", key)
	}

	t.Path[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Path {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/named-paths/path YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path struct {
	Hop           map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop `path:"hop" module:"srl_nokia-sr-policies"`
	NamedPathName *string                                                                                                      `path:"named-path-name" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) IsYANGGoStruct() {
}

// NewHop creates a new entry in the Hop list of the
// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) NewHop(
	Index uint8,
) (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Hop == nil {
		t.Hop = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Hop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Hop", key)
	}

	t.Hop[key] = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop{
		Index: &Index,
	}

	return t.Hop[key], nil
}

// RenameHop renames an entry in the list Hop within
// the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) RenameHop(oldK, newK uint8) error {
	if _, ok := t.Hop[newK]; ok {
		return fmt.Errorf("key %v already exists in Hop", newK)
	}

	e, ok := t.Hop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Hop", oldK)
	}
	e.Index = &newK

	t.Hop[newK] = e
	delete(t.Hop, oldK)
	return nil
}

// GetOrCreateHop retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) GetOrCreateHop(
	Index uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop {
	key := Index

	if v, ok := t.Hop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHop(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHop got unexpected error: %v", err))
	}
	return v
}

// GetHop retrieves the value with the specified key from
// the Hop map field of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) GetHop(
	Index uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Hop[key]; ok {
		return lm
	}
	return nil
}

// DeleteHop deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) DeleteHop(Index uint8) {
	key := Index

	delete(t.Hop, key)
}

// AppendHop appends the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop struct to the
// list Hop of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) AppendHop(
	v *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Hop == nil {
		t.Hop = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop)
	}

	if _, ok := t.Hop[key]; ok {
		return fmt.Errorf("duplicate key for list Hop %v", key)
	}

	t.Hop[key] = v
	return nil
}

// GetNamedPathName retrieves the value of the leaf NamedPathName from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NamedPathName is set, it can
// safely use t.GetNamedPathName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NamedPathName == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) GetNamedPathName() string {
	if t == nil || t.NamedPathName == nil {
		return ""
	}
	return *t.NamedPathName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Hop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NamedPathName == nil {
		return nil, fmt.Errorf("nil value for key NamedPathName")
	}

	return map[string]interface{}{
		"named-path-name": *t.NamedPathName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/named-paths/path/hop YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop struct {
	HopType   E_SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop_HopType `path:"hop-type" module:"srl_nokia-sr-policies"`
	Index     *uint8                                                                                                      `path:"index" module:"srl_nokia-sr-policies"`
	IpAddress *string                                                                                                     `path:"ip-address" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) IsYANGGoStruct() {
}

// GetHopType retrieves the value of the leaf HopType from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopType is set, it can
// safely use t.GetHopType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopType == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) GetHopType() E_SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop_HopType {
	if t == nil || t.HopType == 0 {
		return 0
	}
	return t.HopType
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpAddress retrieves the value of the leaf IpAddress from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_NamedPaths_Path_Hop) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/protection-policies YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies struct {
	Policy map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy `path:"policy" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) IsYANGGoStruct() {
}

// NewPolicy creates a new entry in the Policy list of the
// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) NewPolicy(
	ProtectionPolicyName string,
) (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy)
	}

	key := ProtectionPolicyName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy{
		ProtectionPolicyName: &ProtectionPolicyName,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.ProtectionPolicyName = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) GetOrCreatePolicy(
	ProtectionPolicyName string,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy {
	key := ProtectionPolicyName

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(ProtectionPolicyName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) GetPolicy(
	ProtectionPolicyName string,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy {
	if t == nil {
		return nil
	}

	key := ProtectionPolicyName

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) DeletePolicy(ProtectionPolicyName string) {
	key := ProtectionPolicyName

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy struct to the
// list Policy of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) AppendPolicy(
	v *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy,
) error {
	if v.ProtectionPolicyName == nil {
		return fmt.Errorf("invalid nil key received for ProtectionPolicyName")
	}

	key := *v.ProtectionPolicyName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Policy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/protection-policies/policy YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy struct {
	HoldDownTimer        *uint16                                                                                                              `path:"hold-down-timer" module:"srl_nokia-sr-policies"`
	ProtectionPolicyName *string                                                                                                              `path:"protection-policy-name" module:"srl_nokia-sr-policies"`
	RevertTimer          *uint16                                                                                                              `path:"revert-timer" module:"srl_nokia-sr-policies"`
	SeamlessBfd          *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd `path:"seamless-bfd" module:"srl_nokia-sr-policies" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) IsYANGGoStruct() {
}

// GetOrCreateSeamlessBfd retrieves the value of the SeamlessBfd field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) GetOrCreateSeamlessBfd() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd {
	if t.SeamlessBfd != nil {
		return t.SeamlessBfd
	}
	t.SeamlessBfd = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd{}
	return t.SeamlessBfd
}

// GetSeamlessBfd returns the value of the SeamlessBfd struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy. If the receiver or the field SeamlessBfd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) GetSeamlessBfd() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd {
	if t != nil && t.SeamlessBfd != nil {
		return t.SeamlessBfd
	}
	return nil
}

// GetHoldDownTimer retrieves the value of the leaf HoldDownTimer from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldDownTimer is set, it can
// safely use t.GetHoldDownTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldDownTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) GetHoldDownTimer() uint16 {
	if t == nil || t.HoldDownTimer == nil {
		return 0
	}
	return *t.HoldDownTimer
}

// GetProtectionPolicyName retrieves the value of the leaf ProtectionPolicyName from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionPolicyName is set, it can
// safely use t.GetProtectionPolicyName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionPolicyName == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) GetProtectionPolicyName() string {
	if t == nil || t.ProtectionPolicyName == nil {
		return ""
	}
	return *t.ProtectionPolicyName
}

// GetRevertTimer retrieves the value of the leaf RevertTimer from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RevertTimer is set, it can
// safely use t.GetRevertTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RevertTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) GetRevertTimer() uint16 {
	if t == nil || t.RevertTimer == nil {
		return 10
	}
	return *t.RevertTimer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RevertTimer == nil {
		var v uint16 = 10
		t.RevertTimer = &v
	}
	t.SeamlessBfd.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ProtectionPolicyName == nil {
		return nil, fmt.Errorf("nil value for key ProtectionPolicyName")
	}

	return map[string]interface{}{
		"protection-policy-name": *t.ProtectionPolicyName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/protection-policies/policy/seamless-bfd YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd struct {
	DesiredMinimumTransmitInterval *uint32 `path:"desired-minimum-transmit-interval" module:"srl_nokia-sr-policies"`
	Multiplier                     *uint8  `path:"multiplier" module:"srl_nokia-sr-policies"`
	ReturnPathLabel                *uint32 `path:"return-path-label" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) IsYANGGoStruct() {
}

// GetDesiredMinimumTransmitInterval retrieves the value of the leaf DesiredMinimumTransmitInterval from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DesiredMinimumTransmitInterval is set, it can
// safely use t.GetDesiredMinimumTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DesiredMinimumTransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) GetDesiredMinimumTransmitInterval() uint32 {
	if t == nil || t.DesiredMinimumTransmitInterval == nil {
		return 1000000
	}
	return *t.DesiredMinimumTransmitInterval
}

// GetMultiplier retrieves the value of the leaf Multiplier from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Multiplier is set, it can
// safely use t.GetMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Multiplier == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) GetMultiplier() uint8 {
	if t == nil || t.Multiplier == nil {
		return 3
	}
	return *t.Multiplier
}

// GetReturnPathLabel retrieves the value of the leaf ReturnPathLabel from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReturnPathLabel is set, it can
// safely use t.GetReturnPathLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReturnPathLabel == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) GetReturnPathLabel() uint32 {
	if t == nil || t.ReturnPathLabel == nil {
		return 0
	}
	return *t.ReturnPathLabel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DesiredMinimumTransmitInterval == nil {
		var v uint32 = 1000000
		t.DesiredMinimumTransmitInterval = &v
	}
	if t.Multiplier == nil {
		var v uint8 = 3
		t.Multiplier = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_ProtectionPolicies_Policy_SeamlessBfd) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/static-policies YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies struct {
	Policy map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy `path:"policy" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) IsYANGGoStruct() {
}

// NewPolicy creates a new entry in the Policy list of the
// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) NewPolicy(
	StaticPolicyName string,
) (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy)
	}

	key := StaticPolicyName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy{
		StaticPolicyName: &StaticPolicyName,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.StaticPolicyName = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) GetOrCreatePolicy(
	StaticPolicyName string,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy {
	key := StaticPolicyName

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(StaticPolicyName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) GetPolicy(
	StaticPolicyName string,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy {
	if t == nil {
		return nil
	}

	key := StaticPolicyName

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) DeletePolicy(StaticPolicyName string) {
	key := StaticPolicyName

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy struct to the
// list Policy of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) AppendPolicy(
	v *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy,
) error {
	if v.StaticPolicyName == nil {
		return fmt.Errorf("invalid nil key received for StaticPolicyName")
	}

	key := *v.StaticPolicyName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Policy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/static-policies/policy YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy struct {
	AdminState       E_SrlNokiaCommon_AdminState                                                                                                `path:"admin-state" module:"srl_nokia-sr-policies"`
	BindingSid       *uint32                                                                                                                    `path:"binding-sid" module:"srl_nokia-sr-policies"`
	Color            *uint32                                                                                                                    `path:"color" module:"srl_nokia-sr-policies"`
	Description      *string                                                                                                                    `path:"description" module:"srl_nokia-sr-policies"`
	Endpoint         *string                                                                                                                    `path:"endpoint" module:"srl_nokia-sr-policies"`
	Preference       *uint32                                                                                                                    `path:"preference" module:"srl_nokia-sr-policies"`
	ProtectionPolicy *string                                                                                                                    `path:"protection-policy" module:"srl_nokia-sr-policies"`
	SegmentList      map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList `path:"segment-list" module:"srl_nokia-sr-policies"`
	StaticPolicyName *string                                                                                                                    `path:"static-policy-name" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) IsYANGGoStruct() {
}

// NewSegmentList creates a new entry in the SegmentList list of the
// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) NewSegmentList(
	SegmentListIndex uint8,
) (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SegmentList == nil {
		t.SegmentList = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList)
	}

	key := SegmentListIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SegmentList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SegmentList", key)
	}

	t.SegmentList[key] = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList{
		SegmentListIndex: &SegmentListIndex,
	}

	return t.SegmentList[key], nil
}

// RenameSegmentList renames an entry in the list SegmentList within
// the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) RenameSegmentList(oldK, newK uint8) error {
	if _, ok := t.SegmentList[newK]; ok {
		return fmt.Errorf("key %v already exists in SegmentList", newK)
	}

	e, ok := t.SegmentList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SegmentList", oldK)
	}
	e.SegmentListIndex = &newK

	t.SegmentList[newK] = e
	delete(t.SegmentList, oldK)
	return nil
}

// GetOrCreateSegmentList retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetOrCreateSegmentList(
	SegmentListIndex uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList {
	key := SegmentListIndex

	if v, ok := t.SegmentList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSegmentList(SegmentListIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSegmentList got unexpected error: %v", err))
	}
	return v
}

// GetSegmentList retrieves the value with the specified key from
// the SegmentList map field of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetSegmentList(
	SegmentListIndex uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList {
	if t == nil {
		return nil
	}

	key := SegmentListIndex

	if lm, ok := t.SegmentList[key]; ok {
		return lm
	}
	return nil
}

// DeleteSegmentList deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) DeleteSegmentList(SegmentListIndex uint8) {
	key := SegmentListIndex

	delete(t.SegmentList, key)
}

// AppendSegmentList appends the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList struct to the
// list SegmentList of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) AppendSegmentList(
	v *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList,
) error {
	if v.SegmentListIndex == nil {
		return fmt.Errorf("invalid nil key received for SegmentListIndex")
	}

	key := *v.SegmentListIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SegmentList == nil {
		t.SegmentList = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList)
	}

	if _, ok := t.SegmentList[key]; ok {
		return fmt.Errorf("duplicate key for list SegmentList %v", key)
	}

	t.SegmentList[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetBindingSid retrieves the value of the leaf BindingSid from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BindingSid is set, it can
// safely use t.GetBindingSid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BindingSid == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetBindingSid() uint32 {
	if t == nil || t.BindingSid == nil {
		return 0
	}
	return *t.BindingSid
}

// GetColor retrieves the value of the leaf Color from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Color is set, it can
// safely use t.GetColor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Color == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetColor() uint32 {
	if t == nil || t.Color == nil {
		return 0
	}
	return *t.Color
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEndpoint retrieves the value of the leaf Endpoint from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Endpoint is set, it can
// safely use t.GetEndpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Endpoint == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetEndpoint() string {
	if t == nil || t.Endpoint == nil {
		return ""
	}
	return *t.Endpoint
}

// GetPreference retrieves the value of the leaf Preference from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetPreference() uint32 {
	if t == nil || t.Preference == nil {
		return 100
	}
	return *t.Preference
}

// GetProtectionPolicy retrieves the value of the leaf ProtectionPolicy from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtectionPolicy is set, it can
// safely use t.GetProtectionPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtectionPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetProtectionPolicy() string {
	if t == nil || t.ProtectionPolicy == nil {
		return ""
	}
	return *t.ProtectionPolicy
}

// GetStaticPolicyName retrieves the value of the leaf StaticPolicyName from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StaticPolicyName is set, it can
// safely use t.GetStaticPolicyName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StaticPolicyName == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) GetStaticPolicyName() string {
	if t == nil || t.StaticPolicyName == nil {
		return ""
	}
	return *t.StaticPolicyName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.Color == nil {
		var v uint32 = 0
		t.Color = &v
	}
	if t.Preference == nil {
		var v uint32 = 100
		t.Preference = &v
	}
	for _, e := range t.SegmentList {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.StaticPolicyName == nil {
		return nil, fmt.Errorf("nil value for key StaticPolicyName")
	}

	return map[string]interface{}{
		"static-policy-name": *t.StaticPolicyName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/static-policies/policy/segment-list YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList struct {
	AdminState          E_SrlNokiaCommon_AdminState                                                                                                        `path:"admin-state" module:"srl_nokia-sr-policies"`
	NamedPath           *string                                                                                                                            `path:"named-path" module:"srl_nokia-sr-policies"`
	ReOptimizationTimer *uint16                                                                                                                            `path:"re-optimization-timer" module:"srl_nokia-sr-policies"`
	Segment             map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment `path:"segment" module:"srl_nokia-sr-policies"`
	SegmentListIndex    *uint8                                                                                                                             `path:"segment-list-index" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) IsYANGGoStruct() {
}

// NewSegment creates a new entry in the Segment list of the
// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) NewSegment(
	SegmentIndex uint8,
) (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Segment == nil {
		t.Segment = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment)
	}

	key := SegmentIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Segment[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Segment", key)
	}

	t.Segment[key] = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment{
		SegmentIndex: &SegmentIndex,
	}

	return t.Segment[key], nil
}

// RenameSegment renames an entry in the list Segment within
// the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) RenameSegment(oldK, newK uint8) error {
	if _, ok := t.Segment[newK]; ok {
		return fmt.Errorf("key %v already exists in Segment", newK)
	}

	e, ok := t.Segment[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Segment", oldK)
	}
	e.SegmentIndex = &newK

	t.Segment[newK] = e
	delete(t.Segment, oldK)
	return nil
}

// GetOrCreateSegment retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) GetOrCreateSegment(
	SegmentIndex uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment {
	key := SegmentIndex

	if v, ok := t.Segment[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSegment(SegmentIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSegment got unexpected error: %v", err))
	}
	return v
}

// GetSegment retrieves the value with the specified key from
// the Segment map field of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) GetSegment(
	SegmentIndex uint8,
) *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment {
	if t == nil {
		return nil
	}

	key := SegmentIndex

	if lm, ok := t.Segment[key]; ok {
		return lm
	}
	return nil
}

// DeleteSegment deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) DeleteSegment(SegmentIndex uint8) {
	key := SegmentIndex

	delete(t.Segment, key)
}

// AppendSegment appends the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment struct to the
// list Segment of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) AppendSegment(
	v *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment,
) error {
	if v.SegmentIndex == nil {
		return fmt.Errorf("invalid nil key received for SegmentIndex")
	}

	key := *v.SegmentIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Segment == nil {
		t.Segment = make(map[uint8]*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment)
	}

	if _, ok := t.Segment[key]; ok {
		return fmt.Errorf("duplicate key for list Segment %v", key)
	}

	t.Segment[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetNamedPath retrieves the value of the leaf NamedPath from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NamedPath is set, it can
// safely use t.GetNamedPath() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NamedPath == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) GetNamedPath() string {
	if t == nil || t.NamedPath == nil {
		return ""
	}
	return *t.NamedPath
}

// GetReOptimizationTimer retrieves the value of the leaf ReOptimizationTimer from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReOptimizationTimer is set, it can
// safely use t.GetReOptimizationTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReOptimizationTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) GetReOptimizationTimer() uint16 {
	if t == nil || t.ReOptimizationTimer == nil {
		return 30
	}
	return *t.ReOptimizationTimer
}

// GetSegmentListIndex retrieves the value of the leaf SegmentListIndex from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SegmentListIndex is set, it can
// safely use t.GetSegmentListIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SegmentListIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) GetSegmentListIndex() uint8 {
	if t == nil || t.SegmentListIndex == nil {
		return 0
	}
	return *t.SegmentListIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ReOptimizationTimer == nil {
		var v uint16 = 30
		t.ReOptimizationTimer = &v
	}
	for _, e := range t.Segment {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SegmentListIndex == nil {
		return nil, fmt.Errorf("nil value for key SegmentListIndex")
	}

	return map[string]interface{}{
		"segment-list-index": *t.SegmentListIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/static-policies/policy/segment-list/segment YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment struct {
	SegmentIndex *uint8                                                                                                                                `path:"segment-index" module:"srl_nokia-sr-policies"`
	SegmentTypeA *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA `path:"segment-type-a" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) IsYANGGoStruct() {
}

// GetOrCreateSegmentTypeA retrieves the value of the SegmentTypeA field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) GetOrCreateSegmentTypeA() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA {
	if t.SegmentTypeA != nil {
		return t.SegmentTypeA
	}
	t.SegmentTypeA = &SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA{}
	return t.SegmentTypeA
}

// GetSegmentTypeA returns the value of the SegmentTypeA struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment. If the receiver or the field SegmentTypeA is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) GetSegmentTypeA() *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA {
	if t != nil && t.SegmentTypeA != nil {
		return t.SegmentTypeA
	}
	return nil
}

// GetSegmentIndex retrieves the value of the leaf SegmentIndex from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SegmentIndex is set, it can
// safely use t.GetSegmentIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SegmentIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) GetSegmentIndex() uint8 {
	if t == nil || t.SegmentIndex == nil {
		return 0
	}
	return *t.SegmentIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SegmentTypeA.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SegmentIndex == nil {
		return nil, fmt.Errorf("nil value for key SegmentIndex")
	}

	return map[string]interface{}{
		"segment-index": *t.SegmentIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA represents the /srl_nokia-network-instance/network-instance/segment-routing/segment-routing-policies/static-policies/policy/segment-list/segment/segment-type-a YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA struct {
	SidValue *uint32 `path:"sid-value" module:"srl_nokia-sr-policies"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA) IsYANGGoStruct() {
}

// GetSidValue retrieves the value of the leaf SidValue from the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SidValue is set, it can
// safely use t.GetSidValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SidValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA) GetSidValue() uint32 {
	if t == nil || t.SidValue == nil {
		return 0
	}
	return *t.SidValue
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA.
func (*SrlNokiaNetworkInstance_NetworkInstance_SegmentRouting_SegmentRoutingPolicies_StaticPolicies_Policy_SegmentList_Segment_SegmentTypeA) ΛBelongingModule() string {
	return "srl_nokia-sr-policies"
}

// SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes represents the /srl_nokia-network-instance/network-instance/static-routes YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes struct {
	Route map[string]*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route `path:"route" module:"srl_nokia-static-routes"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) IsYANGGoStruct() {}

// NewRoute creates a new entry in the Route list of the
// SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) NewRoute(Prefix string) (*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Route[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Route", key)
	}

	t.Route[key] = &SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route{
		Prefix: &Prefix,
	}

	return t.Route[key], nil
}

// RenameRoute renames an entry in the list Route within
// the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) RenameRoute(oldK, newK string) error {
	if _, ok := t.Route[newK]; ok {
		return fmt.Errorf("key %v already exists in Route", newK)
	}

	e, ok := t.Route[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Route", oldK)
	}
	e.Prefix = &newK

	t.Route[newK] = e
	delete(t.Route, oldK)
	return nil
}

// GetOrCreateRoute retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) GetOrCreateRoute(Prefix string) *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route {
	key := Prefix

	if v, ok := t.Route[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRoute(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRoute got unexpected error: %v", err))
	}
	return v
}

// GetRoute retrieves the value with the specified key from
// the Route map field of SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) GetRoute(Prefix string) *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route {
	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Route[key]; ok {
		return lm
	}
	return nil
}

// DeleteRoute deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) DeleteRoute(Prefix string) {
	key := Prefix

	delete(t.Route, key)
}

// AppendRoute appends the supplied SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route struct to the
// list Route of SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) AppendRoute(
	v *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route,
) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route)
	}

	if _, ok := t.Route[key]; ok {
		return fmt.Errorf("duplicate key for list Route %v", key)
	}

	t.Route[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Route {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes.
func (*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) ΛBelongingModule() string {
	return "srl_nokia-static-routes"
}

// SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route represents the /srl_nokia-network-instance/network-instance/static-routes/route YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route struct {
	AdminState   E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-static-routes"`
	Metric       *uint32                     `path:"metric" module:"srl_nokia-static-routes"`
	NextHopGroup *string                     `path:"next-hop-group" module:"srl_nokia-static-routes"`
	Preference   *uint8                      `path:"preference" module:"srl_nokia-static-routes"`
	Prefix       *string                     `path:"prefix" module:"srl_nokia-static-routes"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetMetric retrieves the value of the leaf Metric from the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) GetMetric() uint32 {
	if t == nil || t.Metric == nil {
		return 1
	}
	return *t.Metric
}

// GetNextHopGroup retrieves the value of the leaf NextHopGroup from the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopGroup is set, it can
// safely use t.GetNextHopGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) GetNextHopGroup() string {
	if t == nil || t.NextHopGroup == nil {
		return ""
	}
	return *t.NextHopGroup
}

// GetPreference retrieves the value of the leaf Preference from the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preference is set, it can
// safely use t.GetPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preference == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) GetPreference() uint8 {
	if t == nil || t.Preference == nil {
		return 5
	}
	return *t.Preference
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.Metric == nil {
		var v uint32 = 1
		t.Metric = &v
	}
	if t.Preference == nil {
		var v uint8 = 5
		t.Preference = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route.
func (*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) ΛBelongingModule() string {
	return "srl_nokia-static-routes"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering represents the /srl_nokia-network-instance/network-instance/traffic-engineering YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering struct {
	AdminGroups          *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups          `path:"admin-groups" module:"srl_nokia-traffic-engineering"`
	AutonomousSystem     *uint32                                                                          `path:"autonomous-system" module:"srl_nokia-traffic-engineering"`
	Interface            map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface `path:"interface" module:"srl_nokia-traffic-engineering"`
	Ipv4TeRouterId       *string                                                                          `path:"ipv4-te-router-id" module:"srl_nokia-traffic-engineering"`
	Ipv6TeRouterId       *string                                                                          `path:"ipv6-te-router-id" module:"srl_nokia-traffic-engineering"`
	SharedRiskLinkGroups *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups `path:"shared-risk-link-groups" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) NewInterface(
	InterfaceName string,
) (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface{
		InterfaceName: &InterfaceName,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceName = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetOrCreateInterface(
	InterfaceName string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface {
	key := InterfaceName

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetInterface(
	InterfaceName string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface {
	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) DeleteInterface(InterfaceName string) {
	key := InterfaceName

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface struct to the
// list Interface of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) AppendInterface(
	v *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface,
) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetOrCreateAdminGroups retrieves the value of the AdminGroups field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetOrCreateAdminGroups() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups {
	if t.AdminGroups != nil {
		return t.AdminGroups
	}
	t.AdminGroups = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups{}
	return t.AdminGroups
}

// GetOrCreateSharedRiskLinkGroups retrieves the value of the SharedRiskLinkGroups field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetOrCreateSharedRiskLinkGroups() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups {
	if t.SharedRiskLinkGroups != nil {
		return t.SharedRiskLinkGroups
	}
	t.SharedRiskLinkGroups = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups{}
	return t.SharedRiskLinkGroups
}

// GetAdminGroups returns the value of the AdminGroups struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering. If the receiver or the field AdminGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetAdminGroups() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups {
	if t != nil && t.AdminGroups != nil {
		return t.AdminGroups
	}
	return nil
}

// GetSharedRiskLinkGroups returns the value of the SharedRiskLinkGroups struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering. If the receiver or the field SharedRiskLinkGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetSharedRiskLinkGroups() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups {
	if t != nil && t.SharedRiskLinkGroups != nil {
		return t.SharedRiskLinkGroups
	}
	return nil
}

// GetAutonomousSystem retrieves the value of the leaf AutonomousSystem from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutonomousSystem is set, it can
// safely use t.GetAutonomousSystem() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutonomousSystem == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetAutonomousSystem() uint32 {
	if t == nil || t.AutonomousSystem == nil {
		return 0
	}
	return *t.AutonomousSystem
}

// GetIpv4TeRouterId retrieves the value of the leaf Ipv4TeRouterId from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4TeRouterId is set, it can
// safely use t.GetIpv4TeRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4TeRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetIpv4TeRouterId() string {
	if t == nil || t.Ipv4TeRouterId == nil {
		return ""
	}
	return *t.Ipv4TeRouterId
}

// GetIpv6TeRouterId retrieves the value of the leaf Ipv6TeRouterId from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6TeRouterId is set, it can
// safely use t.GetIpv6TeRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6TeRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) GetIpv6TeRouterId() string {
	if t == nil || t.Ipv6TeRouterId == nil {
		return ""
	}
	return *t.Ipv6TeRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AdminGroups.PopulateDefaults()
	t.SharedRiskLinkGroups.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups represents the /srl_nokia-network-instance/network-instance/traffic-engineering/admin-groups YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups struct {
	Group map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group `path:"group" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) IsYANGGoStruct() {}

// NewGroup creates a new entry in the Group list of the
// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) NewGroup(
	Name string,
) (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) GetOrCreateGroup(
	Name string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group {
	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) GetGroup(
	Name string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) DeleteGroup(Name string) {
	key := Name

	delete(t.Group, key)
}

// AppendGroup appends the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group struct to the
// list Group of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) AppendGroup(
	v *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Group {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group represents the /srl_nokia-network-instance/network-instance/traffic-engineering/admin-groups/group YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group struct {
	BitPosition *uint32 `path:"bit-position" module:"srl_nokia-traffic-engineering"`
	Name        *string `path:"name" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) IsYANGGoStruct() {
}

// GetBitPosition retrieves the value of the leaf BitPosition from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BitPosition is set, it can
// safely use t.GetBitPosition() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BitPosition == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) GetBitPosition() uint32 {
	if t == nil || t.BitPosition == nil {
		return 0
	}
	return *t.BitPosition
}

// GetName retrieves the value of the leaf Name from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_AdminGroups_Group) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface represents the /srl_nokia-network-instance/network-instance/traffic-engineering/interface YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface struct {
	AdminGroup     []string                                                                    `path:"admin-group" module:"srl_nokia-traffic-engineering"`
	Delay          *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay `path:"delay" module:"srl_nokia-traffic-engineering"`
	InterfaceName  *string                                                                     `path:"interface-name" module:"srl_nokia-traffic-engineering"`
	SrlgMembership []string                                                                    `path:"srlg-membership" module:"srl_nokia-traffic-engineering"`
	TeMetric       *uint32                                                                     `path:"te-metric" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) IsYANGGoStruct() {}

// GetOrCreateDelay retrieves the value of the Delay field
// or returns the existing field if it already exists.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) GetOrCreateDelay() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay {
	if t.Delay != nil {
		return t.Delay
	}
	t.Delay = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay{}
	return t.Delay
}

// GetDelay returns the value of the Delay struct pointer
// from SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface. If the receiver or the field Delay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) GetDelay() *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay {
	if t != nil && t.Delay != nil {
		return t.Delay
	}
	return nil
}

// GetAdminGroup retrieves the value of the leaf AdminGroup from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminGroup is set, it can
// safely use t.GetAdminGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) GetAdminGroup() []string {
	if t == nil || t.AdminGroup == nil {
		return nil
	}
	return t.AdminGroup
}

// GetInterfaceName retrieves the value of the leaf InterfaceName from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceName is set, it can
// safely use t.GetInterfaceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceName == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) GetInterfaceName() string {
	if t == nil || t.InterfaceName == nil {
		return ""
	}
	return *t.InterfaceName
}

// GetSrlgMembership retrieves the value of the leaf SrlgMembership from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrlgMembership is set, it can
// safely use t.GetSrlgMembership() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrlgMembership == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) GetSrlgMembership() []string {
	if t == nil || t.SrlgMembership == nil {
		return nil
	}
	return t.SrlgMembership
}

// GetTeMetric retrieves the value of the leaf TeMetric from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TeMetric is set, it can
// safely use t.GetTeMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TeMetric == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) GetTeMetric() uint32 {
	if t == nil || t.TeMetric == nil {
		return 0
	}
	return *t.TeMetric
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Delay.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay represents the /srl_nokia-network-instance/network-instance/traffic-engineering/interface/delay YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay struct {
	Static *uint32 `path:"static" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay) IsYANGGoStruct() {}

// GetStatic retrieves the value of the leaf Static from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Static is set, it can
// safely use t.GetStatic() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Static == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay) GetStatic() uint32 {
	if t == nil || t.Static == nil {
		return 0
	}
	return *t.Static
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_Interface_Delay) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups represents the /srl_nokia-network-instance/network-instance/traffic-engineering/shared-risk-link-groups YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups struct {
	Group map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group `path:"group" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) IsYANGGoStruct() {
}

// NewGroup creates a new entry in the Group list of the
// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) NewGroup(
	Name string,
) (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) GetOrCreateGroup(
	Name string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group {
	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) GetGroup(
	Name string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) DeleteGroup(Name string) {
	key := Name

	delete(t.Group, key)
}

// AppendGroup appends the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group struct to the
// list Group of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) AppendGroup(
	v *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Group {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group represents the /srl_nokia-network-instance/network-instance/traffic-engineering/shared-risk-link-groups/group YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group struct {
	Cost         *uint32                                                                                                        `path:"cost" module:"srl_nokia-traffic-engineering"`
	Name         *string                                                                                                        `path:"name" module:"srl_nokia-traffic-engineering"`
	StaticMember map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember `path:"static-member" module:"srl_nokia-traffic-engineering"`
	Value        *uint32                                                                                                        `path:"value" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) IsYANGGoStruct() {
}

// NewStaticMember creates a new entry in the StaticMember list of the
// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) NewStaticMember(
	FromAddress string,
) (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticMember == nil {
		t.StaticMember = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember)
	}

	key := FromAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticMember[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticMember", key)
	}

	t.StaticMember[key] = &SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember{
		FromAddress: &FromAddress,
	}

	return t.StaticMember[key], nil
}

// RenameStaticMember renames an entry in the list StaticMember within
// the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) RenameStaticMember(oldK, newK string) error {
	if _, ok := t.StaticMember[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticMember", newK)
	}

	e, ok := t.StaticMember[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticMember", oldK)
	}
	e.FromAddress = &newK

	t.StaticMember[newK] = e
	delete(t.StaticMember, oldK)
	return nil
}

// GetOrCreateStaticMember retrieves the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) GetOrCreateStaticMember(
	FromAddress string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember {
	key := FromAddress

	if v, ok := t.StaticMember[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticMember(FromAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticMember got unexpected error: %v", err))
	}
	return v
}

// GetStaticMember retrieves the value with the specified key from
// the StaticMember map field of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) GetStaticMember(
	FromAddress string,
) *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember {
	if t == nil {
		return nil
	}

	key := FromAddress

	if lm, ok := t.StaticMember[key]; ok {
		return lm
	}
	return nil
}

// DeleteStaticMember deletes the value with the specified keys from
// the receiver SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) DeleteStaticMember(FromAddress string) {
	key := FromAddress

	delete(t.StaticMember, key)
}

// AppendStaticMember appends the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember struct to the
// list StaticMember of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember already exist in the list, an error is
// returned.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) AppendStaticMember(
	v *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember,
) error {
	if v.FromAddress == nil {
		return fmt.Errorf("invalid nil key received for FromAddress")
	}

	key := *v.FromAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticMember == nil {
		t.StaticMember = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember)
	}

	if _, ok := t.StaticMember[key]; ok {
		return fmt.Errorf("duplicate key for list StaticMember %v", key)
	}

	t.StaticMember[key] = v
	return nil
}

// GetCost retrieves the value of the leaf Cost from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cost is set, it can
// safely use t.GetCost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cost == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) GetCost() uint32 {
	if t == nil || t.Cost == nil {
		return 0
	}
	return *t.Cost
}

// GetName retrieves the value of the leaf Name from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.StaticMember {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember represents the /srl_nokia-network-instance/network-instance/traffic-engineering/shared-risk-link-groups/group/static-member YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember struct {
	FromAddress *string `path:"from-address" module:"srl_nokia-traffic-engineering"`
	ToAddress   *string `path:"to-address" module:"srl_nokia-traffic-engineering"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) IsYANGGoStruct() {
}

// GetFromAddress retrieves the value of the leaf FromAddress from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FromAddress is set, it can
// safely use t.GetFromAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FromAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) GetFromAddress() string {
	if t == nil || t.FromAddress == nil {
		return ""
	}
	return *t.FromAddress
}

// GetToAddress retrieves the value of the leaf ToAddress from the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ToAddress is set, it can
// safely use t.GetToAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ToAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) GetToAddress() string {
	if t == nil || t.ToAddress == nil {
		return ""
	}
	return *t.ToAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FromAddress == nil {
		return nil, fmt.Errorf("nil value for key FromAddress")
	}

	return map[string]interface{}{
		"from-address": *t.FromAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember.
func (*SrlNokiaNetworkInstance_NetworkInstance_TrafficEngineering_SharedRiskLinkGroups_Group_StaticMember) ΛBelongingModule() string {
	return "srl_nokia-traffic-engineering"
}

// SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface represents the /srl_nokia-network-instance/network-instance/vxlan-interface YANG schema element.
type SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface struct {
	Name *string `path:"name" module:"srl_nokia-network-instance"`
}

// IsYANGGoStruct ensures that SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface.
func (*SrlNokiaNetworkInstance_NetworkInstance_VxlanInterface) ΛBelongingModule() string {
	return "srl_nokia-network-instance"
}

// SrlNokiaOam_Oam represents the /srl_nokia-oam/oam YANG schema element.
type SrlNokiaOam_Oam struct {
	Ethcfm *SrlNokiaOam_Oam_Ethcfm `path:"ethcfm" module:"srl_nokia-ethcfm" yangPresence:"true"`
	Twamp  *SrlNokiaOam_Oam_Twamp  `path:"twamp" module:"srl_nokia-twamp" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam) IsYANGGoStruct() {}

// GetOrCreateEthcfm retrieves the value of the Ethcfm field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam) GetOrCreateEthcfm() *SrlNokiaOam_Oam_Ethcfm {
	if t.Ethcfm != nil {
		return t.Ethcfm
	}
	t.Ethcfm = &SrlNokiaOam_Oam_Ethcfm{}
	return t.Ethcfm
}

// GetOrCreateTwamp retrieves the value of the Twamp field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam) GetOrCreateTwamp() *SrlNokiaOam_Oam_Twamp {
	if t.Twamp != nil {
		return t.Twamp
	}
	t.Twamp = &SrlNokiaOam_Oam_Twamp{}
	return t.Twamp
}

// GetEthcfm returns the value of the Ethcfm struct pointer
// from SrlNokiaOam_Oam. If the receiver or the field Ethcfm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam) GetEthcfm() *SrlNokiaOam_Oam_Ethcfm {
	if t != nil && t.Ethcfm != nil {
		return t.Ethcfm
	}
	return nil
}

// GetTwamp returns the value of the Twamp struct pointer
// from SrlNokiaOam_Oam. If the receiver or the field Twamp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam) GetTwamp() *SrlNokiaOam_Oam_Twamp {
	if t != nil && t.Twamp != nil {
		return t.Twamp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ethcfm.PopulateDefaults()
	t.Twamp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam.
func (*SrlNokiaOam_Oam) ΛBelongingModule() string {
	return "srl_nokia-oam"
}

// SrlNokiaOam_Oam_Ethcfm represents the /srl_nokia-oam/oam/ethcfm YANG schema element.
type SrlNokiaOam_Oam_Ethcfm struct {
	Domain       map[string]*SrlNokiaOam_Oam_Ethcfm_Domain `path:"domain" module:"srl_nokia-ethcfm"`
	FaultMode    E_SrlNokiaOam_Oam_Ethcfm_FaultMode        `path:"fault-mode" module:"srl_nokia-ethcfm"`
	PmonTemplate *SrlNokiaOam_Oam_Ethcfm_PmonTemplate      `path:"pmon-template" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm) IsYANGGoStruct() {}

// NewDomain creates a new entry in the Domain list of the
// SrlNokiaOam_Oam_Ethcfm struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm) NewDomain(Id string) (*SrlNokiaOam_Oam_Ethcfm_Domain, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Domain == nil {
		t.Domain = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Domain[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Domain", key)
	}

	t.Domain[key] = &SrlNokiaOam_Oam_Ethcfm_Domain{
		Id: &Id,
	}

	return t.Domain[key], nil
}

// RenameDomain renames an entry in the list Domain within
// the SrlNokiaOam_Oam_Ethcfm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm) RenameDomain(oldK, newK string) error {
	if _, ok := t.Domain[newK]; ok {
		return fmt.Errorf("key %v already exists in Domain", newK)
	}

	e, ok := t.Domain[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Domain", oldK)
	}
	e.Id = &newK

	t.Domain[newK] = e
	delete(t.Domain, oldK)
	return nil
}

// GetOrCreateDomain retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm) GetOrCreateDomain(Id string) *SrlNokiaOam_Oam_Ethcfm_Domain {
	key := Id

	if v, ok := t.Domain[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDomain(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDomain got unexpected error: %v", err))
	}
	return v
}

// GetDomain retrieves the value with the specified key from
// the Domain map field of SrlNokiaOam_Oam_Ethcfm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm) GetDomain(Id string) *SrlNokiaOam_Oam_Ethcfm_Domain {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Domain[key]; ok {
		return lm
	}
	return nil
}

// DeleteDomain deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm) DeleteDomain(Id string) {
	key := Id

	delete(t.Domain, key)
}

// AppendDomain appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain struct to the
// list Domain of SrlNokiaOam_Oam_Ethcfm. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm) AppendDomain(v *SrlNokiaOam_Oam_Ethcfm_Domain) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Domain == nil {
		t.Domain = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain)
	}

	if _, ok := t.Domain[key]; ok {
		return fmt.Errorf("duplicate key for list Domain %v", key)
	}

	t.Domain[key] = v
	return nil
}

// GetOrCreatePmonTemplate retrieves the value of the PmonTemplate field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Ethcfm) GetOrCreatePmonTemplate() *SrlNokiaOam_Oam_Ethcfm_PmonTemplate {
	if t.PmonTemplate != nil {
		return t.PmonTemplate
	}
	t.PmonTemplate = &SrlNokiaOam_Oam_Ethcfm_PmonTemplate{}
	return t.PmonTemplate
}

// GetPmonTemplate returns the value of the PmonTemplate struct pointer
// from SrlNokiaOam_Oam_Ethcfm. If the receiver or the field PmonTemplate is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm) GetPmonTemplate() *SrlNokiaOam_Oam_Ethcfm_PmonTemplate {
	if t != nil && t.PmonTemplate != nil {
		return t.PmonTemplate
	}
	return nil
}

// GetFaultMode retrieves the value of the leaf FaultMode from the SrlNokiaOam_Oam_Ethcfm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FaultMode is set, it can
// safely use t.GetFaultMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FaultMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm) GetFaultMode() E_SrlNokiaOam_Oam_Ethcfm_FaultMode {
	if t == nil || t.FaultMode == 0 {
		return SrlNokiaOam_Oam_Ethcfm_FaultMode_itu
	}
	return t.FaultMode
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FaultMode == 0 {
		t.FaultMode = SrlNokiaOam_Oam_Ethcfm_FaultMode_itu
	}
	t.PmonTemplate.PopulateDefaults()
	for _, e := range t.Domain {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm.
func (*SrlNokiaOam_Oam_Ethcfm) ΛBelongingModule() string {
	return "srl_nokia-ethcfm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain represents the /srl_nokia-oam/oam/ethcfm/domain YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain struct {
	Association map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association `path:"association" module:"srl_nokia-ethcfm"`
	Format      E_SrlNokiaEthcfmTypes_MdNameType                      `path:"format" module:"srl_nokia-ethcfm"`
	Id          *string                                               `path:"id" module:"srl_nokia-ethcfm"`
	Level       *uint8                                                `path:"level" module:"srl_nokia-ethcfm"`
	Name        *string                                               `path:"name" module:"srl_nokia-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain) IsYANGGoStruct() {}

// NewAssociation creates a new entry in the Association list of the
// SrlNokiaOam_Oam_Ethcfm_Domain struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) NewAssociation(Id string) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Association == nil {
		t.Association = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Association[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Association", key)
	}

	t.Association[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association{
		Id: &Id,
	}

	return t.Association[key], nil
}

// RenameAssociation renames an entry in the list Association within
// the SrlNokiaOam_Oam_Ethcfm_Domain struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) RenameAssociation(oldK, newK string) error {
	if _, ok := t.Association[newK]; ok {
		return fmt.Errorf("key %v already exists in Association", newK)
	}

	e, ok := t.Association[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Association", oldK)
	}
	e.Id = &newK

	t.Association[newK] = e
	delete(t.Association, oldK)
	return nil
}

// GetOrCreateAssociation retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) GetOrCreateAssociation(Id string) *SrlNokiaOam_Oam_Ethcfm_Domain_Association {
	key := Id

	if v, ok := t.Association[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAssociation(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAssociation got unexpected error: %v", err))
	}
	return v
}

// GetAssociation retrieves the value with the specified key from
// the Association map field of SrlNokiaOam_Oam_Ethcfm_Domain. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) GetAssociation(Id string) *SrlNokiaOam_Oam_Ethcfm_Domain_Association {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Association[key]; ok {
		return lm
	}
	return nil
}

// DeleteAssociation deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) DeleteAssociation(Id string) {
	key := Id

	delete(t.Association, key)
}

// AppendAssociation appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association struct to the
// list Association of SrlNokiaOam_Oam_Ethcfm_Domain. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) AppendAssociation(v *SrlNokiaOam_Oam_Ethcfm_Domain_Association) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Association == nil {
		t.Association = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association)
	}

	if _, ok := t.Association[key]; ok {
		return fmt.Errorf("duplicate key for list Association %v", key)
	}

	t.Association[key] = v
	return nil
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaOam_Oam_Ethcfm_Domain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) GetFormat() E_SrlNokiaEthcfmTypes_MdNameType {
	if t == nil || t.Format == 0 {
		return SrlNokiaEthcfmTypes_MdNameType_none
	}
	return t.Format
}

// GetId retrieves the value of the leaf Id from the SrlNokiaOam_Oam_Ethcfm_Domain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetLevel retrieves the value of the leaf Level from the SrlNokiaOam_Oam_Ethcfm_Domain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Level is set, it can
// safely use t.GetLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Level == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) GetLevel() uint8 {
	if t == nil || t.Level == nil {
		return 0
	}
	return *t.Level
}

// GetName retrieves the value of the leaf Name from the SrlNokiaOam_Oam_Ethcfm_Domain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) GetName() string {
	if t == nil || t.Name == nil {
		return "DEFAULT"
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Format == 0 {
		t.Format = SrlNokiaEthcfmTypes_MdNameType_none
	}
	if t.Level == nil {
		var v uint8 = 0
		t.Level = &v
	}
	if t.Name == nil {
		var v string = "DEFAULT"
		t.Name = &v
	}
	for _, e := range t.Association {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain.
func (*SrlNokiaOam_Oam_Ethcfm_Domain) ΛBelongingModule() string {
	return "srl_nokia-ethcfm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association represents the /srl_nokia-oam/oam/ethcfm/domain/association YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association struct {
	Bridge      map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge `path:"bridge" module:"srl_nokia-ethcfm"`
	CcmInterval E_SrlNokiaEthcfmTypes_IntervalType                           `path:"ccm-interval" module:"srl_nokia-ethcfm"`
	Format      E_SrlNokiaEthcfmTypes_MaNameType                             `path:"format" module:"srl_nokia-ethcfm"`
	Id          *string                                                      `path:"id" module:"srl_nokia-ethcfm"`
	Mep         map[uint16]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep    `path:"mep" module:"srl_nokia-ethcfm"`
	Name        *string                                                      `path:"name" module:"srl_nokia-ethcfm"`
	RemoteMeps  []uint16                                                     `path:"remote-meps" module:"srl_nokia-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association) IsYANGGoStruct() {}

// NewBridge creates a new entry in the Bridge list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) NewBridge(Id string) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bridge == nil {
		t.Bridge = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Bridge[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Bridge", key)
	}

	t.Bridge[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge{
		Id: &Id,
	}

	return t.Bridge[key], nil
}

// RenameBridge renames an entry in the list Bridge within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) RenameBridge(oldK, newK string) error {
	if _, ok := t.Bridge[newK]; ok {
		return fmt.Errorf("key %v already exists in Bridge", newK)
	}

	e, ok := t.Bridge[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Bridge", oldK)
	}
	e.Id = &newK

	t.Bridge[newK] = e
	delete(t.Bridge, oldK)
	return nil
}

// GetOrCreateBridge retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetOrCreateBridge(Id string) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge {
	key := Id

	if v, ok := t.Bridge[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBridge(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBridge got unexpected error: %v", err))
	}
	return v
}

// GetBridge retrieves the value with the specified key from
// the Bridge map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetBridge(Id string) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Bridge[key]; ok {
		return lm
	}
	return nil
}

// DeleteBridge deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) DeleteBridge(Id string) {
	key := Id

	delete(t.Bridge, key)
}

// AppendBridge appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge struct to the
// list Bridge of SrlNokiaOam_Oam_Ethcfm_Domain_Association. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) AppendBridge(
	v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge,
) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bridge == nil {
		t.Bridge = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge)
	}

	if _, ok := t.Bridge[key]; ok {
		return fmt.Errorf("duplicate key for list Bridge %v", key)
	}

	t.Bridge[key] = v
	return nil
}

// NewMep creates a new entry in the Mep list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) NewMep(MepId uint16) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mep == nil {
		t.Mep = make(map[uint16]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep)
	}

	key := MepId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mep[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mep", key)
	}

	t.Mep[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep{
		MepId: &MepId,
	}

	return t.Mep[key], nil
}

// RenameMep renames an entry in the list Mep within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) RenameMep(oldK, newK uint16) error {
	if _, ok := t.Mep[newK]; ok {
		return fmt.Errorf("key %v already exists in Mep", newK)
	}

	e, ok := t.Mep[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mep", oldK)
	}
	e.MepId = &newK

	t.Mep[newK] = e
	delete(t.Mep, oldK)
	return nil
}

// GetOrCreateMep retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetOrCreateMep(MepId uint16) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep {
	key := MepId

	if v, ok := t.Mep[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMep(MepId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMep got unexpected error: %v", err))
	}
	return v
}

// GetMep retrieves the value with the specified key from
// the Mep map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetMep(MepId uint16) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep {
	if t == nil {
		return nil
	}

	key := MepId

	if lm, ok := t.Mep[key]; ok {
		return lm
	}
	return nil
}

// DeleteMep deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) DeleteMep(MepId uint16) {
	key := MepId

	delete(t.Mep, key)
}

// AppendMep appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep struct to the
// list Mep of SrlNokiaOam_Oam_Ethcfm_Domain_Association. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) AppendMep(v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) error {
	if v.MepId == nil {
		return fmt.Errorf("invalid nil key received for MepId")
	}

	key := *v.MepId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mep == nil {
		t.Mep = make(map[uint16]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep)
	}

	if _, ok := t.Mep[key]; ok {
		return fmt.Errorf("duplicate key for list Mep %v", key)
	}

	t.Mep[key] = v
	return nil
}

// GetCcmInterval retrieves the value of the leaf CcmInterval from the SrlNokiaOam_Oam_Ethcfm_Domain_Association
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CcmInterval is set, it can
// safely use t.GetCcmInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CcmInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetCcmInterval() E_SrlNokiaEthcfmTypes_IntervalType {
	if t == nil || t.CcmInterval == 0 {
		return SrlNokiaEthcfmTypes_IntervalType_1s
	}
	return t.CcmInterval
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaOam_Oam_Ethcfm_Domain_Association
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetFormat() E_SrlNokiaEthcfmTypes_MaNameType {
	if t == nil || t.Format == 0 {
		return 0
	}
	return t.Format
}

// GetId retrieves the value of the leaf Id from the SrlNokiaOam_Oam_Ethcfm_Domain_Association
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetName retrieves the value of the leaf Name from the SrlNokiaOam_Oam_Ethcfm_Domain_Association
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRemoteMeps retrieves the value of the leaf RemoteMeps from the SrlNokiaOam_Oam_Ethcfm_Domain_Association
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteMeps is set, it can
// safely use t.GetRemoteMeps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteMeps == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) GetRemoteMeps() []uint16 {
	if t == nil || t.RemoteMeps == nil {
		return nil
	}
	return t.RemoteMeps
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CcmInterval == 0 {
		t.CcmInterval = SrlNokiaEthcfmTypes_IntervalType_1s
	}
	for _, e := range t.Bridge {
		e.PopulateDefaults()
	}
	for _, e := range t.Mep {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association) ΛBelongingModule() string {
	return "srl_nokia-ethcfm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge represents the /srl_nokia-oam/oam/ethcfm/domain/association/bridge YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge struct {
	Id          *string                               `path:"id" module:"srl_nokia-ethcfm"`
	MhfCreation E_SrlNokiaEthcfmTypes_MhfCreationType `path:"mhf-creation" module:"srl_nokia-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetMhfCreation retrieves the value of the leaf MhfCreation from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MhfCreation is set, it can
// safely use t.GetMhfCreation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MhfCreation == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) GetMhfCreation() E_SrlNokiaEthcfmTypes_MhfCreationType {
	if t == nil || t.MhfCreation == 0 {
		return SrlNokiaEthcfmTypes_MhfCreationType_defer
	}
	return t.MhfCreation
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MhfCreation == 0 {
		t.MhfCreation = SrlNokiaEthcfmTypes_MhfCreationType_defer
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Bridge) ΛBelongingModule() string {
	return "srl_nokia-ethcfm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep struct {
	AdminState                E_SrlNokiaCommon_AdminState                         `path:"admin-state" module:"srl_nokia-ethcfm"`
	Ccm                       *bool                                               `path:"ccm" module:"srl_nokia-ethcfm"`
	CcmLtmPriority            *uint8                                              `path:"ccm-ltm-priority" module:"srl_nokia-ethcfm"`
	Direction                 E_SrlNokiaEthcfmTypes_MepDirectionType              `path:"direction" module:"srl_nokia-ethcfm"`
	Interface                 *string                                             `path:"interface" module:"srl_nokia-ethcfm"`
	LowestFaultPriorityDefect E_SrlNokiaEthcfmTypes_LowestAlarmPriorityType       `path:"lowest-fault-priority-defect" module:"srl_nokia-ethcfm"`
	MacAddress                *string                                             `path:"mac-address" module:"srl_nokia-ethcfm"`
	MepId                     *uint16                                             `path:"mep-id" module:"srl_nokia-ethcfm"`
	Pmon                      *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon `path:"pmon" module:"srl_nokia-ethcfm-pm"`
	Subinterface              *string                                             `path:"subinterface" module:"srl_nokia-ethcfm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) IsYANGGoStruct() {}

// GetOrCreatePmon retrieves the value of the Pmon field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetOrCreatePmon() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon {
	if t.Pmon != nil {
		return t.Pmon
	}
	t.Pmon = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon{}
	return t.Pmon
}

// GetPmon returns the value of the Pmon struct pointer
// from SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep. If the receiver or the field Pmon is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetPmon() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon {
	if t != nil && t.Pmon != nil {
		return t.Pmon
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetCcm retrieves the value of the leaf Ccm from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ccm is set, it can
// safely use t.GetCcm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ccm == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetCcm() bool {
	if t == nil || t.Ccm == nil {
		return false
	}
	return *t.Ccm
}

// GetCcmLtmPriority retrieves the value of the leaf CcmLtmPriority from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CcmLtmPriority is set, it can
// safely use t.GetCcmLtmPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CcmLtmPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetCcmLtmPriority() uint8 {
	if t == nil || t.CcmLtmPriority == nil {
		return 7
	}
	return *t.CcmLtmPriority
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetDirection() E_SrlNokiaEthcfmTypes_MepDirectionType {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetLowestFaultPriorityDefect retrieves the value of the leaf LowestFaultPriorityDefect from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowestFaultPriorityDefect is set, it can
// safely use t.GetLowestFaultPriorityDefect() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowestFaultPriorityDefect == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetLowestFaultPriorityDefect() E_SrlNokiaEthcfmTypes_LowestAlarmPriorityType {
	if t == nil || t.LowestFaultPriorityDefect == 0 {
		return SrlNokiaEthcfmTypes_LowestAlarmPriorityType_mac_rem_err_xcon
	}
	return t.LowestFaultPriorityDefect
}

// GetMacAddress retrieves the value of the leaf MacAddress from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return "00:00:00:00:00:00"
	}
	return *t.MacAddress
}

// GetMepId retrieves the value of the leaf MepId from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MepId is set, it can
// safely use t.GetMepId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MepId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetMepId() uint16 {
	if t == nil || t.MepId == nil {
		return 0
	}
	return *t.MepId
}

// GetSubinterface retrieves the value of the leaf Subinterface from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) GetSubinterface() string {
	if t == nil || t.Subinterface == nil {
		return ""
	}
	return *t.Subinterface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Ccm == nil {
		var v bool = false
		t.Ccm = &v
	}
	if t.CcmLtmPriority == nil {
		var v uint8 = 7
		t.CcmLtmPriority = &v
	}
	if t.LowestFaultPriorityDefect == 0 {
		t.LowestFaultPriorityDefect = SrlNokiaEthcfmTypes_LowestAlarmPriorityType_mac_rem_err_xcon
	}
	if t.MacAddress == nil {
		var v string = "00:00:00:00:00:00"
		t.MacAddress = &v
	}
	t.Pmon.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MepId == nil {
		return nil, fmt.Errorf("nil value for key MepId")
	}

	return map[string]interface{}{
		"mep-id": *t.MepId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep) ΛBelongingModule() string {
	return "srl_nokia-ethcfm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon struct {
	OneWayDm  *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm  `path:"one-way-dm" module:"srl_nokia-ethcfm-pm"`
	TwoWayDm  *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm  `path:"two-way-dm" module:"srl_nokia-ethcfm-pm"`
	TwoWaySlm *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm `path:"two-way-slm" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) IsYANGGoStruct() {}

// GetOrCreateOneWayDm retrieves the value of the OneWayDm field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) GetOrCreateOneWayDm() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm {
	if t.OneWayDm != nil {
		return t.OneWayDm
	}
	t.OneWayDm = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm{}
	return t.OneWayDm
}

// GetOrCreateTwoWayDm retrieves the value of the TwoWayDm field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) GetOrCreateTwoWayDm() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm {
	if t.TwoWayDm != nil {
		return t.TwoWayDm
	}
	t.TwoWayDm = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm{}
	return t.TwoWayDm
}

// GetOrCreateTwoWaySlm retrieves the value of the TwoWaySlm field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) GetOrCreateTwoWaySlm() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm {
	if t.TwoWaySlm != nil {
		return t.TwoWaySlm
	}
	t.TwoWaySlm = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm{}
	return t.TwoWaySlm
}

// GetOneWayDm returns the value of the OneWayDm struct pointer
// from SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon. If the receiver or the field OneWayDm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) GetOneWayDm() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm {
	if t != nil && t.OneWayDm != nil {
		return t.OneWayDm
	}
	return nil
}

// GetTwoWayDm returns the value of the TwoWayDm struct pointer
// from SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon. If the receiver or the field TwoWayDm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) GetTwoWayDm() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm {
	if t != nil && t.TwoWayDm != nil {
		return t.TwoWayDm
	}
	return nil
}

// GetTwoWaySlm returns the value of the TwoWaySlm struct pointer
// from SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon. If the receiver or the field TwoWaySlm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) GetTwoWaySlm() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm {
	if t != nil && t.TwoWaySlm != nil {
		return t.TwoWaySlm
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.OneWayDm.PopulateDefaults()
	t.TwoWayDm.PopulateDefaults()
	t.TwoWaySlm.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/one-way-dm YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm struct {
	Session map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session `path:"session" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) IsYANGGoStruct() {}

// NewSession creates a new entry in the Session list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) NewSession(SessionId string) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session)
	}

	key := SessionId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session{
		SessionId: &SessionId,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) RenameSession(oldK, newK string) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.SessionId = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) GetOrCreateSession(
	SessionId string,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session {
	key := SessionId

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(SessionId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) GetSession(SessionId string) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session {
	if t == nil {
		return nil
	}

	key := SessionId

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// DeleteSession deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) DeleteSession(SessionId string) {
	key := SessionId

	delete(t.Session, key)
}

// AppendSession appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session struct to the
// list Session of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) AppendSession(
	v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session,
) error {
	if v.SessionId == nil {
		return fmt.Errorf("invalid nil key received for SessionId")
	}

	key := *v.SessionId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Session {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/one-way-dm/session YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session struct {
	AdminState          E_SrlNokiaCommon_AdminState                                                            `path:"admin-state" module:"srl_nokia-ethcfm-pm"`
	BinGroup            *uint16                                                                                `path:"bin-group" module:"srl_nokia-ethcfm-pm"`
	FrameSize           *uint32                                                                                `path:"frame-size" module:"srl_nokia-ethcfm-pm"`
	MeasurementInterval *uint16                                                                                `path:"measurement-interval" module:"srl_nokia-ethcfm-pm"`
	Priority            *uint8                                                                                 `path:"priority" module:"srl_nokia-ethcfm-pm"`
	SessionId           *string                                                                                `path:"session-id" module:"srl_nokia-ethcfm-pm"`
	Target              *string                                                                                `path:"target" module:"srl_nokia-ethcfm-pm"`
	TransmitInterval    E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval `path:"transmit-interval" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetBinGroup retrieves the value of the leaf BinGroup from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinGroup is set, it can
// safely use t.GetBinGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetBinGroup() uint16 {
	if t == nil || t.BinGroup == nil {
		return 1
	}
	return *t.BinGroup
}

// GetFrameSize retrieves the value of the leaf FrameSize from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameSize is set, it can
// safely use t.GetFrameSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetFrameSize() uint32 {
	if t == nil || t.FrameSize == nil {
		return 64
	}
	return *t.FrameSize
}

// GetMeasurementInterval retrieves the value of the leaf MeasurementInterval from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MeasurementInterval is set, it can
// safely use t.GetMeasurementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MeasurementInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetMeasurementInterval() uint16 {
	if t == nil || t.MeasurementInterval == nil {
		return 1
	}
	return *t.MeasurementInterval
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 7
	}
	return *t.Priority
}

// GetSessionId retrieves the value of the leaf SessionId from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionId is set, it can
// safely use t.GetSessionId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetSessionId() string {
	if t == nil || t.SessionId == nil {
		return ""
	}
	return *t.SessionId
}

// GetTarget retrieves the value of the leaf Target from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Target is set, it can
// safely use t.GetTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Target == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetTarget() string {
	if t == nil || t.Target == nil {
		return ""
	}
	return *t.Target
}

// GetTransmitInterval retrieves the value of the leaf TransmitInterval from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitInterval is set, it can
// safely use t.GetTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) GetTransmitInterval() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval {
	if t == nil || t.TransmitInterval == 0 {
		return SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval_1s
	}
	return t.TransmitInterval
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.BinGroup == nil {
		var v uint16 = 1
		t.BinGroup = &v
	}
	if t.FrameSize == nil {
		var v uint32 = 64
		t.FrameSize = &v
	}
	if t.MeasurementInterval == nil {
		var v uint16 = 1
		t.MeasurementInterval = &v
	}
	if t.Priority == nil {
		var v uint8 = 7
		t.Priority = &v
	}
	if t.TransmitInterval == 0 {
		t.TransmitInterval = SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval_1s
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SessionId == nil {
		return nil, fmt.Errorf("nil value for key SessionId")
	}

	return map[string]interface{}{
		"session-id": *t.SessionId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-dm YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm struct {
	Session map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session `path:"session" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) IsYANGGoStruct() {}

// NewSession creates a new entry in the Session list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) NewSession(SessionId string) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session)
	}

	key := SessionId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session{
		SessionId: &SessionId,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) RenameSession(oldK, newK string) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.SessionId = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) GetOrCreateSession(
	SessionId string,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session {
	key := SessionId

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(SessionId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) GetSession(SessionId string) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session {
	if t == nil {
		return nil
	}

	key := SessionId

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// DeleteSession deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) DeleteSession(SessionId string) {
	key := SessionId

	delete(t.Session, key)
}

// AppendSession appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session struct to the
// list Session of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) AppendSession(
	v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session,
) error {
	if v.SessionId == nil {
		return fmt.Errorf("invalid nil key received for SessionId")
	}

	key := *v.SessionId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Session {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-dm/session YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session struct {
	AdminState          E_SrlNokiaCommon_AdminState                                                            `path:"admin-state" module:"srl_nokia-ethcfm-pm"`
	BinGroup            *uint16                                                                                `path:"bin-group" module:"srl_nokia-ethcfm-pm"`
	FrameSize           *uint32                                                                                `path:"frame-size" module:"srl_nokia-ethcfm-pm"`
	MeasurementInterval *uint16                                                                                `path:"measurement-interval" module:"srl_nokia-ethcfm-pm"`
	Priority            *uint8                                                                                 `path:"priority" module:"srl_nokia-ethcfm-pm"`
	SessionId           *string                                                                                `path:"session-id" module:"srl_nokia-ethcfm-pm"`
	Target              *string                                                                                `path:"target" module:"srl_nokia-ethcfm-pm"`
	TransmitInterval    E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval `path:"transmit-interval" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetBinGroup retrieves the value of the leaf BinGroup from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinGroup is set, it can
// safely use t.GetBinGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetBinGroup() uint16 {
	if t == nil || t.BinGroup == nil {
		return 1
	}
	return *t.BinGroup
}

// GetFrameSize retrieves the value of the leaf FrameSize from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameSize is set, it can
// safely use t.GetFrameSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetFrameSize() uint32 {
	if t == nil || t.FrameSize == nil {
		return 64
	}
	return *t.FrameSize
}

// GetMeasurementInterval retrieves the value of the leaf MeasurementInterval from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MeasurementInterval is set, it can
// safely use t.GetMeasurementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MeasurementInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetMeasurementInterval() uint16 {
	if t == nil || t.MeasurementInterval == nil {
		return 1
	}
	return *t.MeasurementInterval
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 7
	}
	return *t.Priority
}

// GetSessionId retrieves the value of the leaf SessionId from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionId is set, it can
// safely use t.GetSessionId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetSessionId() string {
	if t == nil || t.SessionId == nil {
		return ""
	}
	return *t.SessionId
}

// GetTarget retrieves the value of the leaf Target from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Target is set, it can
// safely use t.GetTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Target == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetTarget() string {
	if t == nil || t.Target == nil {
		return ""
	}
	return *t.Target
}

// GetTransmitInterval retrieves the value of the leaf TransmitInterval from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitInterval is set, it can
// safely use t.GetTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) GetTransmitInterval() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval {
	if t == nil || t.TransmitInterval == 0 {
		return SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval_1s
	}
	return t.TransmitInterval
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.BinGroup == nil {
		var v uint16 = 1
		t.BinGroup = &v
	}
	if t.FrameSize == nil {
		var v uint32 = 64
		t.FrameSize = &v
	}
	if t.MeasurementInterval == nil {
		var v uint16 = 1
		t.MeasurementInterval = &v
	}
	if t.Priority == nil {
		var v uint8 = 7
		t.Priority = &v
	}
	if t.TransmitInterval == 0 {
		t.TransmitInterval = SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_TransmitInterval_1s
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SessionId == nil {
		return nil, fmt.Errorf("nil value for key SessionId")
	}

	return map[string]interface{}{
		"session-id": *t.SessionId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWayDm_Session) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-slm YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm struct {
	Session map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session `path:"session" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) IsYANGGoStruct() {}

// NewSession creates a new entry in the Session list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) NewSession(SessionId string) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session)
	}

	key := SessionId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session{
		SessionId: &SessionId,
	}

	return t.Session[key], nil
}

// RenameSession renames an entry in the list Session within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) RenameSession(oldK, newK string) error {
	if _, ok := t.Session[newK]; ok {
		return fmt.Errorf("key %v already exists in Session", newK)
	}

	e, ok := t.Session[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Session", oldK)
	}
	e.SessionId = &newK

	t.Session[newK] = e
	delete(t.Session, oldK)
	return nil
}

// GetOrCreateSession retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) GetOrCreateSession(
	SessionId string,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session {
	key := SessionId

	if v, ok := t.Session[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSession(SessionId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSession got unexpected error: %v", err))
	}
	return v
}

// GetSession retrieves the value with the specified key from
// the Session map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) GetSession(SessionId string) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session {
	if t == nil {
		return nil
	}

	key := SessionId

	if lm, ok := t.Session[key]; ok {
		return lm
	}
	return nil
}

// DeleteSession deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) DeleteSession(SessionId string) {
	key := SessionId

	delete(t.Session, key)
}

// AppendSession appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session struct to the
// list Session of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) AppendSession(
	v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session,
) error {
	if v.SessionId == nil {
		return fmt.Errorf("invalid nil key received for SessionId")
	}

	key := *v.SessionId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[string]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session)
	}

	if _, ok := t.Session[key]; ok {
		return fmt.Errorf("duplicate key for list Session %v", key)
	}

	t.Session[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Session {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-slm/session YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session struct {
	AdminState           E_SrlNokiaCommon_AdminState                                                             `path:"admin-state" module:"srl_nokia-ethcfm-pm"`
	ConsecutiveIntervals *uint8                                                                                  `path:"consecutive-intervals" module:"srl_nokia-ethcfm-pm"`
	DeltaT               *uint16                                                                                 `path:"delta-t" module:"srl_nokia-ethcfm-pm"`
	FlrThreshold         *uint32                                                                                 `path:"flr-threshold" module:"srl_nokia-ethcfm-pm"`
	FrameSize            *uint32                                                                                 `path:"frame-size" module:"srl_nokia-ethcfm-pm"`
	LossEvent            *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent         `path:"loss-event" module:"srl_nokia-ethcfm-pm"`
	MeasurementInterval  *uint16                                                                                 `path:"measurement-interval" module:"srl_nokia-ethcfm-pm"`
	Priority             *uint8                                                                                  `path:"priority" module:"srl_nokia-ethcfm-pm"`
	SessionId            *string                                                                                 `path:"session-id" module:"srl_nokia-ethcfm-pm"`
	Target               *string                                                                                 `path:"target" module:"srl_nokia-ethcfm-pm"`
	TransmitInterval     E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_TransmitInterval `path:"transmit-interval" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) IsYANGGoStruct() {}

// GetOrCreateLossEvent retrieves the value of the LossEvent field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetOrCreateLossEvent() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent {
	if t.LossEvent != nil {
		return t.LossEvent
	}
	t.LossEvent = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent{}
	return t.LossEvent
}

// GetLossEvent returns the value of the LossEvent struct pointer
// from SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session. If the receiver or the field LossEvent is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetLossEvent() *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent {
	if t != nil && t.LossEvent != nil {
		return t.LossEvent
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetConsecutiveIntervals retrieves the value of the leaf ConsecutiveIntervals from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ConsecutiveIntervals is set, it can
// safely use t.GetConsecutiveIntervals() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ConsecutiveIntervals == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetConsecutiveIntervals() uint8 {
	if t == nil || t.ConsecutiveIntervals == nil {
		return 10
	}
	return *t.ConsecutiveIntervals
}

// GetDeltaT retrieves the value of the leaf DeltaT from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeltaT is set, it can
// safely use t.GetDeltaT() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeltaT == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetDeltaT() uint16 {
	if t == nil || t.DeltaT == nil {
		return 1
	}
	return *t.DeltaT
}

// GetFlrThreshold retrieves the value of the leaf FlrThreshold from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlrThreshold is set, it can
// safely use t.GetFlrThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlrThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetFlrThreshold() uint32 {
	if t == nil || t.FlrThreshold == nil {
		return 50000
	}
	return *t.FlrThreshold
}

// GetFrameSize retrieves the value of the leaf FrameSize from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameSize is set, it can
// safely use t.GetFrameSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetFrameSize() uint32 {
	if t == nil || t.FrameSize == nil {
		return 64
	}
	return *t.FrameSize
}

// GetMeasurementInterval retrieves the value of the leaf MeasurementInterval from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MeasurementInterval is set, it can
// safely use t.GetMeasurementInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MeasurementInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetMeasurementInterval() uint16 {
	if t == nil || t.MeasurementInterval == nil {
		return 1
	}
	return *t.MeasurementInterval
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 7
	}
	return *t.Priority
}

// GetSessionId retrieves the value of the leaf SessionId from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionId is set, it can
// safely use t.GetSessionId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetSessionId() string {
	if t == nil || t.SessionId == nil {
		return ""
	}
	return *t.SessionId
}

// GetTarget retrieves the value of the leaf Target from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Target is set, it can
// safely use t.GetTarget() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Target == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetTarget() string {
	if t == nil || t.Target == nil {
		return ""
	}
	return *t.Target
}

// GetTransmitInterval retrieves the value of the leaf TransmitInterval from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitInterval is set, it can
// safely use t.GetTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) GetTransmitInterval() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_TransmitInterval {
	if t == nil || t.TransmitInterval == 0 {
		return SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_TransmitInterval_100ms
	}
	return t.TransmitInterval
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.ConsecutiveIntervals == nil {
		var v uint8 = 10
		t.ConsecutiveIntervals = &v
	}
	if t.DeltaT == nil {
		var v uint16 = 1
		t.DeltaT = &v
	}
	if t.FlrThreshold == nil {
		var v uint32 = 50000
		t.FlrThreshold = &v
	}
	if t.FrameSize == nil {
		var v uint32 = 64
		t.FrameSize = &v
	}
	if t.MeasurementInterval == nil {
		var v uint16 = 1
		t.MeasurementInterval = &v
	}
	if t.Priority == nil {
		var v uint8 = 7
		t.Priority = &v
	}
	if t.TransmitInterval == 0 {
		t.TransmitInterval = SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_TransmitInterval_100ms
	}
	t.LossEvent.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SessionId == nil {
		return nil, fmt.Errorf("nil value for key SessionId")
	}

	return map[string]interface{}{
		"session-id": *t.SessionId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-slm/session/loss-event YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent struct {
	AvgFlr  map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr  `path:"avg-flr" module:"srl_nokia-ethcfm-pm"`
	Hli     map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli     `path:"hli" module:"srl_nokia-ethcfm-pm"`
	Unavail map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail `path:"unavail" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) IsYANGGoStruct() {
}

// NewAvgFlr creates a new entry in the AvgFlr list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) NewAvgFlr(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AvgFlr == nil {
		t.AvgFlr = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AvgFlr[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AvgFlr", key)
	}

	t.AvgFlr[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr{
		Direction: Direction,
	}

	return t.AvgFlr[key], nil
}

// RenameAvgFlr renames an entry in the list AvgFlr within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) RenameAvgFlr(
	oldK, newK E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) error {
	if _, ok := t.AvgFlr[newK]; ok {
		return fmt.Errorf("key %v already exists in AvgFlr", newK)
	}

	e, ok := t.AvgFlr[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AvgFlr", oldK)
	}
	e.Direction = newK

	t.AvgFlr[newK] = e
	delete(t.AvgFlr, oldK)
	return nil
}

// GetOrCreateAvgFlr retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) GetOrCreateAvgFlr(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr {
	key := Direction

	if v, ok := t.AvgFlr[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAvgFlr(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAvgFlr got unexpected error: %v", err))
	}
	return v
}

// GetAvgFlr retrieves the value with the specified key from
// the AvgFlr map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) GetAvgFlr(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.AvgFlr[key]; ok {
		return lm
	}
	return nil
}

// DeleteAvgFlr deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) DeleteAvgFlr(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) {
	key := Direction

	delete(t.AvgFlr, key)
}

// AppendAvgFlr appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr struct to the
// list AvgFlr of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) AppendAvgFlr(
	v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AvgFlr == nil {
		t.AvgFlr = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr)
	}

	if _, ok := t.AvgFlr[key]; ok {
		return fmt.Errorf("duplicate key for list AvgFlr %v", key)
	}

	t.AvgFlr[key] = v
	return nil
}

// NewHli creates a new entry in the Hli list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) NewHli(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Hli == nil {
		t.Hli = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Hli[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Hli", key)
	}

	t.Hli[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli{
		Direction: Direction,
	}

	return t.Hli[key], nil
}

// RenameHli renames an entry in the list Hli within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) RenameHli(
	oldK, newK E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) error {
	if _, ok := t.Hli[newK]; ok {
		return fmt.Errorf("key %v already exists in Hli", newK)
	}

	e, ok := t.Hli[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Hli", oldK)
	}
	e.Direction = newK

	t.Hli[newK] = e
	delete(t.Hli, oldK)
	return nil
}

// GetOrCreateHli retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) GetOrCreateHli(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli {
	key := Direction

	if v, ok := t.Hli[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHli(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHli got unexpected error: %v", err))
	}
	return v
}

// GetHli retrieves the value with the specified key from
// the Hli map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) GetHli(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.Hli[key]; ok {
		return lm
	}
	return nil
}

// DeleteHli deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) DeleteHli(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) {
	key := Direction

	delete(t.Hli, key)
}

// AppendHli appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli struct to the
// list Hli of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) AppendHli(
	v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Hli == nil {
		t.Hli = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli)
	}

	if _, ok := t.Hli[key]; ok {
		return fmt.Errorf("duplicate key for list Hli %v", key)
	}

	t.Hli[key] = v
	return nil
}

// NewUnavail creates a new entry in the Unavail list of the
// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) NewUnavail(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Unavail == nil {
		t.Unavail = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Unavail[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Unavail", key)
	}

	t.Unavail[key] = &SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail{
		Direction: Direction,
	}

	return t.Unavail[key], nil
}

// RenameUnavail renames an entry in the list Unavail within
// the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) RenameUnavail(
	oldK, newK E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) error {
	if _, ok := t.Unavail[newK]; ok {
		return fmt.Errorf("key %v already exists in Unavail", newK)
	}

	e, ok := t.Unavail[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Unavail", oldK)
	}
	e.Direction = newK

	t.Unavail[newK] = e
	delete(t.Unavail, oldK)
	return nil
}

// GetOrCreateUnavail retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) GetOrCreateUnavail(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail {
	key := Direction

	if v, ok := t.Unavail[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnavail(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnavail got unexpected error: %v", err))
	}
	return v
}

// GetUnavail retrieves the value with the specified key from
// the Unavail map field of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) GetUnavail(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.Unavail[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnavail deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) DeleteUnavail(
	Direction E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction,
) {
	key := Direction

	delete(t.Unavail, key)
}

// AppendUnavail appends the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail struct to the
// list Unavail of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) AppendUnavail(
	v *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Unavail == nil {
		t.Unavail = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction]*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail)
	}

	if _, ok := t.Unavail[key]; ok {
		return fmt.Errorf("duplicate key for list Unavail %v", key)
	}

	t.Unavail[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AvgFlr {
		e.PopulateDefaults()
	}
	for _, e := range t.Hli {
		e.PopulateDefaults()
	}
	for _, e := range t.Unavail {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-slm/session/loss-event/avg-flr YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr struct {
	ClearThreshold *uint32                                                                                           `path:"clear-threshold" module:"srl_nokia-ethcfm-pm"`
	Direction      E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction `path:"direction" module:"srl_nokia-ethcfm-pm"`
	RaiseThreshold *uint32                                                                                           `path:"raise-threshold" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) GetDirection() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ClearThreshold == nil {
		var v uint32 = 0
		t.ClearThreshold = &v
	}
	if t.RaiseThreshold == nil {
		var v uint32 = 0
		t.RaiseThreshold = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-slm/session/loss-event/hli YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli struct {
	ClearThreshold *uint32                                                                                           `path:"clear-threshold" module:"srl_nokia-ethcfm-pm"`
	Direction      E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction `path:"direction" module:"srl_nokia-ethcfm-pm"`
	RaiseThreshold *uint32                                                                                           `path:"raise-threshold" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) GetDirection() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ClearThreshold == nil {
		var v uint32 = 0
		t.ClearThreshold = &v
	}
	if t.RaiseThreshold == nil {
		var v uint32 = 0
		t.RaiseThreshold = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Hli) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail represents the /srl_nokia-oam/oam/ethcfm/domain/association/mep/pmon/two-way-slm/session/loss-event/unavail YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail struct {
	ClearThreshold *uint32                                                                                           `path:"clear-threshold" module:"srl_nokia-ethcfm-pm"`
	Direction      E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction `path:"direction" module:"srl_nokia-ethcfm-pm"`
	RaiseThreshold *uint32                                                                                           `path:"raise-threshold" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) IsYANGGoStruct() {
}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) GetDirection() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_AvgFlr_Direction {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ClearThreshold == nil {
		var v uint32 = 0
		t.ClearThreshold = &v
	}
	if t.RaiseThreshold == nil {
		var v uint32 = 0
		t.RaiseThreshold = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail.
func (*SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_TwoWaySlm_Session_LossEvent_Unavail) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_PmonTemplate represents the /srl_nokia-oam/oam/ethcfm/pmon-template YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_PmonTemplate struct {
	BinGroup            map[uint16]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup            `path:"bin-group" module:"srl_nokia-ethcfm-pm"`
	MeasurementInterval map[uint16]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval `path:"measurement-interval" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_PmonTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate) IsYANGGoStruct() {}

// NewBinGroup creates a new entry in the BinGroup list of the
// SrlNokiaOam_Oam_Ethcfm_PmonTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) NewBinGroup(BgId uint16) (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinGroup == nil {
		t.BinGroup = make(map[uint16]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup)
	}

	key := BgId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BinGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BinGroup", key)
	}

	t.BinGroup[key] = &SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup{
		BgId: &BgId,
	}

	return t.BinGroup[key], nil
}

// RenameBinGroup renames an entry in the list BinGroup within
// the SrlNokiaOam_Oam_Ethcfm_PmonTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) RenameBinGroup(oldK, newK uint16) error {
	if _, ok := t.BinGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in BinGroup", newK)
	}

	e, ok := t.BinGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BinGroup", oldK)
	}
	e.BgId = &newK

	t.BinGroup[newK] = e
	delete(t.BinGroup, oldK)
	return nil
}

// GetOrCreateBinGroup retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) GetOrCreateBinGroup(BgId uint16) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup {
	key := BgId

	if v, ok := t.BinGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBinGroup(BgId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBinGroup got unexpected error: %v", err))
	}
	return v
}

// GetBinGroup retrieves the value with the specified key from
// the BinGroup map field of SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) GetBinGroup(BgId uint16) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup {
	if t == nil {
		return nil
	}

	key := BgId

	if lm, ok := t.BinGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteBinGroup deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) DeleteBinGroup(BgId uint16) {
	key := BgId

	delete(t.BinGroup, key)
}

// AppendBinGroup appends the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup struct to the
// list BinGroup of SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) AppendBinGroup(v *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) error {
	if v.BgId == nil {
		return fmt.Errorf("invalid nil key received for BgId")
	}

	key := *v.BgId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinGroup == nil {
		t.BinGroup = make(map[uint16]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup)
	}

	if _, ok := t.BinGroup[key]; ok {
		return fmt.Errorf("duplicate key for list BinGroup %v", key)
	}

	t.BinGroup[key] = v
	return nil
}

// NewMeasurementInterval creates a new entry in the MeasurementInterval list of the
// SrlNokiaOam_Oam_Ethcfm_PmonTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) NewMeasurementInterval(MiId uint16) (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MeasurementInterval == nil {
		t.MeasurementInterval = make(map[uint16]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval)
	}

	key := MiId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MeasurementInterval[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MeasurementInterval", key)
	}

	t.MeasurementInterval[key] = &SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval{
		MiId: &MiId,
	}

	return t.MeasurementInterval[key], nil
}

// RenameMeasurementInterval renames an entry in the list MeasurementInterval within
// the SrlNokiaOam_Oam_Ethcfm_PmonTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) RenameMeasurementInterval(oldK, newK uint16) error {
	if _, ok := t.MeasurementInterval[newK]; ok {
		return fmt.Errorf("key %v already exists in MeasurementInterval", newK)
	}

	e, ok := t.MeasurementInterval[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MeasurementInterval", oldK)
	}
	e.MiId = &newK

	t.MeasurementInterval[newK] = e
	delete(t.MeasurementInterval, oldK)
	return nil
}

// GetOrCreateMeasurementInterval retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) GetOrCreateMeasurementInterval(MiId uint16) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval {
	key := MiId

	if v, ok := t.MeasurementInterval[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMeasurementInterval(MiId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMeasurementInterval got unexpected error: %v", err))
	}
	return v
}

// GetMeasurementInterval retrieves the value with the specified key from
// the MeasurementInterval map field of SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) GetMeasurementInterval(MiId uint16) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval {
	if t == nil {
		return nil
	}

	key := MiId

	if lm, ok := t.MeasurementInterval[key]; ok {
		return lm
	}
	return nil
}

// DeleteMeasurementInterval deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) DeleteMeasurementInterval(MiId uint16) {
	key := MiId

	delete(t.MeasurementInterval, key)
}

// AppendMeasurementInterval appends the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval struct to the
// list MeasurementInterval of SrlNokiaOam_Oam_Ethcfm_PmonTemplate. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) AppendMeasurementInterval(
	v *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval,
) error {
	if v.MiId == nil {
		return fmt.Errorf("invalid nil key received for MiId")
	}

	key := *v.MiId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MeasurementInterval == nil {
		t.MeasurementInterval = make(map[uint16]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval)
	}

	if _, ok := t.MeasurementInterval[key]; ok {
		return fmt.Errorf("duplicate key for list MeasurementInterval %v", key)
	}

	t.MeasurementInterval[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_PmonTemplate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.BinGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.MeasurementInterval {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_PmonTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_PmonTemplate.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup represents the /srl_nokia-oam/oam/ethcfm/pmon-template/bin-group YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup struct {
	BgId    *uint16                                                                                                                                                                 `path:"bg-id" module:"srl_nokia-ethcfm-pm"`
	BinType map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType `path:"bin-type" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) IsYANGGoStruct() {}

// NewBinType creates a new entry in the BinType list of the
// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) NewBinType(
	BtId E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId,
) (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinType == nil {
		t.BinType = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType)
	}

	key := BtId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BinType[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BinType", key)
	}

	t.BinType[key] = &SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType{
		BtId: BtId,
	}

	return t.BinType[key], nil
}

// RenameBinType renames an entry in the list BinType within
// the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) RenameBinType(
	oldK, newK E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId,
) error {
	if _, ok := t.BinType[newK]; ok {
		return fmt.Errorf("key %v already exists in BinType", newK)
	}

	e, ok := t.BinType[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BinType", oldK)
	}
	e.BtId = newK

	t.BinType[newK] = e
	delete(t.BinType, oldK)
	return nil
}

// GetOrCreateBinType retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) GetOrCreateBinType(
	BtId E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId,
) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType {
	key := BtId

	if v, ok := t.BinType[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBinType(BtId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBinType got unexpected error: %v", err))
	}
	return v
}

// GetBinType retrieves the value with the specified key from
// the BinType map field of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) GetBinType(
	BtId E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId,
) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType {
	if t == nil {
		return nil
	}

	key := BtId

	if lm, ok := t.BinType[key]; ok {
		return lm
	}
	return nil
}

// DeleteBinType deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) DeleteBinType(
	BtId E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId,
) {
	key := BtId

	delete(t.BinType, key)
}

// AppendBinType appends the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType struct to the
// list BinType of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) AppendBinType(
	v *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType,
) error {
	key := v.BtId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BinType == nil {
		t.BinType = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType)
	}

	if _, ok := t.BinType[key]; ok {
		return fmt.Errorf("duplicate key for list BinType %v", key)
	}

	t.BinType[key] = v
	return nil
}

// GetBgId retrieves the value of the leaf BgId from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BgId is set, it can
// safely use t.GetBgId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BgId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) GetBgId() uint16 {
	if t == nil || t.BgId == nil {
		return 0
	}
	return *t.BgId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.BinType {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BgId == nil {
		return nil, fmt.Errorf("nil value for key BgId")
	}

	return map[string]interface{}{
		"bg-id": *t.BgId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType represents the /srl_nokia-oam/oam/ethcfm/pmon-template/bin-group/bin-type YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType struct {
	Bin        map[uint8]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin                                                                              `path:"bin" module:"srl_nokia-ethcfm-pm"`
	BinCount   *uint8                                                                                                                                           `path:"bin-count" module:"srl_nokia-ethcfm-pm"`
	BtId       E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId                                    `path:"bt-id" module:"srl_nokia-ethcfm-pm"`
	DelayEvent map[E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent `path:"delay-event" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) IsYANGGoStruct() {}

// NewBin creates a new entry in the Bin list of the
// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) NewBin(BinId uint8) (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bin == nil {
		t.Bin = make(map[uint8]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin)
	}

	key := BinId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Bin[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Bin", key)
	}

	t.Bin[key] = &SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin{
		BinId: &BinId,
	}

	return t.Bin[key], nil
}

// RenameBin renames an entry in the list Bin within
// the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) RenameBin(oldK, newK uint8) error {
	if _, ok := t.Bin[newK]; ok {
		return fmt.Errorf("key %v already exists in Bin", newK)
	}

	e, ok := t.Bin[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Bin", oldK)
	}
	e.BinId = &newK

	t.Bin[newK] = e
	delete(t.Bin, oldK)
	return nil
}

// GetOrCreateBin retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) GetOrCreateBin(BinId uint8) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin {
	key := BinId

	if v, ok := t.Bin[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBin(BinId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBin got unexpected error: %v", err))
	}
	return v
}

// GetBin retrieves the value with the specified key from
// the Bin map field of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) GetBin(BinId uint8) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin {
	if t == nil {
		return nil
	}

	key := BinId

	if lm, ok := t.Bin[key]; ok {
		return lm
	}
	return nil
}

// DeleteBin deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) DeleteBin(BinId uint8) {
	key := BinId

	delete(t.Bin, key)
}

// AppendBin appends the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin struct to the
// list Bin of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) AppendBin(
	v *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin,
) error {
	if v.BinId == nil {
		return fmt.Errorf("invalid nil key received for BinId")
	}

	key := *v.BinId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bin == nil {
		t.Bin = make(map[uint8]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin)
	}

	if _, ok := t.Bin[key]; ok {
		return fmt.Errorf("duplicate key for list Bin %v", key)
	}

	t.Bin[key] = v
	return nil
}

// NewDelayEvent creates a new entry in the DelayEvent list of the
// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) NewDelayEvent(
	Direction E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction,
) (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DelayEvent == nil {
		t.DelayEvent = make(map[E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent)
	}

	key := Direction

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DelayEvent[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DelayEvent", key)
	}

	t.DelayEvent[key] = &SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent{
		Direction: Direction,
	}

	return t.DelayEvent[key], nil
}

// RenameDelayEvent renames an entry in the list DelayEvent within
// the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) RenameDelayEvent(
	oldK, newK E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction,
) error {
	if _, ok := t.DelayEvent[newK]; ok {
		return fmt.Errorf("key %v already exists in DelayEvent", newK)
	}

	e, ok := t.DelayEvent[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DelayEvent", oldK)
	}
	e.Direction = newK

	t.DelayEvent[newK] = e
	delete(t.DelayEvent, oldK)
	return nil
}

// GetOrCreateDelayEvent retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) GetOrCreateDelayEvent(
	Direction E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction,
) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent {
	key := Direction

	if v, ok := t.DelayEvent[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDelayEvent(Direction)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDelayEvent got unexpected error: %v", err))
	}
	return v
}

// GetDelayEvent retrieves the value with the specified key from
// the DelayEvent map field of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) GetDelayEvent(
	Direction E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction,
) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent {
	if t == nil {
		return nil
	}

	key := Direction

	if lm, ok := t.DelayEvent[key]; ok {
		return lm
	}
	return nil
}

// DeleteDelayEvent deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) DeleteDelayEvent(
	Direction E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction,
) {
	key := Direction

	delete(t.DelayEvent, key)
}

// AppendDelayEvent appends the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent struct to the
// list DelayEvent of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) AppendDelayEvent(
	v *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent,
) error {
	key := v.Direction

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DelayEvent == nil {
		t.DelayEvent = make(map[E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent)
	}

	if _, ok := t.DelayEvent[key]; ok {
		return fmt.Errorf("duplicate key for list DelayEvent %v", key)
	}

	t.DelayEvent[key] = v
	return nil
}

// GetBinCount retrieves the value of the leaf BinCount from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinCount is set, it can
// safely use t.GetBinCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) GetBinCount() uint8 {
	if t == nil || t.BinCount == nil {
		return 2
	}
	return *t.BinCount
}

// GetBtId retrieves the value of the leaf BtId from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BtId is set, it can
// safely use t.GetBtId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BtId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) GetBtId() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_Interval_BinType_BtId {
	if t == nil || t.BtId == 0 {
		return 0
	}
	return t.BtId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BinCount == nil {
		var v uint8 = 2
		t.BinCount = &v
	}
	for _, e := range t.Bin {
		e.PopulateDefaults()
	}
	for _, e := range t.DelayEvent {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"bt-id": t.BtId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin represents the /srl_nokia-oam/oam/ethcfm/pmon-template/bin-group/bin-type/bin YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin struct {
	BinId      *uint8  `path:"bin-id" module:"srl_nokia-ethcfm-pm"`
	LowerBound *uint32 `path:"lower-bound" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) IsYANGGoStruct() {}

// GetBinId retrieves the value of the leaf BinId from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BinId is set, it can
// safely use t.GetBinId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BinId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) GetBinId() uint8 {
	if t == nil || t.BinId == nil {
		return 0
	}
	return *t.BinId
}

// GetLowerBound retrieves the value of the leaf LowerBound from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowerBound is set, it can
// safely use t.GetLowerBound() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowerBound == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) GetLowerBound() uint32 {
	if t == nil || t.LowerBound == nil {
		return 0
	}
	return *t.LowerBound
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BinId == nil {
		return nil, fmt.Errorf("nil value for key BinId")
	}

	return map[string]interface{}{
		"bin-id": *t.BinId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_Bin) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent represents the /srl_nokia-oam/oam/ethcfm/pmon-template/bin-group/bin-type/delay-event YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent struct {
	ClearThreshold *uint32                                                                     `path:"clear-threshold" module:"srl_nokia-ethcfm-pm"`
	Direction      E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction `path:"direction" module:"srl_nokia-ethcfm-pm"`
	LowestBin      *uint8                                                                      `path:"lowest-bin" module:"srl_nokia-ethcfm-pm"`
	RaiseThreshold *uint32                                                                     `path:"raise-threshold" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) IsYANGGoStruct() {}

// GetClearThreshold retrieves the value of the leaf ClearThreshold from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearThreshold is set, it can
// safely use t.GetClearThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) GetClearThreshold() uint32 {
	if t == nil || t.ClearThreshold == nil {
		return 0
	}
	return *t.ClearThreshold
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) GetDirection() E_SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent_Direction {
	if t == nil || t.Direction == 0 {
		return 0
	}
	return t.Direction
}

// GetLowestBin retrieves the value of the leaf LowestBin from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowestBin is set, it can
// safely use t.GetLowestBin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowestBin == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) GetLowestBin() uint8 {
	if t == nil || t.LowestBin == nil {
		return 0
	}
	return *t.LowestBin
}

// GetRaiseThreshold retrieves the value of the leaf RaiseThreshold from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RaiseThreshold is set, it can
// safely use t.GetRaiseThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RaiseThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) GetRaiseThreshold() uint32 {
	if t == nil || t.RaiseThreshold == nil {
		return 0
	}
	return *t.RaiseThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ClearThreshold == nil {
		var v uint32 = 0
		t.ClearThreshold = &v
	}
	if t.LowestBin == nil {
		var v uint8 = 0
		t.LowestBin = &v
	}
	if t.RaiseThreshold == nil {
		var v uint32 = 0
		t.RaiseThreshold = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"direction": t.Direction,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_BinGroup_BinType_DelayEvent) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval represents the /srl_nokia-oam/oam/ethcfm/pmon-template/measurement-interval YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval struct {
	Duration map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration `path:"duration" module:"srl_nokia-ethcfm-pm"`
	MiId     *uint16                                                                                                                                                              `path:"mi-id" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) IsYANGGoStruct() {}

// NewDuration creates a new entry in the Duration list of the
// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) NewDuration(
	MiType E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType,
) (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Duration == nil {
		t.Duration = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration)
	}

	key := MiType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Duration[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Duration", key)
	}

	t.Duration[key] = &SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration{
		MiType: MiType,
	}

	return t.Duration[key], nil
}

// RenameDuration renames an entry in the list Duration within
// the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) RenameDuration(
	oldK, newK E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType,
) error {
	if _, ok := t.Duration[newK]; ok {
		return fmt.Errorf("key %v already exists in Duration", newK)
	}

	e, ok := t.Duration[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Duration", oldK)
	}
	e.MiType = newK

	t.Duration[newK] = e
	delete(t.Duration, oldK)
	return nil
}

// GetOrCreateDuration retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) GetOrCreateDuration(
	MiType E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType,
) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration {
	key := MiType

	if v, ok := t.Duration[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDuration(MiType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDuration got unexpected error: %v", err))
	}
	return v
}

// GetDuration retrieves the value with the specified key from
// the Duration map field of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) GetDuration(
	MiType E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType,
) *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration {
	if t == nil {
		return nil
	}

	key := MiType

	if lm, ok := t.Duration[key]; ok {
		return lm
	}
	return nil
}

// DeleteDuration deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) DeleteDuration(
	MiType E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType,
) {
	key := MiType

	delete(t.Duration, key)
}

// AppendDuration appends the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration struct to the
// list Duration of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) AppendDuration(
	v *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration,
) error {
	key := v.MiType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Duration == nil {
		t.Duration = make(map[E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType]*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration)
	}

	if _, ok := t.Duration[key]; ok {
		return fmt.Errorf("duplicate key for list Duration %v", key)
	}

	t.Duration[key] = v
	return nil
}

// GetMiId retrieves the value of the leaf MiId from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MiId is set, it can
// safely use t.GetMiId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MiId == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) GetMiId() uint16 {
	if t == nil || t.MiId == nil {
		return 0
	}
	return *t.MiId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Duration {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MiId == nil {
		return nil, fmt.Errorf("nil value for key MiId")
	}

	return map[string]interface{}{
		"mi-id": *t.MiId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration represents the /srl_nokia-oam/oam/ethcfm/pmon-template/measurement-interval/duration YANG schema element.
type SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration struct {
	IntervalCount *uint8                                                                                         `path:"interval-count" module:"srl_nokia-ethcfm-pm"`
	MiType        E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType `path:"mi-type" module:"srl_nokia-ethcfm-pm"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) IsYANGGoStruct() {}

// GetIntervalCount retrieves the value of the leaf IntervalCount from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IntervalCount is set, it can
// safely use t.GetIntervalCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IntervalCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) GetIntervalCount() uint8 {
	if t == nil || t.IntervalCount == nil {
		return 0
	}
	return *t.IntervalCount
}

// GetMiType retrieves the value of the leaf MiType from the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MiType is set, it can
// safely use t.GetMiType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MiType == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) GetMiType() E_SrlNokiaOam_Oam_Ethcfm_Domain_Association_Mep_Pmon_OneWayDm_Session_MeasurementResult_MiType {
	if t == nil || t.MiType == 0 {
		return 0
	}
	return t.MiType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"mi-type": t.MiType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration.
func (*SrlNokiaOam_Oam_Ethcfm_PmonTemplate_MeasurementInterval_Duration) ΛBelongingModule() string {
	return "srl_nokia-ethcfm-pm"
}

// SrlNokiaOam_Oam_Twamp represents the /srl_nokia-oam/oam/twamp YANG schema element.
type SrlNokiaOam_Oam_Twamp struct {
	Server map[string]*SrlNokiaOam_Oam_Twamp_Server `path:"server" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp) IsYANGGoStruct() {}

// NewServer creates a new entry in the Server list of the
// SrlNokiaOam_Oam_Twamp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Twamp) NewServer(NetworkInstanceName string) (*SrlNokiaOam_Oam_Twamp_Server, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaOam_Oam_Twamp_Server)
	}

	key := NetworkInstanceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &SrlNokiaOam_Oam_Twamp_Server{
		NetworkInstanceName: &NetworkInstanceName,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the SrlNokiaOam_Oam_Twamp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Twamp) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.NetworkInstanceName = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Twamp) GetOrCreateServer(NetworkInstanceName string) *SrlNokiaOam_Oam_Twamp_Server {
	key := NetworkInstanceName

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(NetworkInstanceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of SrlNokiaOam_Oam_Twamp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Twamp) GetServer(NetworkInstanceName string) *SrlNokiaOam_Oam_Twamp_Server {
	if t == nil {
		return nil
	}

	key := NetworkInstanceName

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// DeleteServer deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Twamp) DeleteServer(NetworkInstanceName string) {
	key := NetworkInstanceName

	delete(t.Server, key)
}

// AppendServer appends the supplied SrlNokiaOam_Oam_Twamp_Server struct to the
// list Server of SrlNokiaOam_Oam_Twamp. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Twamp_Server already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Twamp) AppendServer(v *SrlNokiaOam_Oam_Twamp_Server) error {
	if v.NetworkInstanceName == nil {
		return fmt.Errorf("invalid nil key received for NetworkInstanceName")
	}

	key := *v.NetworkInstanceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaOam_Oam_Twamp_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Server {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp.
func (*SrlNokiaOam_Oam_Twamp) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaOam_Oam_Twamp_Server represents the /srl_nokia-oam/oam/twamp/server YANG schema element.
type SrlNokiaOam_Oam_Twamp_Server struct {
	AdminState          E_SrlNokiaCommon_AdminState                               `path:"admin-state" module:"srl_nokia-twamp"`
	ClientConnection    map[string]*SrlNokiaOam_Oam_Twamp_Server_ClientConnection `path:"client-connection" module:"srl_nokia-twamp"`
	ControlPacketDscp   E_SrlNokiaCommon_DscpName                                 `path:"control-packet-dscp" module:"srl_nokia-twamp"`
	MaxConnServer       *uint32                                                   `path:"max-conn-server" module:"srl_nokia-twamp"`
	MaxSessServer       *uint32                                                   `path:"max-sess-server" module:"srl_nokia-twamp"`
	NetworkInstanceName *string                                                   `path:"network-instance-name" module:"srl_nokia-twamp"`
	Servwait            *uint32                                                   `path:"servwait" module:"srl_nokia-twamp"`
	SessionReflector    *SrlNokiaOam_Oam_Twamp_Server_SessionReflector            `path:"session-reflector" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp_Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp_Server) IsYANGGoStruct() {}

// NewClientConnection creates a new entry in the ClientConnection list of the
// SrlNokiaOam_Oam_Twamp_Server struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaOam_Oam_Twamp_Server) NewClientConnection(ClientIp string) (*SrlNokiaOam_Oam_Twamp_Server_ClientConnection, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientConnection == nil {
		t.ClientConnection = make(map[string]*SrlNokiaOam_Oam_Twamp_Server_ClientConnection)
	}

	key := ClientIp

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ClientConnection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ClientConnection", key)
	}

	t.ClientConnection[key] = &SrlNokiaOam_Oam_Twamp_Server_ClientConnection{
		ClientIp: &ClientIp,
	}

	return t.ClientConnection[key], nil
}

// RenameClientConnection renames an entry in the list ClientConnection within
// the SrlNokiaOam_Oam_Twamp_Server struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaOam_Oam_Twamp_Server) RenameClientConnection(oldK, newK string) error {
	if _, ok := t.ClientConnection[newK]; ok {
		return fmt.Errorf("key %v already exists in ClientConnection", newK)
	}

	e, ok := t.ClientConnection[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ClientConnection", oldK)
	}
	e.ClientIp = &newK

	t.ClientConnection[newK] = e
	delete(t.ClientConnection, oldK)
	return nil
}

// GetOrCreateClientConnection retrieves the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp_Server. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetOrCreateClientConnection(ClientIp string) *SrlNokiaOam_Oam_Twamp_Server_ClientConnection {
	key := ClientIp

	if v, ok := t.ClientConnection[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewClientConnection(ClientIp)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateClientConnection got unexpected error: %v", err))
	}
	return v
}

// GetClientConnection retrieves the value with the specified key from
// the ClientConnection map field of SrlNokiaOam_Oam_Twamp_Server. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetClientConnection(ClientIp string) *SrlNokiaOam_Oam_Twamp_Server_ClientConnection {
	if t == nil {
		return nil
	}

	key := ClientIp

	if lm, ok := t.ClientConnection[key]; ok {
		return lm
	}
	return nil
}

// DeleteClientConnection deletes the value with the specified keys from
// the receiver SrlNokiaOam_Oam_Twamp_Server. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaOam_Oam_Twamp_Server) DeleteClientConnection(ClientIp string) {
	key := ClientIp

	delete(t.ClientConnection, key)
}

// AppendClientConnection appends the supplied SrlNokiaOam_Oam_Twamp_Server_ClientConnection struct to the
// list ClientConnection of SrlNokiaOam_Oam_Twamp_Server. If the key value(s) specified in
// the supplied SrlNokiaOam_Oam_Twamp_Server_ClientConnection already exist in the list, an error is
// returned.
func (t *SrlNokiaOam_Oam_Twamp_Server) AppendClientConnection(v *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) error {
	if v.ClientIp == nil {
		return fmt.Errorf("invalid nil key received for ClientIp")
	}

	key := *v.ClientIp

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientConnection == nil {
		t.ClientConnection = make(map[string]*SrlNokiaOam_Oam_Twamp_Server_ClientConnection)
	}

	if _, ok := t.ClientConnection[key]; ok {
		return fmt.Errorf("duplicate key for list ClientConnection %v", key)
	}

	t.ClientConnection[key] = v
	return nil
}

// GetOrCreateSessionReflector retrieves the value of the SessionReflector field
// or returns the existing field if it already exists.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetOrCreateSessionReflector() *SrlNokiaOam_Oam_Twamp_Server_SessionReflector {
	if t.SessionReflector != nil {
		return t.SessionReflector
	}
	t.SessionReflector = &SrlNokiaOam_Oam_Twamp_Server_SessionReflector{}
	return t.SessionReflector
}

// GetSessionReflector returns the value of the SessionReflector struct pointer
// from SrlNokiaOam_Oam_Twamp_Server. If the receiver or the field SessionReflector is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetSessionReflector() *SrlNokiaOam_Oam_Twamp_Server_SessionReflector {
	if t != nil && t.SessionReflector != nil {
		return t.SessionReflector
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaOam_Oam_Twamp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetControlPacketDscp retrieves the value of the leaf ControlPacketDscp from the SrlNokiaOam_Oam_Twamp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ControlPacketDscp is set, it can
// safely use t.GetControlPacketDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ControlPacketDscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetControlPacketDscp() E_SrlNokiaCommon_DscpName {
	if t == nil || t.ControlPacketDscp == 0 {
		return SrlNokiaCommon_DscpName_CS7
	}
	return t.ControlPacketDscp
}

// GetMaxConnServer retrieves the value of the leaf MaxConnServer from the SrlNokiaOam_Oam_Twamp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxConnServer is set, it can
// safely use t.GetMaxConnServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxConnServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetMaxConnServer() uint32 {
	if t == nil || t.MaxConnServer == nil {
		return 32
	}
	return *t.MaxConnServer
}

// GetMaxSessServer retrieves the value of the leaf MaxSessServer from the SrlNokiaOam_Oam_Twamp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxSessServer is set, it can
// safely use t.GetMaxSessServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxSessServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetMaxSessServer() uint32 {
	if t == nil || t.MaxSessServer == nil {
		return 32
	}
	return *t.MaxSessServer
}

// GetNetworkInstanceName retrieves the value of the leaf NetworkInstanceName from the SrlNokiaOam_Oam_Twamp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstanceName is set, it can
// safely use t.GetNetworkInstanceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstanceName == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetNetworkInstanceName() string {
	if t == nil || t.NetworkInstanceName == nil {
		return ""
	}
	return *t.NetworkInstanceName
}

// GetServwait retrieves the value of the leaf Servwait from the SrlNokiaOam_Oam_Twamp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Servwait is set, it can
// safely use t.GetServwait() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Servwait == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server) GetServwait() uint32 {
	if t == nil || t.Servwait == nil {
		return 900
	}
	return *t.Servwait
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp_Server
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp_Server) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.ControlPacketDscp == 0 {
		t.ControlPacketDscp = SrlNokiaCommon_DscpName_CS7
	}
	if t.MaxConnServer == nil {
		var v uint32 = 32
		t.MaxConnServer = &v
	}
	if t.MaxSessServer == nil {
		var v uint32 = 32
		t.MaxSessServer = &v
	}
	if t.Servwait == nil {
		var v uint32 = 900
		t.Servwait = &v
	}
	t.SessionReflector.PopulateDefaults()
	for _, e := range t.ClientConnection {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Twamp_Server struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Twamp_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NetworkInstanceName == nil {
		return nil, fmt.Errorf("nil value for key NetworkInstanceName")
	}

	return map[string]interface{}{
		"network-instance-name": *t.NetworkInstanceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp_Server.
func (*SrlNokiaOam_Oam_Twamp_Server) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaOam_Oam_Twamp_Server_ClientConnection represents the /srl_nokia-oam/oam/twamp/server/client-connection YANG schema element.
type SrlNokiaOam_Oam_Twamp_Server_ClientConnection struct {
	ClientIp      *string `path:"client-ip" module:"srl_nokia-twamp"`
	MaxConnServer *uint32 `path:"max-conn-server" module:"srl_nokia-twamp"`
	MaxSessServer *uint32 `path:"max-sess-server" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp_Server_ClientConnection implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp_Server_ClientConnection) IsYANGGoStruct() {}

// GetClientIp retrieves the value of the leaf ClientIp from the SrlNokiaOam_Oam_Twamp_Server_ClientConnection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClientIp is set, it can
// safely use t.GetClientIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClientIp == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) GetClientIp() string {
	if t == nil || t.ClientIp == nil {
		return ""
	}
	return *t.ClientIp
}

// GetMaxConnServer retrieves the value of the leaf MaxConnServer from the SrlNokiaOam_Oam_Twamp_Server_ClientConnection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxConnServer is set, it can
// safely use t.GetMaxConnServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxConnServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) GetMaxConnServer() uint32 {
	if t == nil || t.MaxConnServer == nil {
		return 0
	}
	return *t.MaxConnServer
}

// GetMaxSessServer retrieves the value of the leaf MaxSessServer from the SrlNokiaOam_Oam_Twamp_Server_ClientConnection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxSessServer is set, it can
// safely use t.GetMaxSessServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxSessServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) GetMaxSessServer() uint32 {
	if t == nil || t.MaxSessServer == nil {
		return 0
	}
	return *t.MaxSessServer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp_Server_ClientConnection
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaOam_Oam_Twamp_Server_ClientConnection struct, which is a YANG list entry.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ClientIp == nil {
		return nil, fmt.Errorf("nil value for key ClientIp")
	}

	return map[string]interface{}{
		"client-ip": *t.ClientIp,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp_Server_ClientConnection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp_Server_ClientConnection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp_Server_ClientConnection.
func (*SrlNokiaOam_Oam_Twamp_Server_ClientConnection) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaOam_Oam_Twamp_Server_SessionReflector represents the /srl_nokia-oam/oam/twamp/server/session-reflector YANG schema element.
type SrlNokiaOam_Oam_Twamp_Server_SessionReflector struct {
	Refwait *uint32 `path:"refwait" module:"srl_nokia-twamp"`
}

// IsYANGGoStruct ensures that SrlNokiaOam_Oam_Twamp_Server_SessionReflector implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaOam_Oam_Twamp_Server_SessionReflector) IsYANGGoStruct() {}

// GetRefwait retrieves the value of the leaf Refwait from the SrlNokiaOam_Oam_Twamp_Server_SessionReflector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Refwait is set, it can
// safely use t.GetRefwait() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Refwait == nil' before retrieving the leaf's value.
func (t *SrlNokiaOam_Oam_Twamp_Server_SessionReflector) GetRefwait() uint32 {
	if t == nil || t.Refwait == nil {
		return 900
	}
	return *t.Refwait
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaOam_Oam_Twamp_Server_SessionReflector
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaOam_Oam_Twamp_Server_SessionReflector) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Refwait == nil {
		var v uint32 = 900
		t.Refwait = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_SessionReflector) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaOam_Oam_Twamp_Server_SessionReflector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaOam_Oam_Twamp_Server_SessionReflector) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaOam_Oam_Twamp_Server_SessionReflector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaOam_Oam_Twamp_Server_SessionReflector.
func (*SrlNokiaOam_Oam_Twamp_Server_SessionReflector) ΛBelongingModule() string {
	return "srl_nokia-twamp"
}

// SrlNokiaPlatform_Platform represents the /srl_nokia-platform/platform YANG schema element.
type SrlNokiaPlatform_Platform struct {
	Chassis            *SrlNokiaPlatform_Platform_Chassis            `path:"chassis" module:"srl_nokia-platform-chassis"`
	Control            map[string]*SrlNokiaPlatform_Platform_Control `path:"control" module:"srl_nokia-platform-control"`
	Fabric             map[uint8]*SrlNokiaPlatform_Platform_Fabric   `path:"fabric" module:"srl_nokia-platform-fabric"`
	Linecard           map[uint8]*SrlNokiaPlatform_Platform_Linecard `path:"linecard" module:"srl_nokia-platform-lc"`
	Redundancy         *SrlNokiaPlatform_Platform_Redundancy         `path:"redundancy" module:"srl_nokia-platform-redundancy"`
	ResourceManagement *SrlNokiaPlatform_Platform_ResourceManagement `path:"resource-management" module:"srl_nokia-platform-resource-mgmt"`
	ResourceMonitoring *SrlNokiaPlatform_Platform_ResourceMonitoring `path:"resource-monitoring" module:"srl_nokia-platform-resource-monitoring"`
	Vxdp               *SrlNokiaPlatform_Platform_Vxdp               `path:"vxdp" module:"srl_nokia-platform-vxdp" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform) IsYANGGoStruct() {}

// NewControl creates a new entry in the Control list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewControl(Slot string) (*SrlNokiaPlatform_Platform_Control, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Control == nil {
		t.Control = make(map[string]*SrlNokiaPlatform_Platform_Control)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Control[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Control", key)
	}

	t.Control[key] = &SrlNokiaPlatform_Platform_Control{
		Slot: &Slot,
	}

	return t.Control[key], nil
}

// RenameControl renames an entry in the list Control within
// the SrlNokiaPlatform_Platform struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform) RenameControl(oldK, newK string) error {
	if _, ok := t.Control[newK]; ok {
		return fmt.Errorf("key %v already exists in Control", newK)
	}

	e, ok := t.Control[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Control", oldK)
	}
	e.Slot = &newK

	t.Control[newK] = e
	delete(t.Control, oldK)
	return nil
}

// GetOrCreateControl retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform) GetOrCreateControl(Slot string) *SrlNokiaPlatform_Platform_Control {
	key := Slot

	if v, ok := t.Control[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewControl(Slot)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateControl got unexpected error: %v", err))
	}
	return v
}

// GetControl retrieves the value with the specified key from
// the Control map field of SrlNokiaPlatform_Platform. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform) GetControl(Slot string) *SrlNokiaPlatform_Platform_Control {
	if t == nil {
		return nil
	}

	key := Slot

	if lm, ok := t.Control[key]; ok {
		return lm
	}
	return nil
}

// DeleteControl deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform) DeleteControl(Slot string) {
	key := Slot

	delete(t.Control, key)
}

// AppendControl appends the supplied SrlNokiaPlatform_Platform_Control struct to the
// list Control of SrlNokiaPlatform_Platform. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Control already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform) AppendControl(v *SrlNokiaPlatform_Platform_Control) error {
	if v.Slot == nil {
		return fmt.Errorf("invalid nil key received for Slot")
	}

	key := *v.Slot

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Control == nil {
		t.Control = make(map[string]*SrlNokiaPlatform_Platform_Control)
	}

	if _, ok := t.Control[key]; ok {
		return fmt.Errorf("duplicate key for list Control %v", key)
	}

	t.Control[key] = v
	return nil
}

// NewFabric creates a new entry in the Fabric list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewFabric(Slot uint8) (*SrlNokiaPlatform_Platform_Fabric, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Fabric == nil {
		t.Fabric = make(map[uint8]*SrlNokiaPlatform_Platform_Fabric)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Fabric[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Fabric", key)
	}

	t.Fabric[key] = &SrlNokiaPlatform_Platform_Fabric{
		Slot: &Slot,
	}

	return t.Fabric[key], nil
}

// RenameFabric renames an entry in the list Fabric within
// the SrlNokiaPlatform_Platform struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform) RenameFabric(oldK, newK uint8) error {
	if _, ok := t.Fabric[newK]; ok {
		return fmt.Errorf("key %v already exists in Fabric", newK)
	}

	e, ok := t.Fabric[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Fabric", oldK)
	}
	e.Slot = &newK

	t.Fabric[newK] = e
	delete(t.Fabric, oldK)
	return nil
}

// GetOrCreateFabric retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform) GetOrCreateFabric(Slot uint8) *SrlNokiaPlatform_Platform_Fabric {
	key := Slot

	if v, ok := t.Fabric[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFabric(Slot)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFabric got unexpected error: %v", err))
	}
	return v
}

// GetFabric retrieves the value with the specified key from
// the Fabric map field of SrlNokiaPlatform_Platform. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform) GetFabric(Slot uint8) *SrlNokiaPlatform_Platform_Fabric {
	if t == nil {
		return nil
	}

	key := Slot

	if lm, ok := t.Fabric[key]; ok {
		return lm
	}
	return nil
}

// DeleteFabric deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform) DeleteFabric(Slot uint8) {
	key := Slot

	delete(t.Fabric, key)
}

// AppendFabric appends the supplied SrlNokiaPlatform_Platform_Fabric struct to the
// list Fabric of SrlNokiaPlatform_Platform. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Fabric already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform) AppendFabric(v *SrlNokiaPlatform_Platform_Fabric) error {
	if v.Slot == nil {
		return fmt.Errorf("invalid nil key received for Slot")
	}

	key := *v.Slot

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Fabric == nil {
		t.Fabric = make(map[uint8]*SrlNokiaPlatform_Platform_Fabric)
	}

	if _, ok := t.Fabric[key]; ok {
		return fmt.Errorf("duplicate key for list Fabric %v", key)
	}

	t.Fabric[key] = v
	return nil
}

// NewLinecard creates a new entry in the Linecard list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewLinecard(Slot uint8) (*SrlNokiaPlatform_Platform_Linecard, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Linecard == nil {
		t.Linecard = make(map[uint8]*SrlNokiaPlatform_Platform_Linecard)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Linecard[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Linecard", key)
	}

	t.Linecard[key] = &SrlNokiaPlatform_Platform_Linecard{
		Slot: &Slot,
	}

	return t.Linecard[key], nil
}

// RenameLinecard renames an entry in the list Linecard within
// the SrlNokiaPlatform_Platform struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform) RenameLinecard(oldK, newK uint8) error {
	if _, ok := t.Linecard[newK]; ok {
		return fmt.Errorf("key %v already exists in Linecard", newK)
	}

	e, ok := t.Linecard[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Linecard", oldK)
	}
	e.Slot = &newK

	t.Linecard[newK] = e
	delete(t.Linecard, oldK)
	return nil
}

// GetOrCreateLinecard retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform) GetOrCreateLinecard(Slot uint8) *SrlNokiaPlatform_Platform_Linecard {
	key := Slot

	if v, ok := t.Linecard[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLinecard(Slot)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLinecard got unexpected error: %v", err))
	}
	return v
}

// GetLinecard retrieves the value with the specified key from
// the Linecard map field of SrlNokiaPlatform_Platform. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform) GetLinecard(Slot uint8) *SrlNokiaPlatform_Platform_Linecard {
	if t == nil {
		return nil
	}

	key := Slot

	if lm, ok := t.Linecard[key]; ok {
		return lm
	}
	return nil
}

// DeleteLinecard deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform) DeleteLinecard(Slot uint8) {
	key := Slot

	delete(t.Linecard, key)
}

// AppendLinecard appends the supplied SrlNokiaPlatform_Platform_Linecard struct to the
// list Linecard of SrlNokiaPlatform_Platform. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Linecard already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform) AppendLinecard(v *SrlNokiaPlatform_Platform_Linecard) error {
	if v.Slot == nil {
		return fmt.Errorf("invalid nil key received for Slot")
	}

	key := *v.Slot

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Linecard == nil {
		t.Linecard = make(map[uint8]*SrlNokiaPlatform_Platform_Linecard)
	}

	if _, ok := t.Linecard[key]; ok {
		return fmt.Errorf("duplicate key for list Linecard %v", key)
	}

	t.Linecard[key] = v
	return nil
}

// GetOrCreateChassis retrieves the value of the Chassis field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateChassis() *SrlNokiaPlatform_Platform_Chassis {
	if t.Chassis != nil {
		return t.Chassis
	}
	t.Chassis = &SrlNokiaPlatform_Platform_Chassis{}
	return t.Chassis
}

// GetOrCreateRedundancy retrieves the value of the Redundancy field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateRedundancy() *SrlNokiaPlatform_Platform_Redundancy {
	if t.Redundancy != nil {
		return t.Redundancy
	}
	t.Redundancy = &SrlNokiaPlatform_Platform_Redundancy{}
	return t.Redundancy
}

// GetOrCreateResourceManagement retrieves the value of the ResourceManagement field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateResourceManagement() *SrlNokiaPlatform_Platform_ResourceManagement {
	if t.ResourceManagement != nil {
		return t.ResourceManagement
	}
	t.ResourceManagement = &SrlNokiaPlatform_Platform_ResourceManagement{}
	return t.ResourceManagement
}

// GetOrCreateResourceMonitoring retrieves the value of the ResourceMonitoring field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateResourceMonitoring() *SrlNokiaPlatform_Platform_ResourceMonitoring {
	if t.ResourceMonitoring != nil {
		return t.ResourceMonitoring
	}
	t.ResourceMonitoring = &SrlNokiaPlatform_Platform_ResourceMonitoring{}
	return t.ResourceMonitoring
}

// GetOrCreateVxdp retrieves the value of the Vxdp field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform) GetOrCreateVxdp() *SrlNokiaPlatform_Platform_Vxdp {
	if t.Vxdp != nil {
		return t.Vxdp
	}
	t.Vxdp = &SrlNokiaPlatform_Platform_Vxdp{}
	return t.Vxdp
}

// GetChassis returns the value of the Chassis struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field Chassis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetChassis() *SrlNokiaPlatform_Platform_Chassis {
	if t != nil && t.Chassis != nil {
		return t.Chassis
	}
	return nil
}

// GetRedundancy returns the value of the Redundancy struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field Redundancy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetRedundancy() *SrlNokiaPlatform_Platform_Redundancy {
	if t != nil && t.Redundancy != nil {
		return t.Redundancy
	}
	return nil
}

// GetResourceManagement returns the value of the ResourceManagement struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field ResourceManagement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetResourceManagement() *SrlNokiaPlatform_Platform_ResourceManagement {
	if t != nil && t.ResourceManagement != nil {
		return t.ResourceManagement
	}
	return nil
}

// GetResourceMonitoring returns the value of the ResourceMonitoring struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field ResourceMonitoring is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetResourceMonitoring() *SrlNokiaPlatform_Platform_ResourceMonitoring {
	if t != nil && t.ResourceMonitoring != nil {
		return t.ResourceMonitoring
	}
	return nil
}

// GetVxdp returns the value of the Vxdp struct pointer
// from SrlNokiaPlatform_Platform. If the receiver or the field Vxdp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform) GetVxdp() *SrlNokiaPlatform_Platform_Vxdp {
	if t != nil && t.Vxdp != nil {
		return t.Vxdp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Chassis.PopulateDefaults()
	t.Redundancy.PopulateDefaults()
	t.ResourceManagement.PopulateDefaults()
	t.ResourceMonitoring.PopulateDefaults()
	t.Vxdp.PopulateDefaults()
	for _, e := range t.Control {
		e.PopulateDefaults()
	}
	for _, e := range t.Fabric {
		e.PopulateDefaults()
	}
	for _, e := range t.Linecard {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform.
func (*SrlNokiaPlatform_Platform) ΛBelongingModule() string {
	return "srl_nokia-platform"
}

// SrlNokiaPlatform_Platform_Chassis represents the /srl_nokia-platform/platform/chassis YANG schema element.
type SrlNokiaPlatform_Platform_Chassis struct {
	MacAddress           *string                                  `path:"mac-address" module:"srl_nokia-platform-vxdp"`
	MacAddressAllocation *uint32                                  `path:"mac-address-allocation" module:"srl_nokia-platform-vxdp"`
	Power                *SrlNokiaPlatform_Platform_Chassis_Power `path:"power" module:"srl_nokia-platform-chassis"`
	SecondaryMacAddress  *string                                  `path:"secondary-mac-address" module:"srl_nokia-platform-chassis"`
	Uuid                 *string                                  `path:"uuid" module:"srl_nokia-platform-vxdp"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Chassis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Chassis) IsYANGGoStruct() {}

// GetOrCreatePower retrieves the value of the Power field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Chassis) GetOrCreatePower() *SrlNokiaPlatform_Platform_Chassis_Power {
	if t.Power != nil {
		return t.Power
	}
	t.Power = &SrlNokiaPlatform_Platform_Chassis_Power{}
	return t.Power
}

// GetPower returns the value of the Power struct pointer
// from SrlNokiaPlatform_Platform_Chassis. If the receiver or the field Power is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Chassis) GetPower() *SrlNokiaPlatform_Platform_Chassis_Power {
	if t != nil && t.Power != nil {
		return t.Power
	}
	return nil
}

// GetMacAddress retrieves the value of the leaf MacAddress from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetMacAddressAllocation retrieves the value of the leaf MacAddressAllocation from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddressAllocation is set, it can
// safely use t.GetMacAddressAllocation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddressAllocation == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetMacAddressAllocation() uint32 {
	if t == nil || t.MacAddressAllocation == nil {
		return 1024
	}
	return *t.MacAddressAllocation
}

// GetSecondaryMacAddress retrieves the value of the leaf SecondaryMacAddress from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecondaryMacAddress is set, it can
// safely use t.GetSecondaryMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecondaryMacAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetSecondaryMacAddress() string {
	if t == nil || t.SecondaryMacAddress == nil {
		return ""
	}
	return *t.SecondaryMacAddress
}

// GetUuid retrieves the value of the leaf Uuid from the SrlNokiaPlatform_Platform_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uuid is set, it can
// safely use t.GetUuid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uuid == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis) GetUuid() string {
	if t == nil || t.Uuid == nil {
		return ""
	}
	return *t.Uuid
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Chassis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Chassis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MacAddressAllocation == nil {
		var v uint32 = 1024
		t.MacAddressAllocation = &v
	}
	t.Power.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Chassis.
func (*SrlNokiaPlatform_Platform_Chassis) ΛBelongingModule() string {
	return "srl_nokia-platform-chassis"
}

// SrlNokiaPlatform_Platform_Chassis_Power represents the /srl_nokia-platform/platform/chassis/power YANG schema element.
type SrlNokiaPlatform_Platform_Chassis_Power struct {
	Redundancy *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy `path:"redundancy" module:"srl_nokia-platform-chassis"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Chassis_Power implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Chassis_Power) IsYANGGoStruct() {}

// GetOrCreateRedundancy retrieves the value of the Redundancy field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) GetOrCreateRedundancy() *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy {
	if t.Redundancy != nil {
		return t.Redundancy
	}
	t.Redundancy = &SrlNokiaPlatform_Platform_Chassis_Power_Redundancy{}
	return t.Redundancy
}

// GetRedundancy returns the value of the Redundancy struct pointer
// from SrlNokiaPlatform_Platform_Chassis_Power. If the receiver or the field Redundancy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) GetRedundancy() *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy {
	if t != nil && t.Redundancy != nil {
		return t.Redundancy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Chassis_Power
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Redundancy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Chassis_Power.
func (*SrlNokiaPlatform_Platform_Chassis_Power) ΛBelongingModule() string {
	return "srl_nokia-platform-chassis"
}

// SrlNokiaPlatform_Platform_Chassis_Power_Redundancy represents the /srl_nokia-platform/platform/chassis/power/redundancy YANG schema element.
type SrlNokiaPlatform_Platform_Chassis_Power_Redundancy struct {
	Mode E_SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode `path:"mode" module:"srl_nokia-platform-chassis"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Chassis_Power_Redundancy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the SrlNokiaPlatform_Platform_Chassis_Power_Redundancy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) GetMode() E_SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode {
	if t == nil || t.Mode == 0 {
		return SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode_none
	}
	return t.Mode
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Chassis_Power_Redundancy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = SrlNokiaPlatform_Platform_Chassis_Power_Redundancy_Mode_none
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power_Redundancy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Chassis_Power_Redundancy.
func (*SrlNokiaPlatform_Platform_Chassis_Power_Redundancy) ΛBelongingModule() string {
	return "srl_nokia-platform-chassis"
}

// SrlNokiaPlatform_Platform_Control represents the /srl_nokia-platform/platform/control YANG schema element.
type SrlNokiaPlatform_Platform_Control struct {
	Interface map[E_SrlNokiaPlatformControl_ControlInterfaces]*SrlNokiaPlatform_Platform_Control_Interface `path:"interface" module:"srl_nokia-platform-control"`
	Slot      *string                                                                                      `path:"slot" module:"srl_nokia-platform-control"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Control implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Control) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaPlatform_Platform_Control struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Control) NewInterface(Name E_SrlNokiaPlatformControl_ControlInterfaces) (*SrlNokiaPlatform_Platform_Control_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[E_SrlNokiaPlatformControl_ControlInterfaces]*SrlNokiaPlatform_Platform_Control_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaPlatform_Platform_Control_Interface{
		Name: Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaPlatform_Platform_Control struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_Control) RenameInterface(
	oldK, newK E_SrlNokiaPlatformControl_ControlInterfaces,
) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Control. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_Control) GetOrCreateInterface(
	Name E_SrlNokiaPlatformControl_ControlInterfaces,
) *SrlNokiaPlatform_Platform_Control_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaPlatform_Platform_Control. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_Control) GetInterface(Name E_SrlNokiaPlatformControl_ControlInterfaces) *SrlNokiaPlatform_Platform_Control_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Control. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_Control) DeleteInterface(Name E_SrlNokiaPlatformControl_ControlInterfaces) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaPlatform_Platform_Control_Interface struct to the
// list Interface of SrlNokiaPlatform_Platform_Control. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Control_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_Control) AppendInterface(v *SrlNokiaPlatform_Platform_Control_Interface) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[E_SrlNokiaPlatformControl_ControlInterfaces]*SrlNokiaPlatform_Platform_Control_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// GetSlot retrieves the value of the leaf Slot from the SrlNokiaPlatform_Platform_Control
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Slot is set, it can
// safely use t.GetSlot() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Slot == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Control) GetSlot() string {
	if t == nil || t.Slot == nil {
		return ""
	}
	return *t.Slot
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Control
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Control) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Control.
func (*SrlNokiaPlatform_Platform_Control) ΛBelongingModule() string {
	return "srl_nokia-platform-control"
}

// SrlNokiaPlatform_Platform_Control_Interface represents the /srl_nokia-platform/platform/control/interface YANG schema element.
type SrlNokiaPlatform_Platform_Control_Interface struct {
	AdminState E_SrlNokiaCommon_AdminState                 `path:"admin-state" module:"srl_nokia-platform-control"`
	Name       E_SrlNokiaPlatformControl_ControlInterfaces `path:"name" module:"srl_nokia-platform-control"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Control_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Control_Interface) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaPlatform_Platform_Control_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Control_Interface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_Control_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Control_Interface) GetName() E_SrlNokiaPlatformControl_ControlInterfaces {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Control_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Control_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control_Interface struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Control_Interface.
func (*SrlNokiaPlatform_Platform_Control_Interface) ΛBelongingModule() string {
	return "srl_nokia-platform-control"
}

// SrlNokiaPlatform_Platform_Fabric represents the /srl_nokia-platform/platform/fabric YANG schema element.
type SrlNokiaPlatform_Platform_Fabric struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-platform-fabric"`
	Slot       *uint8                      `path:"slot" module:"srl_nokia-platform-fabric"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Fabric implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Fabric) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaPlatform_Platform_Fabric
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Fabric) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetSlot retrieves the value of the leaf Slot from the SrlNokiaPlatform_Platform_Fabric
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Slot is set, it can
// safely use t.GetSlot() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Slot == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Fabric) GetSlot() uint8 {
	if t == nil || t.Slot == nil {
		return 0
	}
	return *t.Slot
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Fabric
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Fabric) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Fabric struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Fabric) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Fabric.
func (*SrlNokiaPlatform_Platform_Fabric) ΛBelongingModule() string {
	return "srl_nokia-platform-fabric"
}

// SrlNokiaPlatform_Platform_Linecard represents the /srl_nokia-platform/platform/linecard YANG schema element.
type SrlNokiaPlatform_Platform_Linecard struct {
	AdminState        E_SrlNokiaCommon_AdminState                                                                                           `path:"admin-state" module:"srl_nokia-platform-lc"`
	ForwardingComplex map[E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex `path:"forwarding-complex" module:"srl_nokia-platform-lc"`
	Slot              *uint8                                                                                                                `path:"slot" module:"srl_nokia-platform-lc"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard) IsYANGGoStruct() {}

// NewForwardingComplex creates a new entry in the ForwardingComplex list of the
// SrlNokiaPlatform_Platform_Linecard struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard) NewForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingComplex == nil {
		t.ForwardingComplex = make(map[E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingComplex[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingComplex", key)
	}

	t.ForwardingComplex[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex{
		Name: Name,
	}

	return t.ForwardingComplex[key], nil
}

// RenameForwardingComplex renames an entry in the list ForwardingComplex within
// the SrlNokiaPlatform_Platform_Linecard struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_Linecard) RenameForwardingComplex(
	oldK, newK E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) error {
	if _, ok := t.ForwardingComplex[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingComplex", newK)
	}

	e, ok := t.ForwardingComplex[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingComplex", oldK)
	}
	e.Name = newK

	t.ForwardingComplex[newK] = e
	delete(t.ForwardingComplex, oldK)
	return nil
}

// GetOrCreateForwardingComplex retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_Linecard) GetOrCreateForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex {
	key := Name

	if v, ok := t.ForwardingComplex[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingComplex(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingComplex got unexpected error: %v", err))
	}
	return v
}

// GetForwardingComplex retrieves the value with the specified key from
// the ForwardingComplex map field of SrlNokiaPlatform_Platform_Linecard. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard) GetForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ForwardingComplex[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingComplex deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_Linecard) DeleteForwardingComplex(
	Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name,
) {
	key := Name

	delete(t.ForwardingComplex, key)
}

// AppendForwardingComplex appends the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct to the
// list ForwardingComplex of SrlNokiaPlatform_Platform_Linecard. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_Linecard) AppendForwardingComplex(
	v *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingComplex == nil {
		t.ForwardingComplex = make(map[E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex)
	}

	if _, ok := t.ForwardingComplex[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingComplex %v", key)
	}

	t.ForwardingComplex[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaPlatform_Platform_Linecard
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetSlot retrieves the value of the leaf Slot from the SrlNokiaPlatform_Platform_Linecard
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Slot is set, it can
// safely use t.GetSlot() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Slot == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard) GetSlot() uint8 {
	if t == nil || t.Slot == nil {
		return 0
	}
	return *t.Slot
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	for _, e := range t.ForwardingComplex {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard.
func (*SrlNokiaPlatform_Platform_Linecard) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex represents the /srl_nokia-platform/platform/linecard/forwarding-complex YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct {
	BufferMemory *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory                                                                           `path:"buffer-memory" module:"srl_nokia-platform-qos"`
	Fabric       *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric                                                                                 `path:"fabric" module:"srl_nokia-platform-lc"`
	Name         E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name                                                                                  `path:"name" module:"srl_nokia-platform-lc"`
	P4Rt         *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt                                                                                   `path:"p4rt" module:"srl_nokia-platform-p4rt" yangPresence:"true"`
	Pipeline     map[SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline `path:"pipeline" module:"srl_nokia-platform-lc"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) IsYANGGoStruct() {}

// NewPipeline creates a new entry in the Pipeline list of the
// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) NewPipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pipeline == nil {
		t.Pipeline = make(map[SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Pipeline[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Pipeline", key)
	}

	t.Pipeline[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline{
		Index: Index,
	}

	return t.Pipeline[key], nil
}

// RenamePipeline renames an entry in the list Pipeline within
// the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) RenamePipeline(
	oldK, newK SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) error {
	if _, ok := t.Pipeline[newK]; ok {
		return fmt.Errorf("key %v already exists in Pipeline", newK)
	}

	e, ok := t.Pipeline[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Pipeline", oldK)
	}
	e.Index = newK

	t.Pipeline[newK] = e
	delete(t.Pipeline, oldK)
	return nil
}

// GetOrCreatePipeline retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreatePipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline {
	key := Index

	if v, ok := t.Pipeline[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPipeline(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePipeline got unexpected error: %v", err))
	}
	return v
}

// GetPipeline retrieves the value with the specified key from
// the Pipeline map field of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetPipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Pipeline[key]; ok {
		return lm
	}
	return nil
}

// DeletePipeline deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) DeletePipeline(
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union,
) {
	key := Index

	delete(t.Pipeline, key)
}

// AppendPipeline appends the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline struct to the
// list Pipeline of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) AppendPipeline(
	v *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline,
) error {
	key := v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pipeline == nil {
		t.Pipeline = make(map[SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline)
	}

	if _, ok := t.Pipeline[key]; ok {
		return fmt.Errorf("duplicate key for list Pipeline %v", key)
	}

	t.Pipeline[key] = v
	return nil
}

// GetOrCreateBufferMemory retrieves the value of the BufferMemory field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreateBufferMemory() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory {
	if t.BufferMemory != nil {
		return t.BufferMemory
	}
	t.BufferMemory = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory{}
	return t.BufferMemory
}

// GetOrCreateFabric retrieves the value of the Fabric field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreateFabric() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric {
	if t.Fabric != nil {
		return t.Fabric
	}
	t.Fabric = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric{}
	return t.Fabric
}

// GetOrCreateP4Rt retrieves the value of the P4Rt field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetOrCreateP4Rt() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt {
	if t.P4Rt != nil {
		return t.P4Rt
	}
	t.P4Rt = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt{}
	return t.P4Rt
}

// GetBufferMemory returns the value of the BufferMemory struct pointer
// from SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver or the field BufferMemory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetBufferMemory() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory {
	if t != nil && t.BufferMemory != nil {
		return t.BufferMemory
	}
	return nil
}

// GetFabric returns the value of the Fabric struct pointer
// from SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver or the field Fabric is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetFabric() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric {
	if t != nil && t.Fabric != nil {
		return t.Fabric
	}
	return nil
}

// GetP4Rt returns the value of the P4Rt struct pointer
// from SrlNokiaPlatform_Platform_Linecard_ForwardingComplex. If the receiver or the field P4Rt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetP4Rt() *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt {
	if t != nil && t.P4Rt != nil {
		return t.P4Rt
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) GetName() E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.BufferMemory.PopulateDefaults()
	t.Fabric.PopulateDefaults()
	t.P4Rt.PopulateDefaults()
	for _, e := range t.Pipeline {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory represents the /srl_nokia-platform/platform/linecard/forwarding-complex/buffer-memory YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory struct{}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) ΛBelongingModule() string {
	return "srl_nokia-platform-qos"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric represents the /srl_nokia-platform/platform/linecard/forwarding-complex/fabric YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric struct{}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Fabric) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt represents the /srl_nokia-platform/platform/linecard/forwarding-complex/p4rt YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt struct {
	Id *uint64 `path:"id" module:"srl_nokia-platform-p4rt"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) GetId() uint64 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_P4Rt) ΛBelongingModule() string {
	return "srl_nokia-platform-p4rt"
}

// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline represents the /srl_nokia-platform/platform/linecard/forwarding-complex/pipeline YANG schema element.
type SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline struct {
	Index SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union `path:"index" module:"srl_nokia-platform-lc"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) IsYANGGoStruct() {}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) GetIndex() SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline_Index_Union {
	if t == nil || t.Index == nil {
		return nil
	}
	return t.Index
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"index": t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline.
func (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Pipeline) ΛBelongingModule() string {
	return "srl_nokia-platform-lc"
}

// SrlNokiaPlatform_Platform_Redundancy represents the /srl_nokia-platform/platform/redundancy YANG schema element.
type SrlNokiaPlatform_Platform_Redundancy struct {
	Synchronization *SrlNokiaPlatform_Platform_Redundancy_Synchronization `path:"synchronization" module:"srl_nokia-platform-redundancy"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Redundancy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Redundancy) IsYANGGoStruct() {}

// GetOrCreateSynchronization retrieves the value of the Synchronization field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Redundancy) GetOrCreateSynchronization() *SrlNokiaPlatform_Platform_Redundancy_Synchronization {
	if t.Synchronization != nil {
		return t.Synchronization
	}
	t.Synchronization = &SrlNokiaPlatform_Platform_Redundancy_Synchronization{}
	return t.Synchronization
}

// GetSynchronization returns the value of the Synchronization struct pointer
// from SrlNokiaPlatform_Platform_Redundancy. If the receiver or the field Synchronization is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Redundancy) GetSynchronization() *SrlNokiaPlatform_Platform_Redundancy_Synchronization {
	if t != nil && t.Synchronization != nil {
		return t.Synchronization
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Redundancy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Redundancy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Synchronization.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Redundancy.
func (*SrlNokiaPlatform_Platform_Redundancy) ΛBelongingModule() string {
	return "srl_nokia-platform-redundancy"
}

// SrlNokiaPlatform_Platform_Redundancy_Synchronization represents the /srl_nokia-platform/platform/redundancy/synchronization YANG schema element.
type SrlNokiaPlatform_Platform_Redundancy_Synchronization struct {
	Overlay *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay `path:"overlay" module:"srl_nokia-platform-redundancy"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Redundancy_Synchronization implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization) IsYANGGoStruct() {}

// GetOrCreateOverlay retrieves the value of the Overlay field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) GetOrCreateOverlay() *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay {
	if t.Overlay != nil {
		return t.Overlay
	}
	t.Overlay = &SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay{}
	return t.Overlay
}

// GetOverlay returns the value of the Overlay struct pointer
// from SrlNokiaPlatform_Platform_Redundancy_Synchronization. If the receiver or the field Overlay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) GetOverlay() *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay {
	if t != nil && t.Overlay != nil {
		return t.Overlay
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Redundancy_Synchronization
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Overlay.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy_Synchronization"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Redundancy_Synchronization.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization) ΛBelongingModule() string {
	return "srl_nokia-platform-redundancy"
}

// SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay represents the /srl_nokia-platform/platform/redundancy/synchronization/overlay YANG schema element.
type SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay struct {
	SynchronizationFrequency *uint32 `path:"synchronization-frequency" module:"srl_nokia-platform-redundancy"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) IsYANGGoStruct() {}

// GetSynchronizationFrequency retrieves the value of the leaf SynchronizationFrequency from the SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SynchronizationFrequency is set, it can
// safely use t.GetSynchronizationFrequency() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SynchronizationFrequency == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) GetSynchronizationFrequency() uint32 {
	if t == nil || t.SynchronizationFrequency == nil {
		return 60
	}
	return *t.SynchronizationFrequency
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SynchronizationFrequency == nil {
		var v uint32 = 60
		t.SynchronizationFrequency = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay.
func (*SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) ΛBelongingModule() string {
	return "srl_nokia-platform-redundancy"
}

// SrlNokiaPlatform_Platform_ResourceManagement represents the /srl_nokia-platform/platform/resource-management YANG schema element.
type SrlNokiaPlatform_Platform_ResourceManagement struct {
	Tcam                       *SrlNokiaPlatform_Platform_ResourceManagement_Tcam                       `path:"tcam" module:"srl_nokia-platform-resource-mgmt"`
	UnifiedForwardingResources *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources `path:"unified-forwarding-resources" module:"srl_nokia-platform-resource-mgmt"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceManagement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceManagement) IsYANGGoStruct() {}

// GetOrCreateTcam retrieves the value of the Tcam field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) GetOrCreateTcam() *SrlNokiaPlatform_Platform_ResourceManagement_Tcam {
	if t.Tcam != nil {
		return t.Tcam
	}
	t.Tcam = &SrlNokiaPlatform_Platform_ResourceManagement_Tcam{}
	return t.Tcam
}

// GetOrCreateUnifiedForwardingResources retrieves the value of the UnifiedForwardingResources field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) GetOrCreateUnifiedForwardingResources() *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources {
	if t.UnifiedForwardingResources != nil {
		return t.UnifiedForwardingResources
	}
	t.UnifiedForwardingResources = &SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources{}
	return t.UnifiedForwardingResources
}

// GetTcam returns the value of the Tcam struct pointer
// from SrlNokiaPlatform_Platform_ResourceManagement. If the receiver or the field Tcam is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) GetTcam() *SrlNokiaPlatform_Platform_ResourceManagement_Tcam {
	if t != nil && t.Tcam != nil {
		return t.Tcam
	}
	return nil
}

// GetUnifiedForwardingResources returns the value of the UnifiedForwardingResources struct pointer
// from SrlNokiaPlatform_Platform_ResourceManagement. If the receiver or the field UnifiedForwardingResources is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) GetUnifiedForwardingResources() *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources {
	if t != nil && t.UnifiedForwardingResources != nil {
		return t.UnifiedForwardingResources
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceManagement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Tcam.PopulateDefaults()
	t.UnifiedForwardingResources.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceManagement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceManagement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceManagement.
func (*SrlNokiaPlatform_Platform_ResourceManagement) ΛBelongingModule() string {
	return "srl_nokia-platform-resource-mgmt"
}

// SrlNokiaPlatform_Platform_ResourceManagement_Tcam represents the /srl_nokia-platform/platform/resource-management/tcam YANG schema element.
type SrlNokiaPlatform_Platform_ResourceManagement_Tcam struct{}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceManagement_Tcam implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceManagement_Tcam) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceManagement_Tcam
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_Tcam) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_Tcam) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceManagement_Tcam"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_Tcam) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_Tcam) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceManagement_Tcam.
func (*SrlNokiaPlatform_Platform_ResourceManagement_Tcam) ΛBelongingModule() string {
	return "srl_nokia-platform-resource-mgmt"
}

// SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources represents the /srl_nokia-platform/platform/resource-management/unified-forwarding-resources YANG schema element.
type SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources struct {
	Alpm                        E_SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources_Alpm `path:"alpm" module:"srl_nokia-platform-resource-mgmt"`
	Ipv6_128BitLpmEntries       *uint16                                                                        `path:"ipv6-128bit-lpm-entries" module:"srl_nokia-platform-resource-mgmt"`
	RequestedExtraIpHostEntries *uint32                                                                        `path:"requested-extra-ip-host-entries" module:"srl_nokia-platform-resource-mgmt"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) IsYANGGoStruct() {}

// GetAlpm retrieves the value of the leaf Alpm from the SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Alpm is set, it can
// safely use t.GetAlpm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Alpm == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) GetAlpm() E_SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources_Alpm {
	if t == nil || t.Alpm == 0 {
		return SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources_Alpm_disabled
	}
	return t.Alpm
}

// GetIpv6_128BitLpmEntries retrieves the value of the leaf Ipv6_128BitLpmEntries from the SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6_128BitLpmEntries is set, it can
// safely use t.GetIpv6_128BitLpmEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6_128BitLpmEntries == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) GetIpv6_128BitLpmEntries() uint16 {
	if t == nil || t.Ipv6_128BitLpmEntries == nil {
		return 0
	}
	return *t.Ipv6_128BitLpmEntries
}

// GetRequestedExtraIpHostEntries retrieves the value of the leaf RequestedExtraIpHostEntries from the SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RequestedExtraIpHostEntries is set, it can
// safely use t.GetRequestedExtraIpHostEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RequestedExtraIpHostEntries == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) GetRequestedExtraIpHostEntries() uint32 {
	if t == nil || t.RequestedExtraIpHostEntries == nil {
		return 0
	}
	return *t.RequestedExtraIpHostEntries
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Alpm == 0 {
		t.Alpm = SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources_Alpm_disabled
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources.
func (*SrlNokiaPlatform_Platform_ResourceManagement_UnifiedForwardingResources) ΛBelongingModule() string {
	return "srl_nokia-platform-resource-mgmt"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring represents the /srl_nokia-platform/platform/resource-monitoring YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring struct {
	Acl      *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl      `path:"acl" module:"srl_nokia-platform-acl"`
	Datapath *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath `path:"datapath" module:"srl_nokia-platform-datapath-resources"`
	Mtu      *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu      `path:"mtu" module:"srl_nokia-platform-mtu"`
	Qos      *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos      `path:"qos" module:"srl_nokia-platform-qos"`
	Tcam     *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam     `path:"tcam" module:"srl_nokia-platform-tcam"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring) IsYANGGoStruct() {}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetOrCreateAcl() *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &SrlNokiaPlatform_Platform_ResourceMonitoring_Acl{}
	return t.Acl
}

// GetOrCreateDatapath retrieves the value of the Datapath field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetOrCreateDatapath() *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath {
	if t.Datapath != nil {
		return t.Datapath
	}
	t.Datapath = &SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath{}
	return t.Datapath
}

// GetOrCreateMtu retrieves the value of the Mtu field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetOrCreateMtu() *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu {
	if t.Mtu != nil {
		return t.Mtu
	}
	t.Mtu = &SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu{}
	return t.Mtu
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetOrCreateQos() *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &SrlNokiaPlatform_Platform_ResourceMonitoring_Qos{}
	return t.Qos
}

// GetOrCreateTcam retrieves the value of the Tcam field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetOrCreateTcam() *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam {
	if t.Tcam != nil {
		return t.Tcam
	}
	t.Tcam = &SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam{}
	return t.Tcam
}

// GetAcl returns the value of the Acl struct pointer
// from SrlNokiaPlatform_Platform_ResourceMonitoring. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetAcl() *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetDatapath returns the value of the Datapath struct pointer
// from SrlNokiaPlatform_Platform_ResourceMonitoring. If the receiver or the field Datapath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetDatapath() *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath {
	if t != nil && t.Datapath != nil {
		return t.Datapath
	}
	return nil
}

// GetMtu returns the value of the Mtu struct pointer
// from SrlNokiaPlatform_Platform_ResourceMonitoring. If the receiver or the field Mtu is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetMtu() *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu {
	if t != nil && t.Mtu != nil {
		return t.Mtu
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from SrlNokiaPlatform_Platform_ResourceMonitoring. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetQos() *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetTcam returns the value of the Tcam struct pointer
// from SrlNokiaPlatform_Platform_ResourceMonitoring. If the receiver or the field Tcam is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) GetTcam() *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam {
	if t != nil && t.Tcam != nil {
		return t.Tcam
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Acl.PopulateDefaults()
	t.Datapath.PopulateDefaults()
	t.Mtu.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.Tcam.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring) ΛBelongingModule() string {
	return "srl_nokia-platform-resource-monitoring"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Acl represents the /srl_nokia-platform/platform/resource-monitoring/acl YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Acl struct {
	Resource map[E_SrlNokiaPlatformAcl_AclResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource `path:"resource" module:"srl_nokia-platform-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) NewResource(
	Name E_SrlNokiaPlatformAcl_AclResources,
) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformAcl_AclResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) RenameResource(oldK, newK E_SrlNokiaPlatformAcl_AclResources) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) GetOrCreateResource(
	Name E_SrlNokiaPlatformAcl_AclResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource {
	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of SrlNokiaPlatform_Platform_ResourceMonitoring_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) GetResource(
	Name E_SrlNokiaPlatformAcl_AclResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) DeleteResource(Name E_SrlNokiaPlatformAcl_AclResources) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource struct to the
// list Resource of SrlNokiaPlatform_Platform_ResourceMonitoring_Acl. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) AppendResource(
	v *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformAcl_AclResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Resource {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Acl.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) ΛBelongingModule() string {
	return "srl_nokia-platform-acl"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource represents the /srl_nokia-platform/platform/resource-monitoring/acl/resource YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource struct {
	FallingThresholdLog *uint8                             `path:"falling-threshold-log" module:"srl_nokia-platform-acl"`
	Name                E_SrlNokiaPlatformAcl_AclResources `path:"name" module:"srl_nokia-platform-acl"`
	RisingThresholdLog  *uint8                             `path:"rising-threshold-log" module:"srl_nokia-platform-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) IsYANGGoStruct() {}

// GetFallingThresholdLog retrieves the value of the leaf FallingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdLog is set, it can
// safely use t.GetFallingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) GetFallingThresholdLog() uint8 {
	if t == nil || t.FallingThresholdLog == nil {
		return 70
	}
	return *t.FallingThresholdLog
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) GetName() E_SrlNokiaPlatformAcl_AclResources {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// GetRisingThresholdLog retrieves the value of the leaf RisingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdLog is set, it can
// safely use t.GetRisingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) GetRisingThresholdLog() uint8 {
	if t == nil || t.RisingThresholdLog == nil {
		return 90
	}
	return *t.RisingThresholdLog
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FallingThresholdLog == nil {
		var v uint8 = 70
		t.FallingThresholdLog = &v
	}
	if t.RisingThresholdLog == nil {
		var v uint8 = 90
		t.RisingThresholdLog = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) ΛBelongingModule() string {
	return "srl_nokia-platform-acl"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath represents the /srl_nokia-platform/platform/resource-monitoring/datapath YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath struct {
	Asic *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic `path:"asic" module:"srl_nokia-platform-datapath-resources"`
	Xdp  *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp  `path:"xdp" module:"srl_nokia-platform-datapath-resources"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) IsYANGGoStruct() {}

// GetOrCreateAsic retrieves the value of the Asic field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) GetOrCreateAsic() *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic {
	if t.Asic != nil {
		return t.Asic
	}
	t.Asic = &SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic{}
	return t.Asic
}

// GetOrCreateXdp retrieves the value of the Xdp field
// or returns the existing field if it already exists.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) GetOrCreateXdp() *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp {
	if t.Xdp != nil {
		return t.Xdp
	}
	t.Xdp = &SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp{}
	return t.Xdp
}

// GetAsic returns the value of the Asic struct pointer
// from SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath. If the receiver or the field Asic is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) GetAsic() *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic {
	if t != nil && t.Asic != nil {
		return t.Asic
	}
	return nil
}

// GetXdp returns the value of the Xdp struct pointer
// from SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath. If the receiver or the field Xdp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) GetXdp() *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp {
	if t != nil && t.Xdp != nil {
		return t.Xdp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Asic.PopulateDefaults()
	t.Xdp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath) ΛBelongingModule() string {
	return "srl_nokia-platform-datapath-resources"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic represents the /srl_nokia-platform/platform/resource-monitoring/datapath/asic YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic struct {
	Resource map[E_SrlNokiaPlatformDatapathResources_AsicDatapathResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource `path:"resource" module:"srl_nokia-platform-datapath-resources"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) NewResource(
	Name E_SrlNokiaPlatformDatapathResources_AsicDatapathResources,
) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformDatapathResources_AsicDatapathResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) RenameResource(
	oldK, newK E_SrlNokiaPlatformDatapathResources_AsicDatapathResources,
) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) GetOrCreateResource(
	Name E_SrlNokiaPlatformDatapathResources_AsicDatapathResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource {
	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) GetResource(
	Name E_SrlNokiaPlatformDatapathResources_AsicDatapathResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) DeleteResource(
	Name E_SrlNokiaPlatformDatapathResources_AsicDatapathResources,
) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource struct to the
// list Resource of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) AppendResource(
	v *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformDatapathResources_AsicDatapathResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Resource {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic) ΛBelongingModule() string {
	return "srl_nokia-platform-datapath-resources"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource represents the /srl_nokia-platform/platform/resource-monitoring/datapath/asic/resource YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource struct {
	FallingThresholdLog *uint8                                                    `path:"falling-threshold-log" module:"srl_nokia-platform-datapath-resources"`
	Name                E_SrlNokiaPlatformDatapathResources_AsicDatapathResources `path:"name" module:"srl_nokia-platform-datapath-resources"`
	RisingThresholdLog  *uint8                                                    `path:"rising-threshold-log" module:"srl_nokia-platform-datapath-resources"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) IsYANGGoStruct() {}

// GetFallingThresholdLog retrieves the value of the leaf FallingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdLog is set, it can
// safely use t.GetFallingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) GetFallingThresholdLog() uint8 {
	if t == nil || t.FallingThresholdLog == nil {
		return 70
	}
	return *t.FallingThresholdLog
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) GetName() E_SrlNokiaPlatformDatapathResources_AsicDatapathResources {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// GetRisingThresholdLog retrieves the value of the leaf RisingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdLog is set, it can
// safely use t.GetRisingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) GetRisingThresholdLog() uint8 {
	if t == nil || t.RisingThresholdLog == nil {
		return 90
	}
	return *t.RisingThresholdLog
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FallingThresholdLog == nil {
		var v uint8 = 70
		t.FallingThresholdLog = &v
	}
	if t.RisingThresholdLog == nil {
		var v uint8 = 90
		t.RisingThresholdLog = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Asic_Resource) ΛBelongingModule() string {
	return "srl_nokia-platform-datapath-resources"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp represents the /srl_nokia-platform/platform/resource-monitoring/datapath/xdp YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp struct {
	Resource map[E_SrlNokiaPlatformDatapathResources_XdpDatapathResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource `path:"resource" module:"srl_nokia-platform-datapath-resources"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) NewResource(
	Name E_SrlNokiaPlatformDatapathResources_XdpDatapathResources,
) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformDatapathResources_XdpDatapathResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) RenameResource(
	oldK, newK E_SrlNokiaPlatformDatapathResources_XdpDatapathResources,
) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) GetOrCreateResource(
	Name E_SrlNokiaPlatformDatapathResources_XdpDatapathResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource {
	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) GetResource(
	Name E_SrlNokiaPlatformDatapathResources_XdpDatapathResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) DeleteResource(
	Name E_SrlNokiaPlatformDatapathResources_XdpDatapathResources,
) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource struct to the
// list Resource of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) AppendResource(
	v *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformDatapathResources_XdpDatapathResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Resource {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp) ΛBelongingModule() string {
	return "srl_nokia-platform-datapath-resources"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource represents the /srl_nokia-platform/platform/resource-monitoring/datapath/xdp/resource YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource struct {
	FallingThresholdLog *uint8                                                   `path:"falling-threshold-log" module:"srl_nokia-platform-datapath-resources"`
	Name                E_SrlNokiaPlatformDatapathResources_XdpDatapathResources `path:"name" module:"srl_nokia-platform-datapath-resources"`
	RisingThresholdLog  *uint8                                                   `path:"rising-threshold-log" module:"srl_nokia-platform-datapath-resources"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) IsYANGGoStruct() {}

// GetFallingThresholdLog retrieves the value of the leaf FallingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdLog is set, it can
// safely use t.GetFallingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) GetFallingThresholdLog() uint8 {
	if t == nil || t.FallingThresholdLog == nil {
		return 70
	}
	return *t.FallingThresholdLog
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) GetName() E_SrlNokiaPlatformDatapathResources_XdpDatapathResources {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// GetRisingThresholdLog retrieves the value of the leaf RisingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdLog is set, it can
// safely use t.GetRisingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) GetRisingThresholdLog() uint8 {
	if t == nil || t.RisingThresholdLog == nil {
		return 90
	}
	return *t.RisingThresholdLog
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FallingThresholdLog == nil {
		var v uint8 = 70
		t.FallingThresholdLog = &v
	}
	if t.RisingThresholdLog == nil {
		var v uint8 = 90
		t.RisingThresholdLog = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Datapath_Xdp_Resource) ΛBelongingModule() string {
	return "srl_nokia-platform-datapath-resources"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu represents the /srl_nokia-platform/platform/resource-monitoring/mtu YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu struct {
	Resource map[E_SrlNokiaPlatformMtu_MtuResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource `path:"resource" module:"srl_nokia-platform-mtu"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) NewResource(
	Name E_SrlNokiaPlatformMtu_MtuResources,
) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformMtu_MtuResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) RenameResource(oldK, newK E_SrlNokiaPlatformMtu_MtuResources) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) GetOrCreateResource(
	Name E_SrlNokiaPlatformMtu_MtuResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource {
	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) GetResource(
	Name E_SrlNokiaPlatformMtu_MtuResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) DeleteResource(Name E_SrlNokiaPlatformMtu_MtuResources) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource struct to the
// list Resource of SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) AppendResource(
	v *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformMtu_MtuResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Resource {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) ΛBelongingModule() string {
	return "srl_nokia-platform-mtu"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource represents the /srl_nokia-platform/platform/resource-monitoring/mtu/resource YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource struct {
	FallingThresholdLog *uint8                             `path:"falling-threshold-log" module:"srl_nokia-platform-mtu"`
	Name                E_SrlNokiaPlatformMtu_MtuResources `path:"name" module:"srl_nokia-platform-mtu"`
	RisingThresholdLog  *uint8                             `path:"rising-threshold-log" module:"srl_nokia-platform-mtu"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) IsYANGGoStruct() {}

// GetFallingThresholdLog retrieves the value of the leaf FallingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdLog is set, it can
// safely use t.GetFallingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) GetFallingThresholdLog() uint8 {
	if t == nil || t.FallingThresholdLog == nil {
		return 70
	}
	return *t.FallingThresholdLog
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) GetName() E_SrlNokiaPlatformMtu_MtuResources {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// GetRisingThresholdLog retrieves the value of the leaf RisingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdLog is set, it can
// safely use t.GetRisingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) GetRisingThresholdLog() uint8 {
	if t == nil || t.RisingThresholdLog == nil {
		return 90
	}
	return *t.RisingThresholdLog
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FallingThresholdLog == nil {
		var v uint8 = 70
		t.FallingThresholdLog = &v
	}
	if t.RisingThresholdLog == nil {
		var v uint8 = 90
		t.RisingThresholdLog = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) ΛBelongingModule() string {
	return "srl_nokia-platform-mtu"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Qos represents the /srl_nokia-platform/platform/resource-monitoring/qos YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Qos struct {
	Resource map[E_SrlNokiaPlatformQos_QosResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource `path:"resource" module:"srl_nokia-platform-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Qos struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) NewResource(
	Name E_SrlNokiaPlatformQos_QosResources,
) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformQos_QosResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) RenameResource(oldK, newK E_SrlNokiaPlatformQos_QosResources) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Qos. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) GetOrCreateResource(
	Name E_SrlNokiaPlatformQos_QosResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource {
	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of SrlNokiaPlatform_Platform_ResourceMonitoring_Qos. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) GetResource(
	Name E_SrlNokiaPlatformQos_QosResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Qos. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) DeleteResource(Name E_SrlNokiaPlatformQos_QosResources) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource struct to the
// list Resource of SrlNokiaPlatform_Platform_ResourceMonitoring_Qos. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) AppendResource(
	v *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformQos_QosResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Resource {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Qos.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) ΛBelongingModule() string {
	return "srl_nokia-platform-qos"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource represents the /srl_nokia-platform/platform/resource-monitoring/qos/resource YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource struct {
	FallingThresholdLog *uint8                             `path:"falling-threshold-log" module:"srl_nokia-platform-qos"`
	Name                E_SrlNokiaPlatformQos_QosResources `path:"name" module:"srl_nokia-platform-qos"`
	RisingThresholdLog  *uint8                             `path:"rising-threshold-log" module:"srl_nokia-platform-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) IsYANGGoStruct() {}

// GetFallingThresholdLog retrieves the value of the leaf FallingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdLog is set, it can
// safely use t.GetFallingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) GetFallingThresholdLog() uint8 {
	if t == nil || t.FallingThresholdLog == nil {
		return 70
	}
	return *t.FallingThresholdLog
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) GetName() E_SrlNokiaPlatformQos_QosResources {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// GetRisingThresholdLog retrieves the value of the leaf RisingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdLog is set, it can
// safely use t.GetRisingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) GetRisingThresholdLog() uint8 {
	if t == nil || t.RisingThresholdLog == nil {
		return 90
	}
	return *t.RisingThresholdLog
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FallingThresholdLog == nil {
		var v uint8 = 70
		t.FallingThresholdLog = &v
	}
	if t.RisingThresholdLog == nil {
		var v uint8 = 90
		t.RisingThresholdLog = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) ΛBelongingModule() string {
	return "srl_nokia-platform-qos"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam represents the /srl_nokia-platform/platform/resource-monitoring/tcam YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam struct {
	Resource map[E_SrlNokiaPlatformTcam_TcamResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource `path:"resource" module:"srl_nokia-platform-tcam"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) IsYANGGoStruct() {}

// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) NewResource(
	Name E_SrlNokiaPlatformTcam_TcamResources,
) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformTcam_TcamResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// RenameResource renames an entry in the list Resource within
// the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) RenameResource(oldK, newK E_SrlNokiaPlatformTcam_TcamResources) error {
	if _, ok := t.Resource[newK]; ok {
		return fmt.Errorf("key %v already exists in Resource", newK)
	}

	e, ok := t.Resource[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Resource", oldK)
	}
	e.Name = newK

	t.Resource[newK] = e
	delete(t.Resource, oldK)
	return nil
}

// GetOrCreateResource retrieves the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) GetOrCreateResource(
	Name E_SrlNokiaPlatformTcam_TcamResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource {
	key := Name

	if v, ok := t.Resource[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewResource(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateResource got unexpected error: %v", err))
	}
	return v
}

// GetResource retrieves the value with the specified key from
// the Resource map field of SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) GetResource(
	Name E_SrlNokiaPlatformTcam_TcamResources,
) *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Resource[key]; ok {
		return lm
	}
	return nil
}

// DeleteResource deletes the value with the specified keys from
// the receiver SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) DeleteResource(Name E_SrlNokiaPlatformTcam_TcamResources) {
	key := Name

	delete(t.Resource, key)
}

// AppendResource appends the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource struct to the
// list Resource of SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam. If the key value(s) specified in
// the supplied SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource already exist in the list, an error is
// returned.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) AppendResource(
	v *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformTcam_TcamResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource)
	}

	if _, ok := t.Resource[key]; ok {
		return fmt.Errorf("duplicate key for list Resource %v", key)
	}

	t.Resource[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Resource {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) ΛBelongingModule() string {
	return "srl_nokia-platform-tcam"
}

// SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource represents the /srl_nokia-platform/platform/resource-monitoring/tcam/resource YANG schema element.
type SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource struct {
	FallingThresholdLog *uint8                               `path:"falling-threshold-log" module:"srl_nokia-platform-tcam"`
	Name                E_SrlNokiaPlatformTcam_TcamResources `path:"name" module:"srl_nokia-platform-tcam"`
	RisingThresholdLog  *uint8                               `path:"rising-threshold-log" module:"srl_nokia-platform-tcam"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) IsYANGGoStruct() {}

// GetFallingThresholdLog retrieves the value of the leaf FallingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FallingThresholdLog is set, it can
// safely use t.GetFallingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FallingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) GetFallingThresholdLog() uint8 {
	if t == nil || t.FallingThresholdLog == nil {
		return 70
	}
	return *t.FallingThresholdLog
}

// GetName retrieves the value of the leaf Name from the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) GetName() E_SrlNokiaPlatformTcam_TcamResources {
	if t == nil || t.Name == 0 {
		return 0
	}
	return t.Name
}

// GetRisingThresholdLog retrieves the value of the leaf RisingThresholdLog from the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RisingThresholdLog is set, it can
// safely use t.GetRisingThresholdLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RisingThresholdLog == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) GetRisingThresholdLog() uint8 {
	if t == nil || t.RisingThresholdLog == nil {
		return 90
	}
	return *t.RisingThresholdLog
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FallingThresholdLog == nil {
		var v uint8 = 70
		t.FallingThresholdLog = &v
	}
	if t.RisingThresholdLog == nil {
		var v uint8 = 90
		t.RisingThresholdLog = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource.
func (*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) ΛBelongingModule() string {
	return "srl_nokia-platform-tcam"
}

// SrlNokiaPlatform_Platform_Vxdp represents the /srl_nokia-platform/platform/vxdp YANG schema element.
type SrlNokiaPlatform_Platform_Vxdp struct {
	CpuSet []uint16 `path:"cpu-set" module:"srl_nokia-platform-vxdp"`
}

// IsYANGGoStruct ensures that SrlNokiaPlatform_Platform_Vxdp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaPlatform_Platform_Vxdp) IsYANGGoStruct() {}

// GetCpuSet retrieves the value of the leaf CpuSet from the SrlNokiaPlatform_Platform_Vxdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CpuSet is set, it can
// safely use t.GetCpuSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CpuSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaPlatform_Platform_Vxdp) GetCpuSet() []uint16 {
	if t == nil || t.CpuSet == nil {
		return nil
	}
	return t.CpuSet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaPlatform_Platform_Vxdp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaPlatform_Platform_Vxdp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Vxdp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Vxdp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Vxdp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Vxdp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaPlatform_Platform_Vxdp.
func (*SrlNokiaPlatform_Platform_Vxdp) ΛBelongingModule() string {
	return "srl_nokia-platform-vxdp"
}

// SrlNokiaQos_Qos represents the /srl_nokia-qos/qos YANG schema element.
type SrlNokiaQos_Qos struct {
	CbsSizeTable                   *SrlNokiaQos_Qos_CbsSizeTable                   `path:"cbs-size-table" module:"srl_nokia-qos"`
	Classifiers                    *SrlNokiaQos_Qos_Classifiers                    `path:"classifiers" module:"srl_nokia-qos"`
	ExplicitCongestionNotification *SrlNokiaQos_Qos_ExplicitCongestionNotification `path:"explicit-congestion-notification" module:"srl_nokia-qos" yangPresence:"true"`
	ForwardingClasses              *SrlNokiaQos_Qos_ForwardingClasses              `path:"forwarding-classes" module:"srl_nokia-qos"`
	OutClassMap                    map[string]*SrlNokiaQos_Qos_OutClassMap         `path:"out-class-map" module:"srl_nokia-qos"`
	PolicerTemplates               *SrlNokiaQos_Qos_PolicerTemplates               `path:"policer-templates" module:"srl_nokia-qos"`
	Policers                       *SrlNokiaQos_Qos_Policers                       `path:"policers" module:"srl_nokia-qos"`
	QueueTemplates                 *SrlNokiaQos_Qos_QueueTemplates                 `path:"queue-templates" module:"srl_nokia-qos"`
	Queues                         *SrlNokiaQos_Qos_Queues                         `path:"queues" module:"srl_nokia-qos"`
	ResourceManagement             *SrlNokiaQos_Qos_ResourceManagement             `path:"resource-management" module:"srl_nokia-qos"`
	RewriteRules                   *SrlNokiaQos_Qos_RewriteRules                   `path:"rewrite-rules" module:"srl_nokia-qos"`
	SchedulerPolicies              *SrlNokiaQos_Qos_SchedulerPolicies              `path:"scheduler-policies" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos) IsYANGGoStruct() {}

// NewOutClassMap creates a new entry in the OutClassMap list of the
// SrlNokiaQos_Qos struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos) NewOutClassMap(Name string) (*SrlNokiaQos_Qos_OutClassMap, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.OutClassMap == nil {
		t.OutClassMap = make(map[string]*SrlNokiaQos_Qos_OutClassMap)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.OutClassMap[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list OutClassMap", key)
	}

	t.OutClassMap[key] = &SrlNokiaQos_Qos_OutClassMap{
		Name: &Name,
	}

	return t.OutClassMap[key], nil
}

// RenameOutClassMap renames an entry in the list OutClassMap within
// the SrlNokiaQos_Qos struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos) RenameOutClassMap(oldK, newK string) error {
	if _, ok := t.OutClassMap[newK]; ok {
		return fmt.Errorf("key %v already exists in OutClassMap", newK)
	}

	e, ok := t.OutClassMap[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in OutClassMap", oldK)
	}
	e.Name = &newK

	t.OutClassMap[newK] = e
	delete(t.OutClassMap, oldK)
	return nil
}

// GetOrCreateOutClassMap retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos) GetOrCreateOutClassMap(Name string) *SrlNokiaQos_Qos_OutClassMap {
	key := Name

	if v, ok := t.OutClassMap[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewOutClassMap(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateOutClassMap got unexpected error: %v", err))
	}
	return v
}

// GetOutClassMap retrieves the value with the specified key from
// the OutClassMap map field of SrlNokiaQos_Qos. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos) GetOutClassMap(Name string) *SrlNokiaQos_Qos_OutClassMap {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.OutClassMap[key]; ok {
		return lm
	}
	return nil
}

// DeleteOutClassMap deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos) DeleteOutClassMap(Name string) {
	key := Name

	delete(t.OutClassMap, key)
}

// AppendOutClassMap appends the supplied SrlNokiaQos_Qos_OutClassMap struct to the
// list OutClassMap of SrlNokiaQos_Qos. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_OutClassMap already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos) AppendOutClassMap(v *SrlNokiaQos_Qos_OutClassMap) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.OutClassMap == nil {
		t.OutClassMap = make(map[string]*SrlNokiaQos_Qos_OutClassMap)
	}

	if _, ok := t.OutClassMap[key]; ok {
		return fmt.Errorf("duplicate key for list OutClassMap %v", key)
	}

	t.OutClassMap[key] = v
	return nil
}

// GetOrCreateCbsSizeTable retrieves the value of the CbsSizeTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateCbsSizeTable() *SrlNokiaQos_Qos_CbsSizeTable {
	if t.CbsSizeTable != nil {
		return t.CbsSizeTable
	}
	t.CbsSizeTable = &SrlNokiaQos_Qos_CbsSizeTable{}
	return t.CbsSizeTable
}

// GetOrCreateClassifiers retrieves the value of the Classifiers field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateClassifiers() *SrlNokiaQos_Qos_Classifiers {
	if t.Classifiers != nil {
		return t.Classifiers
	}
	t.Classifiers = &SrlNokiaQos_Qos_Classifiers{}
	return t.Classifiers
}

// GetOrCreateExplicitCongestionNotification retrieves the value of the ExplicitCongestionNotification field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateExplicitCongestionNotification() *SrlNokiaQos_Qos_ExplicitCongestionNotification {
	if t.ExplicitCongestionNotification != nil {
		return t.ExplicitCongestionNotification
	}
	t.ExplicitCongestionNotification = &SrlNokiaQos_Qos_ExplicitCongestionNotification{}
	return t.ExplicitCongestionNotification
}

// GetOrCreateForwardingClasses retrieves the value of the ForwardingClasses field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateForwardingClasses() *SrlNokiaQos_Qos_ForwardingClasses {
	if t.ForwardingClasses != nil {
		return t.ForwardingClasses
	}
	t.ForwardingClasses = &SrlNokiaQos_Qos_ForwardingClasses{}
	return t.ForwardingClasses
}

// GetOrCreatePolicerTemplates retrieves the value of the PolicerTemplates field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreatePolicerTemplates() *SrlNokiaQos_Qos_PolicerTemplates {
	if t.PolicerTemplates != nil {
		return t.PolicerTemplates
	}
	t.PolicerTemplates = &SrlNokiaQos_Qos_PolicerTemplates{}
	return t.PolicerTemplates
}

// GetOrCreatePolicers retrieves the value of the Policers field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreatePolicers() *SrlNokiaQos_Qos_Policers {
	if t.Policers != nil {
		return t.Policers
	}
	t.Policers = &SrlNokiaQos_Qos_Policers{}
	return t.Policers
}

// GetOrCreateQueueTemplates retrieves the value of the QueueTemplates field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateQueueTemplates() *SrlNokiaQos_Qos_QueueTemplates {
	if t.QueueTemplates != nil {
		return t.QueueTemplates
	}
	t.QueueTemplates = &SrlNokiaQos_Qos_QueueTemplates{}
	return t.QueueTemplates
}

// GetOrCreateQueues retrieves the value of the Queues field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateQueues() *SrlNokiaQos_Qos_Queues {
	if t.Queues != nil {
		return t.Queues
	}
	t.Queues = &SrlNokiaQos_Qos_Queues{}
	return t.Queues
}

// GetOrCreateResourceManagement retrieves the value of the ResourceManagement field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateResourceManagement() *SrlNokiaQos_Qos_ResourceManagement {
	if t.ResourceManagement != nil {
		return t.ResourceManagement
	}
	t.ResourceManagement = &SrlNokiaQos_Qos_ResourceManagement{}
	return t.ResourceManagement
}

// GetOrCreateRewriteRules retrieves the value of the RewriteRules field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateRewriteRules() *SrlNokiaQos_Qos_RewriteRules {
	if t.RewriteRules != nil {
		return t.RewriteRules
	}
	t.RewriteRules = &SrlNokiaQos_Qos_RewriteRules{}
	return t.RewriteRules
}

// GetOrCreateSchedulerPolicies retrieves the value of the SchedulerPolicies field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos) GetOrCreateSchedulerPolicies() *SrlNokiaQos_Qos_SchedulerPolicies {
	if t.SchedulerPolicies != nil {
		return t.SchedulerPolicies
	}
	t.SchedulerPolicies = &SrlNokiaQos_Qos_SchedulerPolicies{}
	return t.SchedulerPolicies
}

// GetCbsSizeTable returns the value of the CbsSizeTable struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field CbsSizeTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetCbsSizeTable() *SrlNokiaQos_Qos_CbsSizeTable {
	if t != nil && t.CbsSizeTable != nil {
		return t.CbsSizeTable
	}
	return nil
}

// GetClassifiers returns the value of the Classifiers struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field Classifiers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetClassifiers() *SrlNokiaQos_Qos_Classifiers {
	if t != nil && t.Classifiers != nil {
		return t.Classifiers
	}
	return nil
}

// GetExplicitCongestionNotification returns the value of the ExplicitCongestionNotification struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field ExplicitCongestionNotification is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetExplicitCongestionNotification() *SrlNokiaQos_Qos_ExplicitCongestionNotification {
	if t != nil && t.ExplicitCongestionNotification != nil {
		return t.ExplicitCongestionNotification
	}
	return nil
}

// GetForwardingClasses returns the value of the ForwardingClasses struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field ForwardingClasses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetForwardingClasses() *SrlNokiaQos_Qos_ForwardingClasses {
	if t != nil && t.ForwardingClasses != nil {
		return t.ForwardingClasses
	}
	return nil
}

// GetPolicerTemplates returns the value of the PolicerTemplates struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field PolicerTemplates is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetPolicerTemplates() *SrlNokiaQos_Qos_PolicerTemplates {
	if t != nil && t.PolicerTemplates != nil {
		return t.PolicerTemplates
	}
	return nil
}

// GetPolicers returns the value of the Policers struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field Policers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetPolicers() *SrlNokiaQos_Qos_Policers {
	if t != nil && t.Policers != nil {
		return t.Policers
	}
	return nil
}

// GetQueueTemplates returns the value of the QueueTemplates struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field QueueTemplates is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetQueueTemplates() *SrlNokiaQos_Qos_QueueTemplates {
	if t != nil && t.QueueTemplates != nil {
		return t.QueueTemplates
	}
	return nil
}

// GetQueues returns the value of the Queues struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field Queues is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetQueues() *SrlNokiaQos_Qos_Queues {
	if t != nil && t.Queues != nil {
		return t.Queues
	}
	return nil
}

// GetResourceManagement returns the value of the ResourceManagement struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field ResourceManagement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetResourceManagement() *SrlNokiaQos_Qos_ResourceManagement {
	if t != nil && t.ResourceManagement != nil {
		return t.ResourceManagement
	}
	return nil
}

// GetRewriteRules returns the value of the RewriteRules struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field RewriteRules is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetRewriteRules() *SrlNokiaQos_Qos_RewriteRules {
	if t != nil && t.RewriteRules != nil {
		return t.RewriteRules
	}
	return nil
}

// GetSchedulerPolicies returns the value of the SchedulerPolicies struct pointer
// from SrlNokiaQos_Qos. If the receiver or the field SchedulerPolicies is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos) GetSchedulerPolicies() *SrlNokiaQos_Qos_SchedulerPolicies {
	if t != nil && t.SchedulerPolicies != nil {
		return t.SchedulerPolicies
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.CbsSizeTable.PopulateDefaults()
	t.Classifiers.PopulateDefaults()
	t.ExplicitCongestionNotification.PopulateDefaults()
	t.ForwardingClasses.PopulateDefaults()
	t.PolicerTemplates.PopulateDefaults()
	t.Policers.PopulateDefaults()
	t.QueueTemplates.PopulateDefaults()
	t.Queues.PopulateDefaults()
	t.ResourceManagement.PopulateDefaults()
	t.RewriteRules.PopulateDefaults()
	t.SchedulerPolicies.PopulateDefaults()
	for _, e := range t.OutClassMap {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos.
func (*SrlNokiaQos_Qos) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_CbsSizeTable represents the /srl_nokia-qos/qos/cbs-size-table YANG schema element.
type SrlNokiaQos_Qos_CbsSizeTable struct {
	Alt_1       *uint64 `path:"alt-1" module:"srl_nokia-qos"`
	Alt_2       *uint64 `path:"alt-2" module:"srl_nokia-qos"`
	Alt_3       *uint64 `path:"alt-3" module:"srl_nokia-qos"`
	DefaultSize *uint64 `path:"default-size" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_CbsSizeTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_CbsSizeTable) IsYANGGoStruct() {}

// GetAlt_1 retrieves the value of the leaf Alt_1 from the SrlNokiaQos_Qos_CbsSizeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Alt_1 is set, it can
// safely use t.GetAlt_1() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Alt_1 == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_CbsSizeTable) GetAlt_1() uint64 {
	if t == nil || t.Alt_1 == nil {
		return 0
	}
	return *t.Alt_1
}

// GetAlt_2 retrieves the value of the leaf Alt_2 from the SrlNokiaQos_Qos_CbsSizeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Alt_2 is set, it can
// safely use t.GetAlt_2() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Alt_2 == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_CbsSizeTable) GetAlt_2() uint64 {
	if t == nil || t.Alt_2 == nil {
		return 0
	}
	return *t.Alt_2
}

// GetAlt_3 retrieves the value of the leaf Alt_3 from the SrlNokiaQos_Qos_CbsSizeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Alt_3 is set, it can
// safely use t.GetAlt_3() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Alt_3 == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_CbsSizeTable) GetAlt_3() uint64 {
	if t == nil || t.Alt_3 == nil {
		return 0
	}
	return *t.Alt_3
}

// GetDefaultSize retrieves the value of the leaf DefaultSize from the SrlNokiaQos_Qos_CbsSizeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultSize is set, it can
// safely use t.GetDefaultSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_CbsSizeTable) GetDefaultSize() uint64 {
	if t == nil || t.DefaultSize == nil {
		return 0
	}
	return *t.DefaultSize
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_CbsSizeTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_CbsSizeTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_CbsSizeTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_CbsSizeTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_CbsSizeTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_CbsSizeTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_CbsSizeTable.
func (*SrlNokiaQos_Qos_CbsSizeTable) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers represents the /srl_nokia-qos/qos/classifiers YANG schema element.
type SrlNokiaQos_Qos_Classifiers struct {
	Dot1PPolicy            map[string]*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy            `path:"dot1p-policy" module:"srl_nokia-qos"`
	DscpPolicy             map[string]*SrlNokiaQos_Qos_Classifiers_DscpPolicy             `path:"dscp-policy" module:"srl_nokia-qos"`
	DscpReclassifyPolicy   map[string]*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy   `path:"dscp-reclassify-policy" module:"srl_nokia-qos"`
	MplsTrafficClassPolicy map[string]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy `path:"mpls-traffic-class-policy" module:"srl_nokia-qos"`
	Multifield             *SrlNokiaQos_Qos_Classifiers_Multifield                        `path:"multifield" module:"srl_nokia-acl-qos"`
	VxlanDefault           *string                                                        `path:"vxlan-default" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers) IsYANGGoStruct() {}

// NewDot1PPolicy creates a new entry in the Dot1PPolicy list of the
// SrlNokiaQos_Qos_Classifiers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers) NewDot1PPolicy(Name string) (*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1PPolicy == nil {
		t.Dot1PPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dot1PPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dot1PPolicy", key)
	}

	t.Dot1PPolicy[key] = &SrlNokiaQos_Qos_Classifiers_Dot1PPolicy{
		Name: &Name,
	}

	return t.Dot1PPolicy[key], nil
}

// RenameDot1PPolicy renames an entry in the list Dot1PPolicy within
// the SrlNokiaQos_Qos_Classifiers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers) RenameDot1PPolicy(oldK, newK string) error {
	if _, ok := t.Dot1PPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in Dot1PPolicy", newK)
	}

	e, ok := t.Dot1PPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dot1PPolicy", oldK)
	}
	e.Name = &newK

	t.Dot1PPolicy[newK] = e
	delete(t.Dot1PPolicy, oldK)
	return nil
}

// GetOrCreateDot1PPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers) GetOrCreateDot1PPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy {
	key := Name

	if v, ok := t.Dot1PPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDot1PPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDot1PPolicy got unexpected error: %v", err))
	}
	return v
}

// GetDot1PPolicy retrieves the value with the specified key from
// the Dot1PPolicy map field of SrlNokiaQos_Qos_Classifiers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers) GetDot1PPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Dot1PPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteDot1PPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers) DeleteDot1PPolicy(Name string) {
	key := Name

	delete(t.Dot1PPolicy, key)
}

// AppendDot1PPolicy appends the supplied SrlNokiaQos_Qos_Classifiers_Dot1PPolicy struct to the
// list Dot1PPolicy of SrlNokiaQos_Qos_Classifiers. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_Dot1PPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers) AppendDot1PPolicy(v *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1PPolicy == nil {
		t.Dot1PPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy)
	}

	if _, ok := t.Dot1PPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list Dot1PPolicy %v", key)
	}

	t.Dot1PPolicy[key] = v
	return nil
}

// NewDscpPolicy creates a new entry in the DscpPolicy list of the
// SrlNokiaQos_Qos_Classifiers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers) NewDscpPolicy(Name string) (*SrlNokiaQos_Qos_Classifiers_DscpPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_DscpPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DscpPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DscpPolicy", key)
	}

	t.DscpPolicy[key] = &SrlNokiaQos_Qos_Classifiers_DscpPolicy{
		Name: &Name,
	}

	return t.DscpPolicy[key], nil
}

// RenameDscpPolicy renames an entry in the list DscpPolicy within
// the SrlNokiaQos_Qos_Classifiers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers) RenameDscpPolicy(oldK, newK string) error {
	if _, ok := t.DscpPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in DscpPolicy", newK)
	}

	e, ok := t.DscpPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DscpPolicy", oldK)
	}
	e.Name = &newK

	t.DscpPolicy[newK] = e
	delete(t.DscpPolicy, oldK)
	return nil
}

// GetOrCreateDscpPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers) GetOrCreateDscpPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_DscpPolicy {
	key := Name

	if v, ok := t.DscpPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDscpPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDscpPolicy got unexpected error: %v", err))
	}
	return v
}

// GetDscpPolicy retrieves the value with the specified key from
// the DscpPolicy map field of SrlNokiaQos_Qos_Classifiers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers) GetDscpPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_DscpPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.DscpPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteDscpPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers) DeleteDscpPolicy(Name string) {
	key := Name

	delete(t.DscpPolicy, key)
}

// AppendDscpPolicy appends the supplied SrlNokiaQos_Qos_Classifiers_DscpPolicy struct to the
// list DscpPolicy of SrlNokiaQos_Qos_Classifiers. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_DscpPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers) AppendDscpPolicy(v *SrlNokiaQos_Qos_Classifiers_DscpPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_DscpPolicy)
	}

	if _, ok := t.DscpPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list DscpPolicy %v", key)
	}

	t.DscpPolicy[key] = v
	return nil
}

// NewDscpReclassifyPolicy creates a new entry in the DscpReclassifyPolicy list of the
// SrlNokiaQos_Qos_Classifiers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers) NewDscpReclassifyPolicy(Name string) (*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpReclassifyPolicy == nil {
		t.DscpReclassifyPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DscpReclassifyPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DscpReclassifyPolicy", key)
	}

	t.DscpReclassifyPolicy[key] = &SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy{
		Name: &Name,
	}

	return t.DscpReclassifyPolicy[key], nil
}

// RenameDscpReclassifyPolicy renames an entry in the list DscpReclassifyPolicy within
// the SrlNokiaQos_Qos_Classifiers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers) RenameDscpReclassifyPolicy(oldK, newK string) error {
	if _, ok := t.DscpReclassifyPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in DscpReclassifyPolicy", newK)
	}

	e, ok := t.DscpReclassifyPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DscpReclassifyPolicy", oldK)
	}
	e.Name = &newK

	t.DscpReclassifyPolicy[newK] = e
	delete(t.DscpReclassifyPolicy, oldK)
	return nil
}

// GetOrCreateDscpReclassifyPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers) GetOrCreateDscpReclassifyPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy {
	key := Name

	if v, ok := t.DscpReclassifyPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDscpReclassifyPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDscpReclassifyPolicy got unexpected error: %v", err))
	}
	return v
}

// GetDscpReclassifyPolicy retrieves the value with the specified key from
// the DscpReclassifyPolicy map field of SrlNokiaQos_Qos_Classifiers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers) GetDscpReclassifyPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.DscpReclassifyPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteDscpReclassifyPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers) DeleteDscpReclassifyPolicy(Name string) {
	key := Name

	delete(t.DscpReclassifyPolicy, key)
}

// AppendDscpReclassifyPolicy appends the supplied SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy struct to the
// list DscpReclassifyPolicy of SrlNokiaQos_Qos_Classifiers. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers) AppendDscpReclassifyPolicy(
	v *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpReclassifyPolicy == nil {
		t.DscpReclassifyPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy)
	}

	if _, ok := t.DscpReclassifyPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list DscpReclassifyPolicy %v", key)
	}

	t.DscpReclassifyPolicy[key] = v
	return nil
}

// NewMplsTrafficClassPolicy creates a new entry in the MplsTrafficClassPolicy list of the
// SrlNokiaQos_Qos_Classifiers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers) NewMplsTrafficClassPolicy(Name string) (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MplsTrafficClassPolicy", key)
	}

	t.MplsTrafficClassPolicy[key] = &SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy{
		Name: &Name,
	}

	return t.MplsTrafficClassPolicy[key], nil
}

// RenameMplsTrafficClassPolicy renames an entry in the list MplsTrafficClassPolicy within
// the SrlNokiaQos_Qos_Classifiers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers) RenameMplsTrafficClassPolicy(oldK, newK string) error {
	if _, ok := t.MplsTrafficClassPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in MplsTrafficClassPolicy", newK)
	}

	e, ok := t.MplsTrafficClassPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MplsTrafficClassPolicy", oldK)
	}
	e.Name = &newK

	t.MplsTrafficClassPolicy[newK] = e
	delete(t.MplsTrafficClassPolicy, oldK)
	return nil
}

// GetOrCreateMplsTrafficClassPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers) GetOrCreateMplsTrafficClassPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy {
	key := Name

	if v, ok := t.MplsTrafficClassPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMplsTrafficClassPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMplsTrafficClassPolicy got unexpected error: %v", err))
	}
	return v
}

// GetMplsTrafficClassPolicy retrieves the value with the specified key from
// the MplsTrafficClassPolicy map field of SrlNokiaQos_Qos_Classifiers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers) GetMplsTrafficClassPolicy(Name string) *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.MplsTrafficClassPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteMplsTrafficClassPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers) DeleteMplsTrafficClassPolicy(Name string) {
	key := Name

	delete(t.MplsTrafficClassPolicy, key)
}

// AppendMplsTrafficClassPolicy appends the supplied SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy struct to the
// list MplsTrafficClassPolicy of SrlNokiaQos_Qos_Classifiers. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers) AppendMplsTrafficClassPolicy(
	v *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy)
	}

	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list MplsTrafficClassPolicy %v", key)
	}

	t.MplsTrafficClassPolicy[key] = v
	return nil
}

// GetOrCreateMultifield retrieves the value of the Multifield field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers) GetOrCreateMultifield() *SrlNokiaQos_Qos_Classifiers_Multifield {
	if t.Multifield != nil {
		return t.Multifield
	}
	t.Multifield = &SrlNokiaQos_Qos_Classifiers_Multifield{}
	return t.Multifield
}

// GetMultifield returns the value of the Multifield struct pointer
// from SrlNokiaQos_Qos_Classifiers. If the receiver or the field Multifield is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers) GetMultifield() *SrlNokiaQos_Qos_Classifiers_Multifield {
	if t != nil && t.Multifield != nil {
		return t.Multifield
	}
	return nil
}

// GetVxlanDefault retrieves the value of the leaf VxlanDefault from the SrlNokiaQos_Qos_Classifiers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VxlanDefault is set, it can
// safely use t.GetVxlanDefault() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VxlanDefault == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers) GetVxlanDefault() string {
	if t == nil || t.VxlanDefault == nil {
		return ""
	}
	return *t.VxlanDefault
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Multifield.PopulateDefaults()
	for _, e := range t.Dot1PPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.DscpPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.DscpReclassifyPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.MplsTrafficClassPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers.
func (*SrlNokiaQos_Qos_Classifiers) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_Dot1PPolicy represents the /srl_nokia-qos/qos/classifiers/dot1p-policy YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Dot1PPolicy struct {
	Dot1P map[uint8]*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P `path:"dot1p" module:"srl_nokia-qos"`
	Name  *string                                                  `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Dot1PPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) IsYANGGoStruct() {}

// NewDot1P creates a new entry in the Dot1P list of the
// SrlNokiaQos_Qos_Classifiers_Dot1PPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) NewDot1P(Value uint8) (*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1P == nil {
		t.Dot1P = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dot1P[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dot1P", key)
	}

	t.Dot1P[key] = &SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P{
		Value: &Value,
	}

	return t.Dot1P[key], nil
}

// RenameDot1P renames an entry in the list Dot1P within
// the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) RenameDot1P(oldK, newK uint8) error {
	if _, ok := t.Dot1P[newK]; ok {
		return fmt.Errorf("key %v already exists in Dot1P", newK)
	}

	e, ok := t.Dot1P[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dot1P", oldK)
	}
	e.Value = &newK

	t.Dot1P[newK] = e
	delete(t.Dot1P, oldK)
	return nil
}

// GetOrCreateDot1P retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Dot1PPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) GetOrCreateDot1P(Value uint8) *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P {
	key := Value

	if v, ok := t.Dot1P[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDot1P(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDot1P got unexpected error: %v", err))
	}
	return v
}

// GetDot1P retrieves the value with the specified key from
// the Dot1P map field of SrlNokiaQos_Qos_Classifiers_Dot1PPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) GetDot1P(Value uint8) *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P {
	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.Dot1P[key]; ok {
		return lm
	}
	return nil
}

// DeleteDot1P deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Dot1PPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) DeleteDot1P(Value uint8) {
	key := Value

	delete(t.Dot1P, key)
}

// AppendDot1P appends the supplied SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P struct to the
// list Dot1P of SrlNokiaQos_Qos_Classifiers_Dot1PPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) AppendDot1P(v *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) error {
	if v.Value == nil {
		return fmt.Errorf("invalid nil key received for Value")
	}

	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1P == nil {
		t.Dot1P = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P)
	}

	if _, ok := t.Dot1P[key]; ok {
		return fmt.Errorf("duplicate key for list Dot1P %v", key)
	}

	t.Dot1P[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Dot1P {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Dot1PPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Dot1PPolicy.
func (*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P represents the /srl_nokia-qos/qos/classifiers/dot1p-policy/dot1p YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P struct {
	DeOutProfile    *bool                                                               `path:"de-out-profile" module:"srl_nokia-qos"`
	DropProbability E_SrlNokiaQos_DropProbability                                       `path:"drop-probability" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P_ForwardingClass_Union `path:"forwarding-class" module:"srl_nokia-qos"`
	IpRemarkPolicy  *string                                                             `path:"ip-remark-policy" module:"srl_nokia-qos"`
	Profile         E_SrlNokiaCommon_ClassifyProfile                                    `path:"profile" module:"srl_nokia-qos"`
	Value           *uint8                                                              `path:"value" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) IsYANGGoStruct() {}

// GetDeOutProfile retrieves the value of the leaf DeOutProfile from the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeOutProfile is set, it can
// safely use t.GetDeOutProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeOutProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) GetDeOutProfile() bool {
	if t == nil || t.DeOutProfile == nil {
		return true
	}
	return *t.DeOutProfile
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) GetDropProbability() E_SrlNokiaQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) GetForwardingClass() SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetIpRemarkPolicy retrieves the value of the leaf IpRemarkPolicy from the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpRemarkPolicy is set, it can
// safely use t.GetIpRemarkPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpRemarkPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) GetIpRemarkPolicy() string {
	if t == nil || t.IpRemarkPolicy == nil {
		return ""
	}
	return *t.IpRemarkPolicy
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) GetProfile() E_SrlNokiaCommon_ClassifyProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) GetValue() uint8 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DeOutProfile == nil {
		var v bool = true
		t.DeOutProfile = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P.
func (*SrlNokiaQos_Qos_Classifiers_Dot1PPolicy_Dot1P) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_DscpPolicy represents the /srl_nokia-qos/qos/classifiers/dscp-policy YANG schema element.
type SrlNokiaQos_Qos_Classifiers_DscpPolicy struct {
	Dscp map[uint8]*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp `path:"dscp" module:"srl_nokia-qos"`
	Name *string                                                `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_DscpPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_DscpPolicy) IsYANGGoStruct() {}

// NewDscp creates a new entry in the Dscp list of the
// SrlNokiaQos_Qos_Classifiers_DscpPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) NewDscp(Value uint8) (*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dscp == nil {
		t.Dscp = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dscp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dscp", key)
	}

	t.Dscp[key] = &SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp{
		Value: &Value,
	}

	return t.Dscp[key], nil
}

// RenameDscp renames an entry in the list Dscp within
// the SrlNokiaQos_Qos_Classifiers_DscpPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) RenameDscp(oldK, newK uint8) error {
	if _, ok := t.Dscp[newK]; ok {
		return fmt.Errorf("key %v already exists in Dscp", newK)
	}

	e, ok := t.Dscp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dscp", oldK)
	}
	e.Value = &newK

	t.Dscp[newK] = e
	delete(t.Dscp, oldK)
	return nil
}

// GetOrCreateDscp retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_DscpPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) GetOrCreateDscp(Value uint8) *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp {
	key := Value

	if v, ok := t.Dscp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDscp(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDscp got unexpected error: %v", err))
	}
	return v
}

// GetDscp retrieves the value with the specified key from
// the Dscp map field of SrlNokiaQos_Qos_Classifiers_DscpPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) GetDscp(Value uint8) *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp {
	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.Dscp[key]; ok {
		return lm
	}
	return nil
}

// DeleteDscp deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_DscpPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) DeleteDscp(Value uint8) {
	key := Value

	delete(t.Dscp, key)
}

// AppendDscp appends the supplied SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp struct to the
// list Dscp of SrlNokiaQos_Qos_Classifiers_DscpPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) AppendDscp(v *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) error {
	if v.Value == nil {
		return fmt.Errorf("invalid nil key received for Value")
	}

	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dscp == nil {
		t.Dscp = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp)
	}

	if _, ok := t.Dscp[key]; ok {
		return fmt.Errorf("duplicate key for list Dscp %v", key)
	}

	t.Dscp[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Classifiers_DscpPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_DscpPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Dscp {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_DscpPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_DscpPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_DscpPolicy.
func (*SrlNokiaQos_Qos_Classifiers_DscpPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp represents the /srl_nokia-qos/qos/classifiers/dscp-policy/dscp YANG schema element.
type SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp struct {
	DeOutProfile    *bool                                                             `path:"de-out-profile" module:"srl_nokia-qos"`
	DropProbability E_SrlNokiaQos_DropProbability                                     `path:"drop-probability" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp_ForwardingClass_Union `path:"forwarding-class" module:"srl_nokia-qos"`
	IpRemarkPolicy  *string                                                           `path:"ip-remark-policy" module:"srl_nokia-qos"`
	Profile         E_SrlNokiaCommon_ClassifyProfile                                  `path:"profile" module:"srl_nokia-qos"`
	Value           *uint8                                                            `path:"value" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) IsYANGGoStruct() {}

// GetDeOutProfile retrieves the value of the leaf DeOutProfile from the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeOutProfile is set, it can
// safely use t.GetDeOutProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeOutProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) GetDeOutProfile() bool {
	if t == nil || t.DeOutProfile == nil {
		return true
	}
	return *t.DeOutProfile
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) GetDropProbability() E_SrlNokiaQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) GetForwardingClass() SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetIpRemarkPolicy retrieves the value of the leaf IpRemarkPolicy from the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpRemarkPolicy is set, it can
// safely use t.GetIpRemarkPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpRemarkPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) GetIpRemarkPolicy() string {
	if t == nil || t.IpRemarkPolicy == nil {
		return ""
	}
	return *t.IpRemarkPolicy
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) GetProfile() E_SrlNokiaCommon_ClassifyProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) GetValue() uint8 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DeOutProfile == nil {
		var v bool = true
		t.DeOutProfile = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp.
func (*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy represents the /srl_nokia-qos/qos/classifiers/dscp-reclassify-policy YANG schema element.
type SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy struct {
	Dscp map[uint8]*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp `path:"dscp" module:"srl_nokia-qos"`
	Name *string                                                          `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) IsYANGGoStruct() {}

// NewDscp creates a new entry in the Dscp list of the
// SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) NewDscp(Value uint8) (*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dscp == nil {
		t.Dscp = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dscp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dscp", key)
	}

	t.Dscp[key] = &SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp{
		Value: &Value,
	}

	return t.Dscp[key], nil
}

// RenameDscp renames an entry in the list Dscp within
// the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) RenameDscp(oldK, newK uint8) error {
	if _, ok := t.Dscp[newK]; ok {
		return fmt.Errorf("key %v already exists in Dscp", newK)
	}

	e, ok := t.Dscp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dscp", oldK)
	}
	e.Value = &newK

	t.Dscp[newK] = e
	delete(t.Dscp, oldK)
	return nil
}

// GetOrCreateDscp retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) GetOrCreateDscp(Value uint8) *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp {
	key := Value

	if v, ok := t.Dscp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDscp(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDscp got unexpected error: %v", err))
	}
	return v
}

// GetDscp retrieves the value with the specified key from
// the Dscp map field of SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) GetDscp(Value uint8) *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp {
	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.Dscp[key]; ok {
		return lm
	}
	return nil
}

// DeleteDscp deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) DeleteDscp(Value uint8) {
	key := Value

	delete(t.Dscp, key)
}

// AppendDscp appends the supplied SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp struct to the
// list Dscp of SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) AppendDscp(
	v *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp,
) error {
	if v.Value == nil {
		return fmt.Errorf("invalid nil key received for Value")
	}

	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dscp == nil {
		t.Dscp = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp)
	}

	if _, ok := t.Dscp[key]; ok {
		return fmt.Errorf("duplicate key for list Dscp %v", key)
	}

	t.Dscp[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Dscp {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy.
func (*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp represents the /srl_nokia-qos/qos/classifiers/dscp-reclassify-policy/dscp YANG schema element.
type SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp struct {
	ForwardingClass SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp_ForwardingClass_Union `path:"forwarding-class" module:"srl_nokia-qos"`
	Profile         E_SrlNokiaCommon_ClassifyProfile                                            `path:"profile" module:"srl_nokia-qos"`
	Value           *uint8                                                                      `path:"value" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) IsYANGGoStruct() {}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) GetForwardingClass() SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) GetProfile() E_SrlNokiaCommon_ClassifyProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) GetValue() uint8 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp.
func (*SrlNokiaQos_Qos_Classifiers_DscpReclassifyPolicy_Dscp) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy represents the /srl_nokia-qos/qos/classifiers/mpls-traffic-class-policy YANG schema element.
type SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy struct {
	Name         *string                                                                    `path:"name" module:"srl_nokia-qos"`
	TrafficClass map[uint8]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass `path:"traffic-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) IsYANGGoStruct() {}

// NewTrafficClass creates a new entry in the TrafficClass list of the
// SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) NewTrafficClass(Value uint8) (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficClass == nil {
		t.TrafficClass = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrafficClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrafficClass", key)
	}

	t.TrafficClass[key] = &SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass{
		Value: &Value,
	}

	return t.TrafficClass[key], nil
}

// RenameTrafficClass renames an entry in the list TrafficClass within
// the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) RenameTrafficClass(oldK, newK uint8) error {
	if _, ok := t.TrafficClass[newK]; ok {
		return fmt.Errorf("key %v already exists in TrafficClass", newK)
	}

	e, ok := t.TrafficClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrafficClass", oldK)
	}
	e.Value = &newK

	t.TrafficClass[newK] = e
	delete(t.TrafficClass, oldK)
	return nil
}

// GetOrCreateTrafficClass retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) GetOrCreateTrafficClass(Value uint8) *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass {
	key := Value

	if v, ok := t.TrafficClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrafficClass(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrafficClass got unexpected error: %v", err))
	}
	return v
}

// GetTrafficClass retrieves the value with the specified key from
// the TrafficClass map field of SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) GetTrafficClass(Value uint8) *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass {
	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.TrafficClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteTrafficClass deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) DeleteTrafficClass(Value uint8) {
	key := Value

	delete(t.TrafficClass, key)
}

// AppendTrafficClass appends the supplied SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass struct to the
// list TrafficClass of SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) AppendTrafficClass(
	v *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass,
) error {
	if v.Value == nil {
		return fmt.Errorf("invalid nil key received for Value")
	}

	key := *v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficClass == nil {
		t.TrafficClass = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass)
	}

	if _, ok := t.TrafficClass[key]; ok {
		return fmt.Errorf("duplicate key for list TrafficClass %v", key)
	}

	t.TrafficClass[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.TrafficClass {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy.
func (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass represents the /srl_nokia-qos/qos/classifiers/mpls-traffic-class-policy/traffic-class YANG schema element.
type SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass struct {
	DeOutProfile    *bool                                                                                 `path:"de-out-profile" module:"srl_nokia-qos"`
	DropProbability E_SrlNokiaQos_DropProbability                                                         `path:"drop-probability" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass_ForwardingClass_Union `path:"forwarding-class" module:"srl_nokia-qos"`
	IpRemarkPolicy  *string                                                                               `path:"ip-remark-policy" module:"srl_nokia-qos"`
	Profile         E_SrlNokiaCommon_ClassifyProfile                                                      `path:"profile" module:"srl_nokia-qos"`
	Value           *uint8                                                                                `path:"value" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) IsYANGGoStruct() {}

// GetDeOutProfile retrieves the value of the leaf DeOutProfile from the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeOutProfile is set, it can
// safely use t.GetDeOutProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeOutProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) GetDeOutProfile() bool {
	if t == nil || t.DeOutProfile == nil {
		return true
	}
	return *t.DeOutProfile
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) GetDropProbability() E_SrlNokiaQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) GetForwardingClass() SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetIpRemarkPolicy retrieves the value of the leaf IpRemarkPolicy from the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpRemarkPolicy is set, it can
// safely use t.GetIpRemarkPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpRemarkPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) GetIpRemarkPolicy() string {
	if t == nil || t.IpRemarkPolicy == nil {
		return ""
	}
	return *t.IpRemarkPolicy
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) GetProfile() E_SrlNokiaCommon_ClassifyProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) GetValue() uint8 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DeOutProfile == nil {
		var v bool = true
		t.DeOutProfile = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass.
func (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield represents the /srl_nokia-qos/qos/classifiers/multifield YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield struct {
	Ipv4Policy map[string]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy `path:"ipv4-policy" module:"srl_nokia-acl-qos"`
	Ipv6Policy map[string]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy `path:"ipv6-policy" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield) IsYANGGoStruct() {}

// NewIpv4Policy creates a new entry in the Ipv4Policy list of the
// SrlNokiaQos_Qos_Classifiers_Multifield struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) NewIpv4Policy(Name string) (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Policy == nil {
		t.Ipv4Policy = make(map[string]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Policy", key)
	}

	t.Ipv4Policy[key] = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy{
		Name: &Name,
	}

	return t.Ipv4Policy[key], nil
}

// RenameIpv4Policy renames an entry in the list Ipv4Policy within
// the SrlNokiaQos_Qos_Classifiers_Multifield struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) RenameIpv4Policy(oldK, newK string) error {
	if _, ok := t.Ipv4Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Policy", newK)
	}

	e, ok := t.Ipv4Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Policy", oldK)
	}
	e.Name = &newK

	t.Ipv4Policy[newK] = e
	delete(t.Ipv4Policy, oldK)
	return nil
}

// GetOrCreateIpv4Policy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) GetOrCreateIpv4Policy(Name string) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy {
	key := Name

	if v, ok := t.Ipv4Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Policy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Policy got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Policy retrieves the value with the specified key from
// the Ipv4Policy map field of SrlNokiaQos_Qos_Classifiers_Multifield. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) GetIpv4Policy(Name string) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv4Policy[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Policy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) DeleteIpv4Policy(Name string) {
	key := Name

	delete(t.Ipv4Policy, key)
}

// AppendIpv4Policy appends the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy struct to the
// list Ipv4Policy of SrlNokiaQos_Qos_Classifiers_Multifield. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) AppendIpv4Policy(
	v *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Policy == nil {
		t.Ipv4Policy = make(map[string]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy)
	}

	if _, ok := t.Ipv4Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Policy %v", key)
	}

	t.Ipv4Policy[key] = v
	return nil
}

// NewIpv6Policy creates a new entry in the Ipv6Policy list of the
// SrlNokiaQos_Qos_Classifiers_Multifield struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) NewIpv6Policy(Name string) (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Policy == nil {
		t.Ipv6Policy = make(map[string]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Policy", key)
	}

	t.Ipv6Policy[key] = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy{
		Name: &Name,
	}

	return t.Ipv6Policy[key], nil
}

// RenameIpv6Policy renames an entry in the list Ipv6Policy within
// the SrlNokiaQos_Qos_Classifiers_Multifield struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) RenameIpv6Policy(oldK, newK string) error {
	if _, ok := t.Ipv6Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Policy", newK)
	}

	e, ok := t.Ipv6Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Policy", oldK)
	}
	e.Name = &newK

	t.Ipv6Policy[newK] = e
	delete(t.Ipv6Policy, oldK)
	return nil
}

// GetOrCreateIpv6Policy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) GetOrCreateIpv6Policy(Name string) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy {
	key := Name

	if v, ok := t.Ipv6Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Policy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Policy got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Policy retrieves the value with the specified key from
// the Ipv6Policy map field of SrlNokiaQos_Qos_Classifiers_Multifield. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) GetIpv6Policy(Name string) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv6Policy[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Policy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) DeleteIpv6Policy(Name string) {
	key := Name

	delete(t.Ipv6Policy, key)
}

// AppendIpv6Policy appends the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy struct to the
// list Ipv6Policy of SrlNokiaQos_Qos_Classifiers_Multifield. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) AppendIpv6Policy(
	v *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Policy == nil {
		t.Ipv6Policy = make(map[string]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy)
	}

	if _, ok := t.Ipv6Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Policy %v", key)
	}

	t.Ipv6Policy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Ipv4Policy {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Policy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield.
func (*SrlNokiaQos_Qos_Classifiers_Multifield) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy struct {
	Entry map[uint32]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry `path:"entry" module:"srl_nokia-acl-qos"`
	Name  *string                                                             `path:"name" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) NewEntry(SequenceId uint32) (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) GetOrCreateEntry(SequenceId uint32) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) GetEntry(SequenceId uint32) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry struct to the
// list Entry of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) AppendEntry(
	v *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry struct {
	Action     *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action `path:"action" module:"srl_nokia-acl-qos"`
	Match      *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match  `path:"match" module:"srl_nokia-acl-qos"`
	SequenceId *uint32                                                         `path:"sequence-id" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) GetOrCreateAction() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) GetOrCreateMatch() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) GetAction() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) GetMatch() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/action YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action struct {
	DropProbability E_SrlNokiaAclQos_DropProbability                                                     `path:"drop-probability" module:"srl_nokia-acl-qos"`
	ForwardingClass SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_ForwardingClass_Union `path:"forwarding-class" module:"srl_nokia-acl-qos"`
	Rewrite         *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite              `path:"rewrite" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateRewrite retrieves the value of the Rewrite field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) GetOrCreateRewrite() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite {
	if t.Rewrite != nil {
		return t.Rewrite
	}
	t.Rewrite = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite{}
	return t.Rewrite
}

// GetRewrite returns the value of the Rewrite struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action. If the receiver or the field Rewrite is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) GetRewrite() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite {
	if t != nil && t.Rewrite != nil {
		return t.Rewrite
	}
	return nil
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) GetDropProbability() E_SrlNokiaAclQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) GetForwardingClass() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Rewrite.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/action/rewrite YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite struct {
	SetDscp *uint8 `path:"set-dscp" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite) IsYANGGoStruct() {}

// GetSetDscp retrieves the value of the leaf SetDscp from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetDscp is set, it can
// safely use t.GetSetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetDscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite) GetSetDscp() uint8 {
	if t == nil || t.SetDscp == nil {
		return 0
	}
	return *t.SetDscp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Action_Rewrite) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match struct {
	DestinationIp   *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl-qos"`
	DestinationPort *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl-qos"`
	DscpSet         []SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl-qos"`
	FirstFragment   *bool                                                                          `path:"first-fragment" module:"srl_nokia-acl-qos"`
	Fragment        *bool                                                                          `path:"fragment" module:"srl_nokia-acl-qos"`
	Icmp            *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp            `path:"icmp" module:"srl_nokia-acl-qos"`
	Protocol        SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Protocol_Union   `path:"protocol" module:"srl_nokia-acl-qos"`
	SourceIp        *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl-qos"`
	SourcePort      *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl-qos"`
	TcpFlags        *string                                                                        `path:"tcp-flags" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetOrCreateIcmp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetOrCreateSourceIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetOrCreateSourcePort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetDestinationIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetDestinationPort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetIcmp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetSourceIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetSourcePort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetDscpSet() []SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetFirstFragment retrieves the value of the leaf FirstFragment from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirstFragment is set, it can
// safely use t.GetFirstFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirstFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetFirstFragment() bool {
	if t == nil || t.FirstFragment == nil {
		return false
	}
	return *t.FirstFragment
}

// GetFragment retrieves the value of the leaf Fragment from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetFragment() bool {
	if t == nil || t.Fragment == nil {
		return false
	}
	return *t.Fragment
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetProtocol() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match/destination-ip YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl-qos"`
	Mask    *string `path:"mask" module:"srl_nokia-acl-qos"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match/destination-port YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                                       `path:"operator" module:"srl_nokia-acl-qos"`
	Range    *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl-qos"`
	Value    SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) GetRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) GetValue() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match/destination-port/range YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl-qos"`
	Start SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match/icmp YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp struct {
	Code []uint8                                                                       `path:"code" module:"srl_nokia-acl-qos"`
	Type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp_Type_Union `path:"type" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) GetType() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_Icmp) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match/source-ip YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl-qos"`
	Mask    *string `path:"mask" module:"srl_nokia-acl-qos"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match/source-port YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                                  `path:"operator" module:"srl_nokia-acl-qos"`
	Range    *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl-qos"`
	Value    SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) GetRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) GetValue() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range represents the /srl_nokia-qos/qos/classifiers/multifield/ipv4-policy/entry/match/source-port/range YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl-qos"`
	Start SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) GetStart() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv4Policy_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy struct {
	Entry map[uint32]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry `path:"entry" module:"srl_nokia-acl-qos"`
	Name  *string                                                             `path:"name" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) NewEntry(SequenceId uint32) (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) GetOrCreateEntry(SequenceId uint32) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) GetEntry(SequenceId uint32) *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry struct to the
// list Entry of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) AppendEntry(
	v *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry struct {
	Action     *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action `path:"action" module:"srl_nokia-acl-qos"`
	Match      *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match  `path:"match" module:"srl_nokia-acl-qos"`
	SequenceId *uint32                                                         `path:"sequence-id" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) GetOrCreateAction() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) GetOrCreateMatch() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) GetAction() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) GetMatch() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/action YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action struct {
	DropProbability E_SrlNokiaAclQos_DropProbability                                                     `path:"drop-probability" module:"srl_nokia-acl-qos"`
	ForwardingClass SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_ForwardingClass_Union `path:"forwarding-class" module:"srl_nokia-acl-qos"`
	Rewrite         *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite              `path:"rewrite" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateRewrite retrieves the value of the Rewrite field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) GetOrCreateRewrite() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite {
	if t.Rewrite != nil {
		return t.Rewrite
	}
	t.Rewrite = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite{}
	return t.Rewrite
}

// GetRewrite returns the value of the Rewrite struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action. If the receiver or the field Rewrite is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) GetRewrite() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite {
	if t != nil && t.Rewrite != nil {
		return t.Rewrite
	}
	return nil
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) GetDropProbability() E_SrlNokiaAclQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) GetForwardingClass() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Rewrite.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/action/rewrite YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite struct {
	SetDscp *uint8 `path:"set-dscp" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite) IsYANGGoStruct() {}

// GetSetDscp retrieves the value of the leaf SetDscp from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetDscp is set, it can
// safely use t.GetSetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetDscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite) GetSetDscp() uint8 {
	if t == nil || t.SetDscp == nil {
		return 0
	}
	return *t.SetDscp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Action_Rewrite) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match struct {
	DestinationIp   *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl-qos"`
	DestinationPort *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl-qos"`
	DscpSet         []SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl-qos"`
	Icmp6           *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl-qos"`
	NextHeader      SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl-qos"`
	SourceIp        *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl-qos"`
	SourcePort      *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl-qos"`
	TcpFlags        *string                                                                        `path:"tcp-flags" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetOrCreateIcmp6() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetOrCreateSourceIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetOrCreateSourcePort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetDestinationIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetDestinationPort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetIcmp6() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetSourceIp() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetSourcePort() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetDscpSet() []SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetNextHeader() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match/destination-ip YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl-qos"`
	Mask    *string `path:"mask" module:"srl_nokia-acl-qos"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match/destination-port YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                                       `path:"operator" module:"srl_nokia-acl-qos"`
	Range    *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl-qos"`
	Value    SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) GetRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) GetValue() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match/destination-port/range YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl-qos"`
	Start SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6 represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match/icmp6 YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6 struct {
	Code []uint8                                                                        `path:"code" module:"srl_nokia-acl-qos"`
	Type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) GetType() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match/source-ip YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl-qos"`
	Mask    *string `path:"mask" module:"srl_nokia-acl-qos"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match/source-port YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                                  `path:"operator" module:"srl_nokia-acl-qos"`
	Range    *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl-qos"`
	Value    SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) GetRange() *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) GetValue() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range represents the /srl_nokia-qos/qos/classifiers/multifield/ipv6-policy/entry/match/source-port/range YANG schema element.
type SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl-qos"`
	Start SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) GetStart() SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range.
func (*SrlNokiaQos_Qos_Classifiers_Multifield_Ipv6Policy_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl-qos"
}

// SrlNokiaQos_Qos_ExplicitCongestionNotification represents the /srl_nokia-qos/qos/explicit-congestion-notification YANG schema element.
type SrlNokiaQos_Qos_ExplicitCongestionNotification struct {
	EcnDscpPolicy *string `path:"ecn-dscp-policy" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ExplicitCongestionNotification implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ExplicitCongestionNotification) IsYANGGoStruct() {}

// GetEcnDscpPolicy retrieves the value of the leaf EcnDscpPolicy from the SrlNokiaQos_Qos_ExplicitCongestionNotification
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EcnDscpPolicy is set, it can
// safely use t.GetEcnDscpPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EcnDscpPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ExplicitCongestionNotification) GetEcnDscpPolicy() string {
	if t == nil || t.EcnDscpPolicy == nil {
		return ""
	}
	return *t.EcnDscpPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ExplicitCongestionNotification
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ExplicitCongestionNotification) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ExplicitCongestionNotification) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ExplicitCongestionNotification"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ExplicitCongestionNotification) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ExplicitCongestionNotification) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ExplicitCongestionNotification.
func (*SrlNokiaQos_Qos_ExplicitCongestionNotification) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ForwardingClasses represents the /srl_nokia-qos/qos/forwarding-classes YANG schema element.
type SrlNokiaQos_Qos_ForwardingClasses struct {
	ForwardingClass map[string]*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass `path:"forwarding-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ForwardingClasses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ForwardingClasses) IsYANGGoStruct() {}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// SrlNokiaQos_Qos_ForwardingClasses struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ForwardingClasses) NewForwardingClass(Name string) (*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[string]*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass{
		Name: &Name,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the SrlNokiaQos_Qos_ForwardingClasses struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ForwardingClasses) RenameForwardingClass(oldK, newK string) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Name = &newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ForwardingClasses. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ForwardingClasses) GetOrCreateForwardingClass(Name string) *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass {
	key := Name

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of SrlNokiaQos_Qos_ForwardingClasses. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ForwardingClasses) GetForwardingClass(Name string) *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingClass deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ForwardingClasses. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ForwardingClasses) DeleteForwardingClass(Name string) {
	key := Name

	delete(t.ForwardingClass, key)
}

// AppendForwardingClass appends the supplied SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass struct to the
// list ForwardingClass of SrlNokiaQos_Qos_ForwardingClasses. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ForwardingClasses) AppendForwardingClass(
	v *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[string]*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ForwardingClasses
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ForwardingClasses) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ForwardingClass {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ForwardingClasses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ForwardingClasses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ForwardingClasses.
func (*SrlNokiaQos_Qos_ForwardingClasses) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass represents the /srl_nokia-qos/qos/forwarding-classes/forwarding-class YANG schema element.
type SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass struct {
	ForwardingClassIndex *uint8                                                    `path:"forwarding-class-index" module:"srl_nokia-qos"`
	Input                *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input  `path:"input" module:"srl_nokia-qos"`
	Name                 *string                                                   `path:"name" module:"srl_nokia-qos"`
	Output               *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output `path:"output" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) IsYANGGoStruct() {}

// GetOrCreateInput retrieves the value of the Input field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) GetOrCreateInput() *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input {
	if t.Input != nil {
		return t.Input
	}
	t.Input = &SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input{}
	return t.Input
}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) GetOrCreateOutput() *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output{}
	return t.Output
}

// GetInput returns the value of the Input struct pointer
// from SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass. If the receiver or the field Input is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) GetInput() *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input {
	if t != nil && t.Input != nil {
		return t.Input
	}
	return nil
}

// GetOutput returns the value of the Output struct pointer
// from SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) GetOutput() *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// GetForwardingClassIndex retrieves the value of the leaf ForwardingClassIndex from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClassIndex is set, it can
// safely use t.GetForwardingClassIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClassIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) GetForwardingClassIndex() uint8 {
	if t == nil || t.ForwardingClassIndex == nil {
		return 0
	}
	return *t.ForwardingClassIndex
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Input.PopulateDefaults()
	t.Output.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass.
func (*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input represents the /srl_nokia-qos/qos/forwarding-classes/forwarding-class/input YANG schema element.
type SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input struct {
	BroadcastPolicer      *string `path:"broadcast-policer" module:"srl_nokia-qos"`
	MulticastPolicer      *string `path:"multicast-policer" module:"srl_nokia-qos"`
	UnicastPolicer        *string `path:"unicast-policer" module:"srl_nokia-qos"`
	UnknownUnicastPolicer *string `path:"unknown-unicast-policer" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) IsYANGGoStruct() {}

// GetBroadcastPolicer retrieves the value of the leaf BroadcastPolicer from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BroadcastPolicer is set, it can
// safely use t.GetBroadcastPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BroadcastPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) GetBroadcastPolicer() string {
	if t == nil || t.BroadcastPolicer == nil {
		return ""
	}
	return *t.BroadcastPolicer
}

// GetMulticastPolicer retrieves the value of the leaf MulticastPolicer from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastPolicer is set, it can
// safely use t.GetMulticastPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) GetMulticastPolicer() string {
	if t == nil || t.MulticastPolicer == nil {
		return ""
	}
	return *t.MulticastPolicer
}

// GetUnicastPolicer retrieves the value of the leaf UnicastPolicer from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnicastPolicer is set, it can
// safely use t.GetUnicastPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnicastPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) GetUnicastPolicer() string {
	if t == nil || t.UnicastPolicer == nil {
		return ""
	}
	return *t.UnicastPolicer
}

// GetUnknownUnicastPolicer retrieves the value of the leaf UnknownUnicastPolicer from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnknownUnicastPolicer is set, it can
// safely use t.GetUnknownUnicastPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnknownUnicastPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) GetUnknownUnicastPolicer() string {
	if t == nil || t.UnknownUnicastPolicer == nil {
		return ""
	}
	return *t.UnknownUnicastPolicer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input.
func (*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Input) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output represents the /srl_nokia-qos/qos/forwarding-classes/forwarding-class/output YANG schema element.
type SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output struct {
	MulticastQueue *string `path:"multicast-queue" module:"srl_nokia-qos"`
	Queue          *string `path:"queue" module:"srl_nokia-qos"`
	UnicastQueue   *string `path:"unicast-queue" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) IsYANGGoStruct() {}

// GetMulticastQueue retrieves the value of the leaf MulticastQueue from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastQueue is set, it can
// safely use t.GetMulticastQueue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastQueue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) GetMulticastQueue() string {
	if t == nil || t.MulticastQueue == nil {
		return ""
	}
	return *t.MulticastQueue
}

// GetQueue retrieves the value of the leaf Queue from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Queue is set, it can
// safely use t.GetQueue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Queue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) GetQueue() string {
	if t == nil || t.Queue == nil {
		return ""
	}
	return *t.Queue
}

// GetUnicastQueue retrieves the value of the leaf UnicastQueue from the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnicastQueue is set, it can
// safely use t.GetUnicastQueue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnicastQueue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) GetUnicastQueue() string {
	if t == nil || t.UnicastQueue == nil {
		return ""
	}
	return *t.UnicastQueue
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output.
func (*SrlNokiaQos_Qos_ForwardingClasses_ForwardingClass_Output) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_OutClassMap represents the /srl_nokia-qos/qos/out-class-map YANG schema element.
type SrlNokiaQos_Qos_OutClassMap struct {
	ForwardingClass map[SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_OutClassMap_ForwardingClass `path:"forwarding-class" module:"srl_nokia-qos"`
	Name            *string                                                                                                 `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_OutClassMap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_OutClassMap) IsYANGGoStruct() {}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// SrlNokiaQos_Qos_OutClassMap struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_OutClassMap) NewForwardingClass(Name SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union) (*SrlNokiaQos_Qos_OutClassMap_ForwardingClass, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_OutClassMap_ForwardingClass)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &SrlNokiaQos_Qos_OutClassMap_ForwardingClass{
		Name: Name,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the SrlNokiaQos_Qos_OutClassMap struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_OutClassMap) RenameForwardingClass(
	oldK, newK SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union,
) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Name = newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_OutClassMap. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_OutClassMap) GetOrCreateForwardingClass(
	Name SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union,
) *SrlNokiaQos_Qos_OutClassMap_ForwardingClass {
	key := Name

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of SrlNokiaQos_Qos_OutClassMap. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_OutClassMap) GetForwardingClass(Name SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union) *SrlNokiaQos_Qos_OutClassMap_ForwardingClass {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingClass deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_OutClassMap. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_OutClassMap) DeleteForwardingClass(
	Name SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union,
) {
	key := Name

	delete(t.ForwardingClass, key)
}

// AppendForwardingClass appends the supplied SrlNokiaQos_Qos_OutClassMap_ForwardingClass struct to the
// list ForwardingClass of SrlNokiaQos_Qos_OutClassMap. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_OutClassMap_ForwardingClass already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_OutClassMap) AppendForwardingClass(v *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_OutClassMap_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_OutClassMap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_OutClassMap) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_OutClassMap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_OutClassMap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ForwardingClass {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_OutClassMap struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_OutClassMap) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_OutClassMap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_OutClassMap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_OutClassMap) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_OutClassMap) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_OutClassMap.
func (*SrlNokiaQos_Qos_OutClassMap) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_OutClassMap_ForwardingClass represents the /srl_nokia-qos/qos/out-class-map/forwarding-class YANG schema element.
type SrlNokiaQos_Qos_OutClassMap_ForwardingClass struct {
	Name  SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union `path:"name" module:"srl_nokia-qos"`
	Queue *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue     `path:"queue" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_OutClassMap_ForwardingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_OutClassMap_ForwardingClass) IsYANGGoStruct() {}

// GetOrCreateQueue retrieves the value of the Queue field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) GetOrCreateQueue() *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue {
	if t.Queue != nil {
		return t.Queue
	}
	t.Queue = &SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue{}
	return t.Queue
}

// GetQueue returns the value of the Queue struct pointer
// from SrlNokiaQos_Qos_OutClassMap_ForwardingClass. If the receiver or the field Queue is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) GetQueue() *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue {
	if t != nil && t.Queue != nil {
		return t.Queue
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_OutClassMap_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) GetName() SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Name_Union {
	if t == nil || t.Name == nil {
		return nil
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_OutClassMap_ForwardingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Queue.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_OutClassMap_ForwardingClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_OutClassMap_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_OutClassMap_ForwardingClass.
func (*SrlNokiaQos_Qos_OutClassMap_ForwardingClass) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue represents the /srl_nokia-qos/qos/out-class-map/forwarding-class/queue YANG schema element.
type SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue struct {
	QueueName  SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue_QueueName_Union `path:"queue-name" module:"srl_nokia-qos"`
	ReDirectTo E_SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue_ReDirectTo    `path:"re-direct-to" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) IsYANGGoStruct() {}

// GetQueueName retrieves the value of the leaf QueueName from the SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueueName is set, it can
// safely use t.GetQueueName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueueName == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) GetQueueName() SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue_QueueName_Union {
	if t == nil || t.QueueName == nil {
		return nil
	}
	return t.QueueName
}

// GetReDirectTo retrieves the value of the leaf ReDirectTo from the SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReDirectTo is set, it can
// safely use t.GetReDirectTo() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReDirectTo == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) GetReDirectTo() E_SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue_ReDirectTo {
	if t == nil || t.ReDirectTo == 0 {
		return 0
	}
	return t.ReDirectTo
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue.
func (*SrlNokiaQos_Qos_OutClassMap_ForwardingClass_Queue) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_PolicerTemplates represents the /srl_nokia-qos/qos/policer-templates YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates struct {
	PolicerTemplate map[string]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate `path:"policer-template" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates) IsYANGGoStruct() {}

// NewPolicerTemplate creates a new entry in the PolicerTemplate list of the
// SrlNokiaQos_Qos_PolicerTemplates struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_PolicerTemplates) NewPolicerTemplate(Name string) (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicerTemplate == nil {
		t.PolicerTemplate = make(map[string]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PolicerTemplate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PolicerTemplate", key)
	}

	t.PolicerTemplate[key] = &SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate{
		Name: &Name,
	}

	return t.PolicerTemplate[key], nil
}

// RenamePolicerTemplate renames an entry in the list PolicerTemplate within
// the SrlNokiaQos_Qos_PolicerTemplates struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_PolicerTemplates) RenamePolicerTemplate(oldK, newK string) error {
	if _, ok := t.PolicerTemplate[newK]; ok {
		return fmt.Errorf("key %v already exists in PolicerTemplate", newK)
	}

	e, ok := t.PolicerTemplate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PolicerTemplate", oldK)
	}
	e.Name = &newK

	t.PolicerTemplate[newK] = e
	delete(t.PolicerTemplate, oldK)
	return nil
}

// GetOrCreatePolicerTemplate retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_PolicerTemplates. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_PolicerTemplates) GetOrCreatePolicerTemplate(Name string) *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate {
	key := Name

	if v, ok := t.PolicerTemplate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicerTemplate(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicerTemplate got unexpected error: %v", err))
	}
	return v
}

// GetPolicerTemplate retrieves the value with the specified key from
// the PolicerTemplate map field of SrlNokiaQos_Qos_PolicerTemplates. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_PolicerTemplates) GetPolicerTemplate(Name string) *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.PolicerTemplate[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicerTemplate deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_PolicerTemplates. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_PolicerTemplates) DeletePolicerTemplate(Name string) {
	key := Name

	delete(t.PolicerTemplate, key)
}

// AppendPolicerTemplate appends the supplied SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate struct to the
// list PolicerTemplate of SrlNokiaQos_Qos_PolicerTemplates. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_PolicerTemplates) AppendPolicerTemplate(
	v *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PolicerTemplate == nil {
		t.PolicerTemplate = make(map[string]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate)
	}

	if _, ok := t.PolicerTemplate[key]; ok {
		return fmt.Errorf("duplicate key for list PolicerTemplate %v", key)
	}

	t.PolicerTemplate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.PolicerTemplate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates.
func (*SrlNokiaQos_Qos_PolicerTemplates) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate represents the /srl_nokia-qos/qos/policer-templates/policer-template YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate struct {
	Name           *string                                                              `path:"name" module:"srl_nokia-qos"`
	Policer        map[uint32]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer `path:"policer" module:"srl_nokia-qos"`
	StatisticsMode E_SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_StatisticsMode    `path:"statistics-mode" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) IsYANGGoStruct() {}

// NewPolicer creates a new entry in the Policer list of the
// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) NewPolicer(SequenceId uint32) (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[uint32]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policer", key)
	}

	t.Policer[key] = &SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer{
		SequenceId: &SequenceId,
	}

	return t.Policer[key], nil
}

// RenamePolicer renames an entry in the list Policer within
// the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) RenamePolicer(oldK, newK uint32) error {
	if _, ok := t.Policer[newK]; ok {
		return fmt.Errorf("key %v already exists in Policer", newK)
	}

	e, ok := t.Policer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policer", oldK)
	}
	e.SequenceId = &newK

	t.Policer[newK] = e
	delete(t.Policer, oldK)
	return nil
}

// GetOrCreatePolicer retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) GetOrCreatePolicer(SequenceId uint32) *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer {
	key := SequenceId

	if v, ok := t.Policer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicer(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicer got unexpected error: %v", err))
	}
	return v
}

// GetPolicer retrieves the value with the specified key from
// the Policer map field of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) GetPolicer(SequenceId uint32) *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Policer[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicer deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) DeletePolicer(SequenceId uint32) {
	key := SequenceId

	delete(t.Policer, key)
}

// AppendPolicer appends the supplied SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer struct to the
// list Policer of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) AppendPolicer(
	v *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[uint32]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer)
	}

	if _, ok := t.Policer[key]; ok {
		return fmt.Errorf("duplicate key for list Policer %v", key)
	}

	t.Policer[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetStatisticsMode retrieves the value of the leaf StatisticsMode from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsMode is set, it can
// safely use t.GetStatisticsMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) GetStatisticsMode() E_SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_StatisticsMode {
	if t == nil || t.StatisticsMode == 0 {
		return SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_StatisticsMode_violating_focus
	}
	return t.StatisticsMode
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.StatisticsMode == 0 {
		t.StatisticsMode = SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_StatisticsMode_violating_focus
	}
	for _, e := range t.Policer {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer represents the /srl_nokia-qos/qos/policer-templates/policer-template/policer YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer struct {
	CommittedBurstSize *uint32                                                                                                                                                         `path:"committed-burst-size" module:"srl_nokia-qos"`
	CommittedRateKbps  *uint32                                                                                                                                                         `path:"committed-rate-kbps" module:"srl_nokia-qos"`
	ExceedAction       *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction                                                                                          `path:"exceed-action" module:"srl_nokia-qos"`
	ForwardingClass    map[SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass `path:"forwarding-class" module:"srl_nokia-qos"`
	MaximumBurstSize   *uint32                                                                                                                                                         `path:"maximum-burst-size" module:"srl_nokia-qos"`
	PeakRateKbps       *uint32                                                                                                                                                         `path:"peak-rate-kbps" module:"srl_nokia-qos"`
	SequenceId         *uint32                                                                                                                                                         `path:"sequence-id" module:"srl_nokia-qos"`
	ViolateAction      *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction                                                                                         `path:"violate-action" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) IsYANGGoStruct() {}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) NewForwardingClass(
	Fc SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union,
) (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass)
	}

	key := Fc

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass{
		Fc: Fc,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) RenameForwardingClass(
	oldK, newK SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union,
) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Fc = newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetOrCreateForwardingClass(
	Fc SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union,
) *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass {
	key := Fc

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Fc)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetForwardingClass(
	Fc SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union,
) *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass {
	if t == nil {
		return nil
	}

	key := Fc

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingClass deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) DeleteForwardingClass(
	Fc SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union,
) {
	key := Fc

	delete(t.ForwardingClass, key)
}

// AppendForwardingClass appends the supplied SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass struct to the
// list ForwardingClass of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) AppendForwardingClass(
	v *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass,
) error {
	key := v.Fc

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union]*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// GetOrCreateExceedAction retrieves the value of the ExceedAction field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetOrCreateExceedAction() *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction {
	if t.ExceedAction != nil {
		return t.ExceedAction
	}
	t.ExceedAction = &SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction{}
	return t.ExceedAction
}

// GetOrCreateViolateAction retrieves the value of the ViolateAction field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetOrCreateViolateAction() *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction {
	if t.ViolateAction != nil {
		return t.ViolateAction
	}
	t.ViolateAction = &SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction{}
	return t.ViolateAction
}

// GetExceedAction returns the value of the ExceedAction struct pointer
// from SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer. If the receiver or the field ExceedAction is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetExceedAction() *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction {
	if t != nil && t.ExceedAction != nil {
		return t.ExceedAction
	}
	return nil
}

// GetViolateAction returns the value of the ViolateAction struct pointer
// from SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer. If the receiver or the field ViolateAction is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetViolateAction() *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction {
	if t != nil && t.ViolateAction != nil {
		return t.ViolateAction
	}
	return nil
}

// GetCommittedBurstSize retrieves the value of the leaf CommittedBurstSize from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommittedBurstSize is set, it can
// safely use t.GetCommittedBurstSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommittedBurstSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetCommittedBurstSize() uint32 {
	if t == nil || t.CommittedBurstSize == nil {
		return 0
	}
	return *t.CommittedBurstSize
}

// GetCommittedRateKbps retrieves the value of the leaf CommittedRateKbps from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommittedRateKbps is set, it can
// safely use t.GetCommittedRateKbps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommittedRateKbps == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetCommittedRateKbps() uint32 {
	if t == nil || t.CommittedRateKbps == nil {
		return 0
	}
	return *t.CommittedRateKbps
}

// GetMaximumBurstSize retrieves the value of the leaf MaximumBurstSize from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumBurstSize is set, it can
// safely use t.GetMaximumBurstSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumBurstSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetMaximumBurstSize() uint32 {
	if t == nil || t.MaximumBurstSize == nil {
		return 0
	}
	return *t.MaximumBurstSize
}

// GetPeakRateKbps retrieves the value of the leaf PeakRateKbps from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRateKbps is set, it can
// safely use t.GetPeakRateKbps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRateKbps == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetPeakRateKbps() uint32 {
	if t == nil || t.PeakRateKbps == nil {
		return 0
	}
	return *t.PeakRateKbps
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ExceedAction.PopulateDefaults()
	t.ViolateAction.PopulateDefaults()
	for _, e := range t.ForwardingClass {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction represents the /srl_nokia-qos/qos/policer-templates/policer-template/policer/exceed-action YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction struct {
	DropProbability E_SrlNokiaQosPolicers_DropProbabilityLevel `path:"drop-probability" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) IsYANGGoStruct() {}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) GetDropProbability() E_SrlNokiaQosPolicers_DropProbabilityLevel {
	if t == nil || t.DropProbability == 0 {
		return SrlNokiaQosPolicers_DropProbabilityLevel_medium
	}
	return t.DropProbability
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DropProbability == 0 {
		t.DropProbability = SrlNokiaQosPolicers_DropProbabilityLevel_medium
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ExceedAction) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass represents the /srl_nokia-qos/qos/policer-templates/policer-template/policer/forwarding-class YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass struct {
	Fc             SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union `path:"fc" module:"srl_nokia-qos"`
	ForwardingType []E_SrlNokiaQosPolicers_ForwardingType                                            `path:"forwarding-type" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) IsYANGGoStruct() {}

// GetFc retrieves the value of the leaf Fc from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fc is set, it can
// safely use t.GetFc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fc == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) GetFc() SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass_Fc_Union {
	if t == nil || t.Fc == nil {
		return nil
	}
	return t.Fc
}

// GetForwardingType retrieves the value of the leaf ForwardingType from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingType is set, it can
// safely use t.GetForwardingType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingType == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) GetForwardingType() []E_SrlNokiaQosPolicers_ForwardingType {
	if t == nil || t.ForwardingType == nil {
		return nil
	}
	return t.ForwardingType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"fc": t.Fc,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ForwardingClass) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction represents the /srl_nokia-qos/qos/policer-templates/policer-template/policer/violate-action YANG schema element.
type SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction struct {
	Drop            YANGEmpty                                  `path:"drop" module:"srl_nokia-qos"`
	DropProbability E_SrlNokiaQosPolicers_DropProbabilityLevel `path:"drop-probability" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) IsYANGGoStruct() {}

// GetDrop retrieves the value of the leaf Drop from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Drop is set, it can
// safely use t.GetDrop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Drop == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) GetDrop() YANGEmpty {
	if t == nil || t.Drop == false {
		return false
	}
	return t.Drop
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) GetDropProbability() E_SrlNokiaQosPolicers_DropProbabilityLevel {
	if t == nil || t.DropProbability == 0 {
		return SrlNokiaQosPolicers_DropProbabilityLevel_high
	}
	return t.DropProbability
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DropProbability == 0 {
		t.DropProbability = SrlNokiaQosPolicers_DropProbabilityLevel_high
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction.
func (*SrlNokiaQos_Qos_PolicerTemplates_PolicerTemplate_Policer_ViolateAction) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Policers represents the /srl_nokia-qos/qos/policers YANG schema element.
type SrlNokiaQos_Qos_Policers struct {
	Policer map[string]*SrlNokiaQos_Qos_Policers_Policer `path:"policer" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Policers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Policers) IsYANGGoStruct() {}

// NewPolicer creates a new entry in the Policer list of the
// SrlNokiaQos_Qos_Policers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Policers) NewPolicer(Name string) (*SrlNokiaQos_Qos_Policers_Policer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[string]*SrlNokiaQos_Qos_Policers_Policer)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policer", key)
	}

	t.Policer[key] = &SrlNokiaQos_Qos_Policers_Policer{
		Name: &Name,
	}

	return t.Policer[key], nil
}

// RenamePolicer renames an entry in the list Policer within
// the SrlNokiaQos_Qos_Policers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Policers) RenamePolicer(oldK, newK string) error {
	if _, ok := t.Policer[newK]; ok {
		return fmt.Errorf("key %v already exists in Policer", newK)
	}

	e, ok := t.Policer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policer", oldK)
	}
	e.Name = &newK

	t.Policer[newK] = e
	delete(t.Policer, oldK)
	return nil
}

// GetOrCreatePolicer retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Policers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Policers) GetOrCreatePolicer(Name string) *SrlNokiaQos_Qos_Policers_Policer {
	key := Name

	if v, ok := t.Policer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicer(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicer got unexpected error: %v", err))
	}
	return v
}

// GetPolicer retrieves the value with the specified key from
// the Policer map field of SrlNokiaQos_Qos_Policers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Policers) GetPolicer(Name string) *SrlNokiaQos_Qos_Policers_Policer {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Policer[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicer deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Policers. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Policers) DeletePolicer(Name string) {
	key := Name

	delete(t.Policer, key)
}

// AppendPolicer appends the supplied SrlNokiaQos_Qos_Policers_Policer struct to the
// list Policer of SrlNokiaQos_Qos_Policers. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Policers_Policer already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Policers) AppendPolicer(v *SrlNokiaQos_Qos_Policers_Policer) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[string]*SrlNokiaQos_Qos_Policers_Policer)
	}

	if _, ok := t.Policer[key]; ok {
		return fmt.Errorf("duplicate key for list Policer %v", key)
	}

	t.Policer[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Policers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Policers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Policer {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Policers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Policers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Policers) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Policers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Policers.
func (*SrlNokiaQos_Qos_Policers) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Policers_Policer represents the /srl_nokia-qos/qos/policers/policer YANG schema element.
type SrlNokiaQos_Qos_Policers_Policer struct {
	Name      *string `path:"name" module:"srl_nokia-qos"`
	PolicerId *uint8  `path:"policer-id" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Policers_Policer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Policers_Policer) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Policers_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Policers_Policer) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPolicerId retrieves the value of the leaf PolicerId from the SrlNokiaQos_Qos_Policers_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicerId is set, it can
// safely use t.GetPolicerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicerId == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Policers_Policer) GetPolicerId() uint8 {
	if t == nil || t.PolicerId == nil {
		return 0
	}
	return *t.PolicerId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Policers_Policer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Policers_Policer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Policers_Policer struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Policers_Policer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Policers_Policer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Policers_Policer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Policers_Policer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Policers_Policer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Policers_Policer.
func (*SrlNokiaQos_Qos_Policers_Policer) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates represents the /srl_nokia-qos/qos/queue-templates YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates struct {
	QueueTemplate map[string]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate `path:"queue-template" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates) IsYANGGoStruct() {}

// NewQueueTemplate creates a new entry in the QueueTemplate list of the
// SrlNokiaQos_Qos_QueueTemplates struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_QueueTemplates) NewQueueTemplate(Name string) (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.QueueTemplate == nil {
		t.QueueTemplate = make(map[string]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.QueueTemplate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list QueueTemplate", key)
	}

	t.QueueTemplate[key] = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate{
		Name: &Name,
	}

	return t.QueueTemplate[key], nil
}

// RenameQueueTemplate renames an entry in the list QueueTemplate within
// the SrlNokiaQos_Qos_QueueTemplates struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_QueueTemplates) RenameQueueTemplate(oldK, newK string) error {
	if _, ok := t.QueueTemplate[newK]; ok {
		return fmt.Errorf("key %v already exists in QueueTemplate", newK)
	}

	e, ok := t.QueueTemplate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in QueueTemplate", oldK)
	}
	e.Name = &newK

	t.QueueTemplate[newK] = e
	delete(t.QueueTemplate, oldK)
	return nil
}

// GetOrCreateQueueTemplate retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_QueueTemplates) GetOrCreateQueueTemplate(Name string) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate {
	key := Name

	if v, ok := t.QueueTemplate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueueTemplate(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueueTemplate got unexpected error: %v", err))
	}
	return v
}

// GetQueueTemplate retrieves the value with the specified key from
// the QueueTemplate map field of SrlNokiaQos_Qos_QueueTemplates. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates) GetQueueTemplate(Name string) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.QueueTemplate[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueueTemplate deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_QueueTemplates) DeleteQueueTemplate(Name string) {
	key := Name

	delete(t.QueueTemplate, key)
}

// AppendQueueTemplate appends the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate struct to the
// list QueueTemplate of SrlNokiaQos_Qos_QueueTemplates. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_QueueTemplates) AppendQueueTemplate(v *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.QueueTemplate == nil {
		t.QueueTemplate = make(map[string]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate)
	}

	if _, ok := t.QueueTemplate[key]; ok {
		return fmt.Errorf("duplicate key for list QueueTemplate %v", key)
	}

	t.QueueTemplate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.QueueTemplate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates.
func (*SrlNokiaQos_Qos_QueueTemplates) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate represents the /srl_nokia-qos/qos/queue-templates/queue-template YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate struct {
	ActiveQueueManagement *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement `path:"active-queue-management" module:"srl_nokia-qos" yangPresence:"true"`
	Name                  *string                                                             `path:"name" module:"srl_nokia-qos"`
	QueueDepth            *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth            `path:"queue-depth" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) IsYANGGoStruct() {}

// GetOrCreateActiveQueueManagement retrieves the value of the ActiveQueueManagement field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetOrCreateActiveQueueManagement() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement {
	if t.ActiveQueueManagement != nil {
		return t.ActiveQueueManagement
	}
	t.ActiveQueueManagement = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement{}
	return t.ActiveQueueManagement
}

// GetOrCreateQueueDepth retrieves the value of the QueueDepth field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetOrCreateQueueDepth() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth {
	if t.QueueDepth != nil {
		return t.QueueDepth
	}
	t.QueueDepth = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth{}
	return t.QueueDepth
}

// GetActiveQueueManagement returns the value of the ActiveQueueManagement struct pointer
// from SrlNokiaQos_Qos_QueueTemplates_QueueTemplate. If the receiver or the field ActiveQueueManagement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetActiveQueueManagement() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement {
	if t != nil && t.ActiveQueueManagement != nil {
		return t.ActiveQueueManagement
	}
	return nil
}

// GetQueueDepth returns the value of the QueueDepth struct pointer
// from SrlNokiaQos_Qos_QueueTemplates_QueueTemplate. If the receiver or the field QueueDepth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetQueueDepth() *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth {
	if t != nil && t.QueueDepth != nil {
		return t.QueueDepth
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ActiveQueueManagement.PopulateDefaults()
	t.QueueDepth.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement represents the /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct {
	EcnSlope     map[E_SrlNokiaQos_EcnDropProbability]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope                                                  `path:"ecn-slope" module:"srl_nokia-qos"`
	WeightFactor *uint8                                                                                                                                                             `path:"weight-factor" module:"srl_nokia-qos"`
	WredSlope    map[SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope `path:"wred-slope" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) IsYANGGoStruct() {}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key represents the key for list WredSlope of element /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key struct {
	TrafficType     E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType `path:"traffic-type"`
	DropProbability E_SrlNokiaQos_DropProbability                                                              `path:"drop-probability"`
}

// NewEcnSlope creates a new entry in the EcnSlope list of the
// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) NewEcnSlope(
	EcnDropProbability E_SrlNokiaQos_EcnDropProbability,
) (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EcnSlope == nil {
		t.EcnSlope = make(map[E_SrlNokiaQos_EcnDropProbability]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope)
	}

	key := EcnDropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EcnSlope[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EcnSlope", key)
	}

	t.EcnSlope[key] = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope{
		EcnDropProbability: EcnDropProbability,
	}

	return t.EcnSlope[key], nil
}

// RenameEcnSlope renames an entry in the list EcnSlope within
// the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) RenameEcnSlope(oldK, newK E_SrlNokiaQos_EcnDropProbability) error {
	if _, ok := t.EcnSlope[newK]; ok {
		return fmt.Errorf("key %v already exists in EcnSlope", newK)
	}

	e, ok := t.EcnSlope[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EcnSlope", oldK)
	}
	e.EcnDropProbability = newK

	t.EcnSlope[newK] = e
	delete(t.EcnSlope, oldK)
	return nil
}

// GetOrCreateEcnSlope retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetOrCreateEcnSlope(
	EcnDropProbability E_SrlNokiaQos_EcnDropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope {
	key := EcnDropProbability

	if v, ok := t.EcnSlope[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEcnSlope(EcnDropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEcnSlope got unexpected error: %v", err))
	}
	return v
}

// GetEcnSlope retrieves the value with the specified key from
// the EcnSlope map field of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetEcnSlope(
	EcnDropProbability E_SrlNokiaQos_EcnDropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope {
	if t == nil {
		return nil
	}

	key := EcnDropProbability

	if lm, ok := t.EcnSlope[key]; ok {
		return lm
	}
	return nil
}

// DeleteEcnSlope deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) DeleteEcnSlope(EcnDropProbability E_SrlNokiaQos_EcnDropProbability) {
	key := EcnDropProbability

	delete(t.EcnSlope, key)
}

// AppendEcnSlope appends the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope struct to the
// list EcnSlope of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) AppendEcnSlope(
	v *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope,
) error {
	key := v.EcnDropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EcnSlope == nil {
		t.EcnSlope = make(map[E_SrlNokiaQos_EcnDropProbability]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope)
	}

	if _, ok := t.EcnSlope[key]; ok {
		return fmt.Errorf("duplicate key for list EcnSlope %v", key)
	}

	t.EcnSlope[key] = v
	return nil
}

// NewWredSlope creates a new entry in the WredSlope list of the
// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) NewWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType,
	DropProbability E_SrlNokiaQos_DropProbability,
) (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WredSlope == nil {
		t.WredSlope = make(map[SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope)
	}

	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.WredSlope[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list WredSlope", key)
	}

	t.WredSlope[key] = &SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	return t.WredSlope[key], nil
}

// RenameWredSlope renames an entry in the list WredSlope within
// the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) RenameWredSlope(
	oldK, newK SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key,
) error {
	if _, ok := t.WredSlope[newK]; ok {
		return fmt.Errorf("key %v already exists in WredSlope", newK)
	}

	e, ok := t.WredSlope[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in WredSlope", oldK)
	}
	e.TrafficType = newK.TrafficType
	e.DropProbability = newK.DropProbability

	t.WredSlope[newK] = e
	delete(t.WredSlope, oldK)
	return nil
}

// GetOrCreateWredSlope retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetOrCreateWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType,
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope {
	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	if v, ok := t.WredSlope[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewWredSlope(TrafficType, DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateWredSlope got unexpected error: %v", err))
	}
	return v
}

// GetWredSlope retrieves the value with the specified key from
// the WredSlope map field of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType,
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope {
	if t == nil {
		return nil
	}

	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	if lm, ok := t.WredSlope[key]; ok {
		return lm
	}
	return nil
}

// DeleteWredSlope deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) DeleteWredSlope(
	TrafficType E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType, DropProbability E_SrlNokiaQos_DropProbability,
) {
	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     TrafficType,
		DropProbability: DropProbability,
	}

	delete(t.WredSlope, key)
}

// AppendWredSlope appends the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope struct to the
// list WredSlope of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) AppendWredSlope(
	v *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope,
) error {
	key := SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key{
		TrafficType:     v.TrafficType,
		DropProbability: v.DropProbability,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WredSlope == nil {
		t.WredSlope = make(map[SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_Key]*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope)
	}

	if _, ok := t.WredSlope[key]; ok {
		return fmt.Errorf("duplicate key for list WredSlope %v", key)
	}

	t.WredSlope[key] = v
	return nil
}

// GetWeightFactor retrieves the value of the leaf WeightFactor from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WeightFactor is set, it can
// safely use t.GetWeightFactor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WeightFactor == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) GetWeightFactor() uint8 {
	if t == nil || t.WeightFactor == nil {
		return 0
	}
	return *t.WeightFactor
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.WeightFactor == nil {
		var v uint8 = 0
		t.WeightFactor = &v
	}
	for _, e := range t.EcnSlope {
		e.PopulateDefaults()
	}
	for _, e := range t.WredSlope {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope represents the /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management/ecn-slope YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope struct {
	EcnDropProbability  E_SrlNokiaQos_EcnDropProbability `path:"ecn-drop-probability" module:"srl_nokia-qos"`
	MaxProbability      *uint8                           `path:"max-probability" module:"srl_nokia-qos"`
	MaxThresholdPercent *uint8                           `path:"max-threshold-percent" module:"srl_nokia-qos"`
	MinThresholdPercent *uint8                           `path:"min-threshold-percent" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) IsYANGGoStruct() {
}

// GetEcnDropProbability retrieves the value of the leaf EcnDropProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EcnDropProbability is set, it can
// safely use t.GetEcnDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EcnDropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetEcnDropProbability() E_SrlNokiaQos_EcnDropProbability {
	if t == nil || t.EcnDropProbability == 0 {
		return 0
	}
	return t.EcnDropProbability
}

// GetMaxProbability retrieves the value of the leaf MaxProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxProbability is set, it can
// safely use t.GetMaxProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetMaxProbability() uint8 {
	if t == nil || t.MaxProbability == nil {
		return 0
	}
	return *t.MaxProbability
}

// GetMaxThresholdPercent retrieves the value of the leaf MaxThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThresholdPercent is set, it can
// safely use t.GetMaxThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetMaxThresholdPercent() uint8 {
	if t == nil || t.MaxThresholdPercent == nil {
		return 100
	}
	return *t.MaxThresholdPercent
}

// GetMinThresholdPercent retrieves the value of the leaf MinThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinThresholdPercent is set, it can
// safely use t.GetMinThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) GetMinThresholdPercent() uint8 {
	if t == nil || t.MinThresholdPercent == nil {
		return 100
	}
	return *t.MinThresholdPercent
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaxProbability == nil {
		var v uint8 = 0
		t.MaxProbability = &v
	}
	if t.MaxThresholdPercent == nil {
		var v uint8 = 100
		t.MaxThresholdPercent = &v
	}
	if t.MinThresholdPercent == nil {
		var v uint8 = 100
		t.MinThresholdPercent = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"ecn-drop-probability": t.EcnDropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_EcnSlope) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope represents the /srl_nokia-qos/qos/queue-templates/queue-template/active-queue-management/wred-slope YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope struct {
	DropProbability     E_SrlNokiaQos_DropProbability                                                              `path:"drop-probability" module:"srl_nokia-qos"`
	MaxProbability      *uint8                                                                                     `path:"max-probability" module:"srl_nokia-qos"`
	MaxThresholdPercent *uint8                                                                                     `path:"max-threshold-percent" module:"srl_nokia-qos"`
	MinThresholdPercent *uint8                                                                                     `path:"min-threshold-percent" module:"srl_nokia-qos"`
	TrafficType         E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType `path:"traffic-type" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) IsYANGGoStruct() {
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetDropProbability() E_SrlNokiaQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetMaxProbability retrieves the value of the leaf MaxProbability from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxProbability is set, it can
// safely use t.GetMaxProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetMaxProbability() uint8 {
	if t == nil || t.MaxProbability == nil {
		return 0
	}
	return *t.MaxProbability
}

// GetMaxThresholdPercent retrieves the value of the leaf MaxThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThresholdPercent is set, it can
// safely use t.GetMaxThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetMaxThresholdPercent() uint8 {
	if t == nil || t.MaxThresholdPercent == nil {
		return 100
	}
	return *t.MaxThresholdPercent
}

// GetMinThresholdPercent retrieves the value of the leaf MinThresholdPercent from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinThresholdPercent is set, it can
// safely use t.GetMinThresholdPercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinThresholdPercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetMinThresholdPercent() uint8 {
	if t == nil || t.MinThresholdPercent == nil {
		return 100
	}
	return *t.MinThresholdPercent
}

// GetTrafficType retrieves the value of the leaf TrafficType from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficType is set, it can
// safely use t.GetTrafficType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficType == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) GetTrafficType() E_SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope_TrafficType {
	if t == nil || t.TrafficType == 0 {
		return 0
	}
	return t.TrafficType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaxProbability == nil {
		var v uint8 = 0
		t.MaxProbability = &v
	}
	if t.MaxThresholdPercent == nil {
		var v uint8 = 100
		t.MaxThresholdPercent = &v
	}
	if t.MinThresholdPercent == nil {
		var v uint8 = 100
		t.MinThresholdPercent = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
		"traffic-type":     t.TrafficType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_ActiveQueueManagement_WredSlope) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth represents the /srl_nokia-qos/qos/queue-templates/queue-template/queue-depth YANG schema element.
type SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth struct {
	HighThresholdBytes *uint32 `path:"high-threshold-bytes" module:"srl_nokia-qos"`
	MaximumBurstSize   *uint32 `path:"maximum-burst-size" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) IsYANGGoStruct() {}

// GetHighThresholdBytes retrieves the value of the leaf HighThresholdBytes from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighThresholdBytes is set, it can
// safely use t.GetHighThresholdBytes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighThresholdBytes == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) GetHighThresholdBytes() uint32 {
	if t == nil || t.HighThresholdBytes == nil {
		return 0
	}
	return *t.HighThresholdBytes
}

// GetMaximumBurstSize retrieves the value of the leaf MaximumBurstSize from the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumBurstSize is set, it can
// safely use t.GetMaximumBurstSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumBurstSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) GetMaximumBurstSize() uint32 {
	if t == nil || t.MaximumBurstSize == nil {
		return 0
	}
	return *t.MaximumBurstSize
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.HighThresholdBytes == nil {
		var v uint32 = 0
		t.HighThresholdBytes = &v
	}
	if t.MaximumBurstSize == nil {
		var v uint32 = 0
		t.MaximumBurstSize = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth.
func (*SrlNokiaQos_Qos_QueueTemplates_QueueTemplate_QueueDepth) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Queues represents the /srl_nokia-qos/qos/queues YANG schema element.
type SrlNokiaQos_Qos_Queues struct {
	Queue map[string]*SrlNokiaQos_Qos_Queues_Queue `path:"queue" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Queues implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Queues) IsYANGGoStruct() {}

// NewQueue creates a new entry in the Queue list of the
// SrlNokiaQos_Qos_Queues struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Queues) NewQueue(Name string) (*SrlNokiaQos_Qos_Queues_Queue, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[string]*SrlNokiaQos_Qos_Queues_Queue)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &SrlNokiaQos_Qos_Queues_Queue{
		Name: &Name,
	}

	return t.Queue[key], nil
}

// RenameQueue renames an entry in the list Queue within
// the SrlNokiaQos_Qos_Queues struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_Queues) RenameQueue(oldK, newK string) error {
	if _, ok := t.Queue[newK]; ok {
		return fmt.Errorf("key %v already exists in Queue", newK)
	}

	e, ok := t.Queue[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Queue", oldK)
	}
	e.Name = &newK

	t.Queue[newK] = e
	delete(t.Queue, oldK)
	return nil
}

// GetOrCreateQueue retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Queues. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_Queues) GetOrCreateQueue(Name string) *SrlNokiaQos_Qos_Queues_Queue {
	key := Name

	if v, ok := t.Queue[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueue(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueue got unexpected error: %v", err))
	}
	return v
}

// GetQueue retrieves the value with the specified key from
// the Queue map field of SrlNokiaQos_Qos_Queues. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_Queues) GetQueue(Name string) *SrlNokiaQos_Qos_Queues_Queue {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Queue[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueue deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_Queues. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_Queues) DeleteQueue(Name string) {
	key := Name

	delete(t.Queue, key)
}

// AppendQueue appends the supplied SrlNokiaQos_Qos_Queues_Queue struct to the
// list Queue of SrlNokiaQos_Qos_Queues. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_Queues_Queue already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_Queues) AppendQueue(v *SrlNokiaQos_Qos_Queues_Queue) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[string]*SrlNokiaQos_Qos_Queues_Queue)
	}

	if _, ok := t.Queue[key]; ok {
		return fmt.Errorf("duplicate key for list Queue %v", key)
	}

	t.Queue[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Queues
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Queues) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Queue {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Queues"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Queues) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Queues.
func (*SrlNokiaQos_Qos_Queues) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_Queues_Queue represents the /srl_nokia-qos/qos/queues/queue YANG schema element.
type SrlNokiaQos_Qos_Queues_Queue struct {
	Name       *string `path:"name" module:"srl_nokia-qos"`
	QueueIndex *uint16 `path:"queue-index" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_Queues_Queue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_Queues_Queue) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_Queues_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Queues_Queue) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetQueueIndex retrieves the value of the leaf QueueIndex from the SrlNokiaQos_Qos_Queues_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueueIndex is set, it can
// safely use t.GetQueueIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueueIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_Queues_Queue) GetQueueIndex() uint16 {
	if t == nil || t.QueueIndex == nil {
		return 0
	}
	return *t.QueueIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_Queues_Queue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_Queues_Queue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Queues_Queue struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Queues_Queue) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues_Queue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Queues_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Queues_Queue) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Queues_Queue) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_Queues_Queue.
func (*SrlNokiaQos_Qos_Queues_Queue) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement represents the /srl_nokia-qos/qos/resource-management YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement struct {
	DropLevels         *SrlNokiaQos_Qos_ResourceManagement_DropLevels         `path:"drop-levels" module:"srl_nokia-qos"`
	ResourcePriority   *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority   `path:"resource-priority" module:"srl_nokia-qos"`
	UntilizationLevels *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels `path:"untilization-levels" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement) IsYANGGoStruct() {}

// GetOrCreateDropLevels retrieves the value of the DropLevels field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetOrCreateDropLevels() *SrlNokiaQos_Qos_ResourceManagement_DropLevels {
	if t.DropLevels != nil {
		return t.DropLevels
	}
	t.DropLevels = &SrlNokiaQos_Qos_ResourceManagement_DropLevels{}
	return t.DropLevels
}

// GetOrCreateResourcePriority retrieves the value of the ResourcePriority field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetOrCreateResourcePriority() *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority {
	if t.ResourcePriority != nil {
		return t.ResourcePriority
	}
	t.ResourcePriority = &SrlNokiaQos_Qos_ResourceManagement_ResourcePriority{}
	return t.ResourcePriority
}

// GetOrCreateUntilizationLevels retrieves the value of the UntilizationLevels field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetOrCreateUntilizationLevels() *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels {
	if t.UntilizationLevels != nil {
		return t.UntilizationLevels
	}
	t.UntilizationLevels = &SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels{}
	return t.UntilizationLevels
}

// GetDropLevels returns the value of the DropLevels struct pointer
// from SrlNokiaQos_Qos_ResourceManagement. If the receiver or the field DropLevels is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetDropLevels() *SrlNokiaQos_Qos_ResourceManagement_DropLevels {
	if t != nil && t.DropLevels != nil {
		return t.DropLevels
	}
	return nil
}

// GetResourcePriority returns the value of the ResourcePriority struct pointer
// from SrlNokiaQos_Qos_ResourceManagement. If the receiver or the field ResourcePriority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetResourcePriority() *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority {
	if t != nil && t.ResourcePriority != nil {
		return t.ResourcePriority
	}
	return nil
}

// GetUntilizationLevels returns the value of the UntilizationLevels struct pointer
// from SrlNokiaQos_Qos_ResourceManagement. If the receiver or the field UntilizationLevels is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement) GetUntilizationLevels() *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels {
	if t != nil && t.UntilizationLevels != nil {
		return t.UntilizationLevels
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DropLevels.PopulateDefaults()
	t.ResourcePriority.PopulateDefaults()
	t.UntilizationLevels.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement.
func (*SrlNokiaQos_Qos_ResourceManagement) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_DropLevels represents the /srl_nokia-qos/qos/resource-management/drop-levels YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_DropLevels struct {
	Multicast map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast `path:"multicast" module:"srl_nokia-qos"`
	Unicast   map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast   `path:"unicast" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_DropLevels implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_DropLevels) IsYANGGoStruct() {}

// NewMulticast creates a new entry in the Multicast list of the
// SrlNokiaQos_Qos_ResourceManagement_DropLevels struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) NewMulticast(Index uint8) (*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Multicast == nil {
		t.Multicast = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Multicast[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Multicast", key)
	}

	t.Multicast[key] = &SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast{
		Index: &Index,
	}

	return t.Multicast[key], nil
}

// RenameMulticast renames an entry in the list Multicast within
// the SrlNokiaQos_Qos_ResourceManagement_DropLevels struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) RenameMulticast(oldK, newK uint8) error {
	if _, ok := t.Multicast[newK]; ok {
		return fmt.Errorf("key %v already exists in Multicast", newK)
	}

	e, ok := t.Multicast[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Multicast", oldK)
	}
	e.Index = &newK

	t.Multicast[newK] = e
	delete(t.Multicast, oldK)
	return nil
}

// GetOrCreateMulticast retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropLevels. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) GetOrCreateMulticast(Index uint8) *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast {
	key := Index

	if v, ok := t.Multicast[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMulticast(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMulticast got unexpected error: %v", err))
	}
	return v
}

// GetMulticast retrieves the value with the specified key from
// the Multicast map field of SrlNokiaQos_Qos_ResourceManagement_DropLevels. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) GetMulticast(Index uint8) *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Multicast[key]; ok {
		return lm
	}
	return nil
}

// DeleteMulticast deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropLevels. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) DeleteMulticast(Index uint8) {
	key := Index

	delete(t.Multicast, key)
}

// AppendMulticast appends the supplied SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast struct to the
// list Multicast of SrlNokiaQos_Qos_ResourceManagement_DropLevels. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) AppendMulticast(
	v *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Multicast == nil {
		t.Multicast = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast)
	}

	if _, ok := t.Multicast[key]; ok {
		return fmt.Errorf("duplicate key for list Multicast %v", key)
	}

	t.Multicast[key] = v
	return nil
}

// NewUnicast creates a new entry in the Unicast list of the
// SrlNokiaQos_Qos_ResourceManagement_DropLevels struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) NewUnicast(Index uint8) (*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Unicast == nil {
		t.Unicast = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Unicast[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Unicast", key)
	}

	t.Unicast[key] = &SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast{
		Index: &Index,
	}

	return t.Unicast[key], nil
}

// RenameUnicast renames an entry in the list Unicast within
// the SrlNokiaQos_Qos_ResourceManagement_DropLevels struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) RenameUnicast(oldK, newK uint8) error {
	if _, ok := t.Unicast[newK]; ok {
		return fmt.Errorf("key %v already exists in Unicast", newK)
	}

	e, ok := t.Unicast[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Unicast", oldK)
	}
	e.Index = &newK

	t.Unicast[newK] = e
	delete(t.Unicast, oldK)
	return nil
}

// GetOrCreateUnicast retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropLevels. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) GetOrCreateUnicast(Index uint8) *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast {
	key := Index

	if v, ok := t.Unicast[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnicast(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnicast got unexpected error: %v", err))
	}
	return v
}

// GetUnicast retrieves the value with the specified key from
// the Unicast map field of SrlNokiaQos_Qos_ResourceManagement_DropLevels. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) GetUnicast(Index uint8) *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Unicast[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnicast deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_DropLevels. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) DeleteUnicast(Index uint8) {
	key := Index

	delete(t.Unicast, key)
}

// AppendUnicast appends the supplied SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast struct to the
// list Unicast of SrlNokiaQos_Qos_ResourceManagement_DropLevels. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) AppendUnicast(
	v *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Unicast == nil {
		t.Unicast = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast)
	}

	if _, ok := t.Unicast[key]; ok {
		return fmt.Errorf("duplicate key for list Unicast %v", key)
	}

	t.Unicast[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_DropLevels
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Multicast {
		e.PopulateDefaults()
	}
	for _, e := range t.Unicast {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_DropLevels"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_DropLevels.
func (*SrlNokiaQos_Qos_ResourceManagement_DropLevels) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast represents the /srl_nokia-qos/qos/resource-management/drop-levels/multicast YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast struct {
	Header  *uint8 `path:"header" module:"srl_nokia-qos"`
	Index   *uint8 `path:"index" module:"srl_nokia-qos"`
	Segment *uint8 `path:"segment" module:"srl_nokia-qos"`
	Vpid    *uint8 `path:"vpid" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) IsYANGGoStruct() {}

// GetHeader retrieves the value of the leaf Header from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Header is set, it can
// safely use t.GetHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Header == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) GetHeader() uint8 {
	if t == nil || t.Header == nil {
		return 0
	}
	return *t.Header
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetSegment retrieves the value of the leaf Segment from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Segment is set, it can
// safely use t.GetSegment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Segment == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) GetSegment() uint8 {
	if t == nil || t.Segment == nil {
		return 0
	}
	return *t.Segment
}

// GetVpid retrieves the value of the leaf Vpid from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpid is set, it can
// safely use t.GetVpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpid == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) GetVpid() uint8 {
	if t == nil || t.Vpid == nil {
		return 0
	}
	return *t.Vpid
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast.
func (*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Multicast) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast represents the /srl_nokia-qos/qos/resource-management/drop-levels/unicast YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast struct {
	Header  *uint8 `path:"header" module:"srl_nokia-qos"`
	Index   *uint8 `path:"index" module:"srl_nokia-qos"`
	Segment *uint8 `path:"segment" module:"srl_nokia-qos"`
	Vpid    *uint8 `path:"vpid" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) IsYANGGoStruct() {}

// GetHeader retrieves the value of the leaf Header from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Header is set, it can
// safely use t.GetHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Header == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) GetHeader() uint8 {
	if t == nil || t.Header == nil {
		return 0
	}
	return *t.Header
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetSegment retrieves the value of the leaf Segment from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Segment is set, it can
// safely use t.GetSegment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Segment == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) GetSegment() uint8 {
	if t == nil || t.Segment == nil {
		return 0
	}
	return *t.Segment
}

// GetVpid retrieves the value of the leaf Vpid from the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpid is set, it can
// safely use t.GetVpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpid == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) GetVpid() uint8 {
	if t == nil || t.Vpid == nil {
		return 0
	}
	return *t.Vpid
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast.
func (*SrlNokiaQos_Qos_ResourceManagement_DropLevels_Unicast) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourcePriority represents the /srl_nokia-qos/qos/resource-management/resource-priority YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourcePriority struct {
	ForwardingClass map[SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass `path:"forwarding-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourcePriority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) IsYANGGoStruct() {}

// NewForwardingClass creates a new entry in the ForwardingClass list of the
// SrlNokiaQos_Qos_ResourceManagement_ResourcePriority struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) NewForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union,
) (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingClass", key)
	}

	t.ForwardingClass[key] = &SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass{
		Name: Name,
	}

	return t.ForwardingClass[key], nil
}

// RenameForwardingClass renames an entry in the list ForwardingClass within
// the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) RenameForwardingClass(
	oldK, newK SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union,
) error {
	if _, ok := t.ForwardingClass[newK]; ok {
		return fmt.Errorf("key %v already exists in ForwardingClass", newK)
	}

	e, ok := t.ForwardingClass[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ForwardingClass", oldK)
	}
	e.Name = newK

	t.ForwardingClass[newK] = e
	delete(t.ForwardingClass, oldK)
	return nil
}

// GetOrCreateForwardingClass retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourcePriority. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) GetOrCreateForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union,
) *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass {
	key := Name

	if v, ok := t.ForwardingClass[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewForwardingClass(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateForwardingClass got unexpected error: %v", err))
	}
	return v
}

// GetForwardingClass retrieves the value with the specified key from
// the ForwardingClass map field of SrlNokiaQos_Qos_ResourceManagement_ResourcePriority. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) GetForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union,
) *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ForwardingClass[key]; ok {
		return lm
	}
	return nil
}

// DeleteForwardingClass deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourcePriority. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) DeleteForwardingClass(
	Name SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union,
) {
	key := Name

	delete(t.ForwardingClass, key)
}

// AppendForwardingClass appends the supplied SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass struct to the
// list ForwardingClass of SrlNokiaQos_Qos_ResourceManagement_ResourcePriority. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) AppendForwardingClass(
	v *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass,
) error {
	key := v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingClass == nil {
		t.ForwardingClass = make(map[SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union]*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass)
	}

	if _, ok := t.ForwardingClass[key]; ok {
		return fmt.Errorf("duplicate key for list ForwardingClass %v", key)
	}

	t.ForwardingClass[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ForwardingClass {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourcePriority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourcePriority.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass represents the /srl_nokia-qos/qos/resource-management/resource-priority/forwarding-class YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass struct {
	Name    SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union                                    `path:"name" module:"srl_nokia-qos"`
	Profile map[E_SrlNokiaCommon_ClassifyProfile]*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) IsYANGGoStruct() {}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) NewProfile(
	ProfileName E_SrlNokiaCommon_ClassifyProfile,
) (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_ClassifyProfile]*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile)
	}

	key := ProfileName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile{
		ProfileName: ProfileName,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) RenameProfile(oldK, newK E_SrlNokiaCommon_ClassifyProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.ProfileName = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) GetOrCreateProfile(
	ProfileName E_SrlNokiaCommon_ClassifyProfile,
) *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile {
	key := ProfileName

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(ProfileName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) GetProfile(
	ProfileName E_SrlNokiaCommon_ClassifyProfile,
) *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile {
	if t == nil {
		return nil
	}

	key := ProfileName

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) DeleteProfile(ProfileName E_SrlNokiaCommon_ClassifyProfile) {
	key := ProfileName

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile struct to the
// list Profile of SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) AppendProfile(
	v *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile,
) error {
	key := v.ProfileName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaCommon_ClassifyProfile]*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) GetName() SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Name_Union {
	if t == nil || t.Name == nil {
		return nil
	}
	return t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile represents the /srl_nokia-qos/qos/resource-management/resource-priority/forwarding-class/profile YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile struct {
	MulticastResourcePriority *uint8                           `path:"multicast-resource-priority" module:"srl_nokia-qos"`
	ProfileName               E_SrlNokiaCommon_ClassifyProfile `path:"profile-name" module:"srl_nokia-qos"`
	UnicastResourcePriority   *uint8                           `path:"unicast-resource-priority" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) IsYANGGoStruct() {
}

// GetMulticastResourcePriority retrieves the value of the leaf MulticastResourcePriority from the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastResourcePriority is set, it can
// safely use t.GetMulticastResourcePriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastResourcePriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) GetMulticastResourcePriority() uint8 {
	if t == nil || t.MulticastResourcePriority == nil {
		return 0
	}
	return *t.MulticastResourcePriority
}

// GetProfileName retrieves the value of the leaf ProfileName from the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProfileName is set, it can
// safely use t.GetProfileName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProfileName == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) GetProfileName() E_SrlNokiaCommon_ClassifyProfile {
	if t == nil || t.ProfileName == 0 {
		return 0
	}
	return t.ProfileName
}

// GetUnicastResourcePriority retrieves the value of the leaf UnicastResourcePriority from the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnicastResourcePriority is set, it can
// safely use t.GetUnicastResourcePriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnicastResourcePriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) GetUnicastResourcePriority() uint8 {
	if t == nil || t.UnicastResourcePriority == nil {
		return 0
	}
	return *t.UnicastResourcePriority
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile-name": t.ProfileName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile.
func (*SrlNokiaQos_Qos_ResourceManagement_ResourcePriority_ForwardingClass_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels represents the /srl_nokia-qos/qos/resource-management/untilization-levels YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels struct {
	SegmentCongestion *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion `path:"segment-congestion" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) IsYANGGoStruct() {}

// GetOrCreateSegmentCongestion retrieves the value of the SegmentCongestion field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) GetOrCreateSegmentCongestion() *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion {
	if t.SegmentCongestion != nil {
		return t.SegmentCongestion
	}
	t.SegmentCongestion = &SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion{}
	return t.SegmentCongestion
}

// GetSegmentCongestion returns the value of the SegmentCongestion struct pointer
// from SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels. If the receiver or the field SegmentCongestion is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) GetSegmentCongestion() *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion {
	if t != nil && t.SegmentCongestion != nil {
		return t.SegmentCongestion
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SegmentCongestion.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels.
func (*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion represents the /srl_nokia-qos/qos/resource-management/untilization-levels/segment-congestion YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion struct {
	Level map[uint8]*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level `path:"level" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) IsYANGGoStruct() {}

// NewLevel creates a new entry in the Level list of the
// SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) NewLevel(
	Index uint8,
) (*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Level[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Level", key)
	}

	t.Level[key] = &SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level{
		Index: &Index,
	}

	return t.Level[key], nil
}

// RenameLevel renames an entry in the list Level within
// the SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) RenameLevel(oldK, newK uint8) error {
	if _, ok := t.Level[newK]; ok {
		return fmt.Errorf("key %v already exists in Level", newK)
	}

	e, ok := t.Level[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Level", oldK)
	}
	e.Index = &newK

	t.Level[newK] = e
	delete(t.Level, oldK)
	return nil
}

// GetOrCreateLevel retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) GetOrCreateLevel(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level {
	key := Index

	if v, ok := t.Level[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLevel(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLevel got unexpected error: %v", err))
	}
	return v
}

// GetLevel retrieves the value with the specified key from
// the Level map field of SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) GetLevel(
	Index uint8,
) *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Level[key]; ok {
		return lm
	}
	return nil
}

// DeleteLevel deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) DeleteLevel(Index uint8) {
	key := Index

	delete(t.Level, key)
}

// AppendLevel appends the supplied SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level struct to the
// list Level of SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) AppendLevel(
	v *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Level == nil {
		t.Level = make(map[uint8]*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level)
	}

	if _, ok := t.Level[key]; ok {
		return fmt.Errorf("duplicate key for list Level %v", key)
	}

	t.Level[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Level {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion.
func (*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level represents the /srl_nokia-qos/qos/resource-management/untilization-levels/segment-congestion/level YANG schema element.
type SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level struct {
	Index     *uint8 `path:"index" module:"srl_nokia-qos"`
	Threshold *uint8 `path:"threshold" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) IsYANGGoStruct() {
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetThreshold retrieves the value of the leaf Threshold from the SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Threshold is set, it can
// safely use t.GetThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Threshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) GetThreshold() uint8 {
	if t == nil || t.Threshold == nil {
		return 0
	}
	return *t.Threshold
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level.
func (*SrlNokiaQos_Qos_ResourceManagement_UntilizationLevels_SegmentCongestion_Level) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules represents the /srl_nokia-qos/qos/rewrite-rules YANG schema element.
type SrlNokiaQos_Qos_RewriteRules struct {
	Dot1PPolicy            map[string]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy            `path:"dot1p-policy" module:"srl_nokia-qos"`
	DscpPolicy             map[string]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy             `path:"dscp-policy" module:"srl_nokia-qos"`
	IpRemarkPolicy         map[string]*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy         `path:"ip-remark-policy" module:"srl_nokia-qos"`
	MplsTrafficClassPolicy map[string]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy `path:"mpls-traffic-class-policy" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules) IsYANGGoStruct() {}

// NewDot1PPolicy creates a new entry in the Dot1PPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewDot1PPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1PPolicy == nil {
		t.Dot1PPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dot1PPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dot1PPolicy", key)
	}

	t.Dot1PPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy{
		Name: &Name,
	}

	return t.Dot1PPolicy[key], nil
}

// RenameDot1PPolicy renames an entry in the list Dot1PPolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameDot1PPolicy(oldK, newK string) error {
	if _, ok := t.Dot1PPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in Dot1PPolicy", newK)
	}

	e, ok := t.Dot1PPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dot1PPolicy", oldK)
	}
	e.Name = &newK

	t.Dot1PPolicy[newK] = e
	delete(t.Dot1PPolicy, oldK)
	return nil
}

// GetOrCreateDot1PPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateDot1PPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy {
	key := Name

	if v, ok := t.Dot1PPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDot1PPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDot1PPolicy got unexpected error: %v", err))
	}
	return v
}

// GetDot1PPolicy retrieves the value with the specified key from
// the Dot1PPolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetDot1PPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Dot1PPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteDot1PPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteDot1PPolicy(Name string) {
	key := Name

	delete(t.Dot1PPolicy, key)
}

// AppendDot1PPolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct to the
// list Dot1PPolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendDot1PPolicy(v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dot1PPolicy == nil {
		t.Dot1PPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy)
	}

	if _, ok := t.Dot1PPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list Dot1PPolicy %v", key)
	}

	t.Dot1PPolicy[key] = v
	return nil
}

// NewDscpPolicy creates a new entry in the DscpPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewDscpPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DscpPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DscpPolicy", key)
	}

	t.DscpPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy{
		Name: &Name,
	}

	return t.DscpPolicy[key], nil
}

// RenameDscpPolicy renames an entry in the list DscpPolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameDscpPolicy(oldK, newK string) error {
	if _, ok := t.DscpPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in DscpPolicy", newK)
	}

	e, ok := t.DscpPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DscpPolicy", oldK)
	}
	e.Name = &newK

	t.DscpPolicy[newK] = e
	delete(t.DscpPolicy, oldK)
	return nil
}

// GetOrCreateDscpPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateDscpPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy {
	key := Name

	if v, ok := t.DscpPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDscpPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDscpPolicy got unexpected error: %v", err))
	}
	return v
}

// GetDscpPolicy retrieves the value with the specified key from
// the DscpPolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetDscpPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.DscpPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteDscpPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteDscpPolicy(Name string) {
	key := Name

	delete(t.DscpPolicy, key)
}

// AppendDscpPolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct to the
// list DscpPolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendDscpPolicy(v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy)
	}

	if _, ok := t.DscpPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list DscpPolicy %v", key)
	}

	t.DscpPolicy[key] = v
	return nil
}

// NewIpRemarkPolicy creates a new entry in the IpRemarkPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewIpRemarkPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpRemarkPolicy == nil {
		t.IpRemarkPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IpRemarkPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IpRemarkPolicy", key)
	}

	t.IpRemarkPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy{
		Name: &Name,
	}

	return t.IpRemarkPolicy[key], nil
}

// RenameIpRemarkPolicy renames an entry in the list IpRemarkPolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameIpRemarkPolicy(oldK, newK string) error {
	if _, ok := t.IpRemarkPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in IpRemarkPolicy", newK)
	}

	e, ok := t.IpRemarkPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IpRemarkPolicy", oldK)
	}
	e.Name = &newK

	t.IpRemarkPolicy[newK] = e
	delete(t.IpRemarkPolicy, oldK)
	return nil
}

// GetOrCreateIpRemarkPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateIpRemarkPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy {
	key := Name

	if v, ok := t.IpRemarkPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpRemarkPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpRemarkPolicy got unexpected error: %v", err))
	}
	return v
}

// GetIpRemarkPolicy retrieves the value with the specified key from
// the IpRemarkPolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetIpRemarkPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.IpRemarkPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpRemarkPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteIpRemarkPolicy(Name string) {
	key := Name

	delete(t.IpRemarkPolicy, key)
}

// AppendIpRemarkPolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy struct to the
// list IpRemarkPolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendIpRemarkPolicy(v *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpRemarkPolicy == nil {
		t.IpRemarkPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy)
	}

	if _, ok := t.IpRemarkPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list IpRemarkPolicy %v", key)
	}

	t.IpRemarkPolicy[key] = v
	return nil
}

// NewMplsTrafficClassPolicy creates a new entry in the MplsTrafficClassPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewMplsTrafficClassPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MplsTrafficClassPolicy", key)
	}

	t.MplsTrafficClassPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy{
		Name: &Name,
	}

	return t.MplsTrafficClassPolicy[key], nil
}

// RenameMplsTrafficClassPolicy renames an entry in the list MplsTrafficClassPolicy within
// the SrlNokiaQos_Qos_RewriteRules struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules) RenameMplsTrafficClassPolicy(oldK, newK string) error {
	if _, ok := t.MplsTrafficClassPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in MplsTrafficClassPolicy", newK)
	}

	e, ok := t.MplsTrafficClassPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MplsTrafficClassPolicy", oldK)
	}
	e.Name = &newK

	t.MplsTrafficClassPolicy[newK] = e
	delete(t.MplsTrafficClassPolicy, oldK)
	return nil
}

// GetOrCreateMplsTrafficClassPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules) GetOrCreateMplsTrafficClassPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy {
	key := Name

	if v, ok := t.MplsTrafficClassPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMplsTrafficClassPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMplsTrafficClassPolicy got unexpected error: %v", err))
	}
	return v
}

// GetMplsTrafficClassPolicy retrieves the value with the specified key from
// the MplsTrafficClassPolicy map field of SrlNokiaQos_Qos_RewriteRules. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules) GetMplsTrafficClassPolicy(Name string) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.MplsTrafficClassPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteMplsTrafficClassPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules) DeleteMplsTrafficClassPolicy(Name string) {
	key := Name

	delete(t.MplsTrafficClassPolicy, key)
}

// AppendMplsTrafficClassPolicy appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct to the
// list MplsTrafficClassPolicy of SrlNokiaQos_Qos_RewriteRules. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules) AppendMplsTrafficClassPolicy(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy)
	}

	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list MplsTrafficClassPolicy %v", key)
	}

	t.MplsTrafficClassPolicy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Dot1PPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.DscpPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.IpRemarkPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.MplsTrafficClassPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules.
func (*SrlNokiaQos_Qos_RewriteRules) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct {
	Map  map[SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map `path:"map" module:"srl_nokia-qos"`
	Name *string                                                                                                              `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) IsYANGGoStruct() {}

// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) NewMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// RenameMap renames an entry in the list Map within
// the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) RenameMap(
	oldK, newK SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union,
) error {
	if _, ok := t.Map[newK]; ok {
		return fmt.Errorf("key %v already exists in Map", newK)
	}

	e, ok := t.Map[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Map", oldK)
	}
	e.ForwardingClass = newK

	t.Map[newK] = e
	delete(t.Map, oldK)
	return nil
}

// GetOrCreateMap retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) GetOrCreateMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map {
	key := ForwardingClass

	if v, ok := t.Map[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMap(ForwardingClass)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMap got unexpected error: %v", err))
	}
	return v
}

// GetMap retrieves the value with the specified key from
// the Map map field of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) GetMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map {
	if t == nil {
		return nil
	}

	key := ForwardingClass

	if lm, ok := t.Map[key]; ok {
		return lm
	}
	return nil
}

// DeleteMap deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) DeleteMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union,
) {
	key := ForwardingClass

	delete(t.Map, key)
}

// AppendMap appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct to the
// list Map of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) AppendMap(v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) error {
	key := v.ForwardingClass

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map)
	}

	if _, ok := t.Map[key]; ok {
		return fmt.Errorf("duplicate key for list Map %v", key)
	}

	t.Map[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Map {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct {
	Dot1P           *uint8                                                                                          `path:"dot1p" module:"srl_nokia-qos"`
	DropProbability map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union                              `path:"forwarding-class" module:"srl_nokia-qos"`
	InnerDeMark     *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark                                       `path:"inner-de-mark" module:"srl_nokia-qos" yangPresence:"true"`
	InnerDot1P      *uint8                                                                                          `path:"inner-dot1p" module:"srl_nokia-qos"`
	OuterDeMark     *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark                                       `path:"outer-de-mark" module:"srl_nokia-qos" yangPresence:"true"`
	OuterDot1P      *uint8                                                                                          `path:"outer-dot1p" module:"srl_nokia-qos"`
	Profile         map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile          `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) IsYANGGoStruct() {}

// NewDropProbability creates a new entry in the DropProbability list of the
// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) NewDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability)
	}

	key := DropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DropProbability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DropProbability", key)
	}

	t.DropProbability[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability{
		DropProbability: DropProbability,
	}

	return t.DropProbability[key], nil
}

// RenameDropProbability renames an entry in the list DropProbability within
// the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) RenameDropProbability(oldK, newK E_SrlNokiaQos_DropProbability) error {
	if _, ok := t.DropProbability[newK]; ok {
		return fmt.Errorf("key %v already exists in DropProbability", newK)
	}

	e, ok := t.DropProbability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DropProbability", oldK)
	}
	e.DropProbability = newK

	t.DropProbability[newK] = e
	delete(t.DropProbability, oldK)
	return nil
}

// GetOrCreateDropProbability retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOrCreateDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability {
	key := DropProbability

	if v, ok := t.DropProbability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDropProbability(DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDropProbability got unexpected error: %v", err))
	}
	return v
}

// GetDropProbability retrieves the value with the specified key from
// the DropProbability map field of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability {
	if t == nil {
		return nil
	}

	key := DropProbability

	if lm, ok := t.DropProbability[key]; ok {
		return lm
	}
	return nil
}

// DeleteDropProbability deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) DeleteDropProbability(DropProbability E_SrlNokiaQos_DropProbability) {
	key := DropProbability

	delete(t.DropProbability, key)
}

// AppendDropProbability appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability struct to the
// list DropProbability of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) AppendDropProbability(
	v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability,
) error {
	key := v.DropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability)
	}

	if _, ok := t.DropProbability[key]; ok {
		return fmt.Errorf("duplicate key for list DropProbability %v", key)
	}

	t.DropProbability[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) NewProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile)
	}

	key := Profile

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile{
		Profile: Profile,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) RenameProfile(oldK, newK E_SrlNokiaQos_RewriteProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Profile = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOrCreateProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile {
	key := Profile

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Profile)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile {
	if t == nil {
		return nil
	}

	key := Profile

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) DeleteProfile(Profile E_SrlNokiaQos_RewriteProfile) {
	key := Profile

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile struct to the
// list Profile of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) AppendProfile(
	v *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile,
) error {
	key := v.Profile

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetOrCreateInnerDeMark retrieves the value of the InnerDeMark field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOrCreateInnerDeMark() *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark {
	if t.InnerDeMark != nil {
		return t.InnerDeMark
	}
	t.InnerDeMark = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark{}
	return t.InnerDeMark
}

// GetOrCreateOuterDeMark retrieves the value of the OuterDeMark field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOrCreateOuterDeMark() *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark {
	if t.OuterDeMark != nil {
		return t.OuterDeMark
	}
	t.OuterDeMark = &SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark{}
	return t.OuterDeMark
}

// GetInnerDeMark returns the value of the InnerDeMark struct pointer
// from SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the receiver or the field InnerDeMark is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetInnerDeMark() *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark {
	if t != nil && t.InnerDeMark != nil {
		return t.InnerDeMark
	}
	return nil
}

// GetOuterDeMark returns the value of the OuterDeMark struct pointer
// from SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map. If the receiver or the field OuterDeMark is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOuterDeMark() *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark {
	if t != nil && t.OuterDeMark != nil {
		return t.OuterDeMark
	}
	return nil
}

// GetDot1P retrieves the value of the leaf Dot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dot1P is set, it can
// safely use t.GetDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetDot1P() uint8 {
	if t == nil || t.Dot1P == nil {
		return 0
	}
	return *t.Dot1P
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetForwardingClass() SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetInnerDot1P retrieves the value of the leaf InnerDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerDot1P is set, it can
// safely use t.GetInnerDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetInnerDot1P() uint8 {
	if t == nil || t.InnerDot1P == nil {
		return 0
	}
	return *t.InnerDot1P
}

// GetOuterDot1P retrieves the value of the leaf OuterDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterDot1P is set, it can
// safely use t.GetOuterDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) GetOuterDot1P() uint8 {
	if t == nil || t.OuterDot1P == nil {
		return 0
	}
	return *t.OuterDot1P
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InnerDeMark.PopulateDefaults()
	t.OuterDeMark.PopulateDefaults()
	for _, e := range t.DropProbability {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map/drop-probability YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability struct {
	Dot1P           *uint8                        `path:"dot1p" module:"srl_nokia-qos"`
	DropProbability E_SrlNokiaQos_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) IsYANGGoStruct() {}

// GetDot1P retrieves the value of the leaf Dot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dot1P is set, it can
// safely use t.GetDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) GetDot1P() uint8 {
	if t == nil || t.Dot1P == nil {
		return 0
	}
	return *t.Dot1P
}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) GetDropProbability() E_SrlNokiaQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_DropProbability) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map/inner-de-mark YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark struct {
	Force *bool `path:"force" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark) IsYANGGoStruct() {}

// GetForce retrieves the value of the leaf Force from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Force is set, it can
// safely use t.GetForce() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Force == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark) GetForce() bool {
	if t == nil || t.Force == nil {
		return false
	}
	return *t.Force
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_InnerDeMark) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map/outer-de-mark YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark struct {
	Force *bool `path:"force" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark) IsYANGGoStruct() {}

// GetForce retrieves the value of the leaf Force from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Force is set, it can
// safely use t.GetForce() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Force == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark) GetForce() bool {
	if t == nil || t.Force == nil {
		return false
	}
	return *t.Force
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_OuterDeMark) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile represents the /srl_nokia-qos/qos/rewrite-rules/dot1p-policy/map/profile YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile struct {
	InnerDot1P *uint8                       `path:"inner-dot1p" module:"srl_nokia-qos"`
	OuterDot1P *uint8                       `path:"outer-dot1p" module:"srl_nokia-qos"`
	Profile    E_SrlNokiaQos_RewriteProfile `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) IsYANGGoStruct() {}

// GetInnerDot1P retrieves the value of the leaf InnerDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InnerDot1P is set, it can
// safely use t.GetInnerDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InnerDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetInnerDot1P() uint8 {
	if t == nil || t.InnerDot1P == nil {
		return 0
	}
	return *t.InnerDot1P
}

// GetOuterDot1P retrieves the value of the leaf OuterDot1P from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OuterDot1P is set, it can
// safely use t.GetOuterDot1P() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OuterDot1P == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetOuterDot1P() uint8 {
	if t == nil || t.OuterDot1P == nil {
		return 0
	}
	return *t.OuterDot1P
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) GetProfile() E_SrlNokiaQos_RewriteProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile": t.Profile,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile.
func (*SrlNokiaQos_Qos_RewriteRules_Dot1PPolicy_Map_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct {
	Map  map[SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map `path:"map" module:"srl_nokia-qos"`
	Name *string                                                                                                            `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy) IsYANGGoStruct() {}

// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) NewMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// RenameMap renames an entry in the list Map within
// the SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) RenameMap(
	oldK, newK SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union,
) error {
	if _, ok := t.Map[newK]; ok {
		return fmt.Errorf("key %v already exists in Map", newK)
	}

	e, ok := t.Map[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Map", oldK)
	}
	e.ForwardingClass = newK

	t.Map[newK] = e
	delete(t.Map, oldK)
	return nil
}

// GetOrCreateMap retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) GetOrCreateMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map {
	key := ForwardingClass

	if v, ok := t.Map[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMap(ForwardingClass)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMap got unexpected error: %v", err))
	}
	return v
}

// GetMap retrieves the value with the specified key from
// the Map map field of SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) GetMap(ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map {
	if t == nil {
		return nil
	}

	key := ForwardingClass

	if lm, ok := t.Map[key]; ok {
		return lm
	}
	return nil
}

// DeleteMap deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) DeleteMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union,
) {
	key := ForwardingClass

	delete(t.Map, key)
}

// AppendMap appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct to the
// list Map of SrlNokiaQos_Qos_RewriteRules_DscpPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) AppendMap(v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) error {
	key := v.ForwardingClass

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map)
	}

	if _, ok := t.Map[key]; ok {
		return fmt.Errorf("duplicate key for list Map %v", key)
	}

	t.Map[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Map {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy/map YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct {
	DropProbability map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	Dscp            SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Dscp_Union                                         `path:"dscp" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union                              `path:"forwarding-class" module:"srl_nokia-qos"`
	Profile         map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile          `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) IsYANGGoStruct() {}

// NewDropProbability creates a new entry in the DropProbability list of the
// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) NewDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability)
	}

	key := DropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DropProbability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DropProbability", key)
	}

	t.DropProbability[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability{
		DropProbability: DropProbability,
	}

	return t.DropProbability[key], nil
}

// RenameDropProbability renames an entry in the list DropProbability within
// the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) RenameDropProbability(oldK, newK E_SrlNokiaQos_DropProbability) error {
	if _, ok := t.DropProbability[newK]; ok {
		return fmt.Errorf("key %v already exists in DropProbability", newK)
	}

	e, ok := t.DropProbability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DropProbability", oldK)
	}
	e.DropProbability = newK

	t.DropProbability[newK] = e
	delete(t.DropProbability, oldK)
	return nil
}

// GetOrCreateDropProbability retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetOrCreateDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability {
	key := DropProbability

	if v, ok := t.DropProbability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDropProbability(DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDropProbability got unexpected error: %v", err))
	}
	return v
}

// GetDropProbability retrieves the value with the specified key from
// the DropProbability map field of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability {
	if t == nil {
		return nil
	}

	key := DropProbability

	if lm, ok := t.DropProbability[key]; ok {
		return lm
	}
	return nil
}

// DeleteDropProbability deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) DeleteDropProbability(DropProbability E_SrlNokiaQos_DropProbability) {
	key := DropProbability

	delete(t.DropProbability, key)
}

// AppendDropProbability appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability struct to the
// list DropProbability of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) AppendDropProbability(
	v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability,
) error {
	key := v.DropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability)
	}

	if _, ok := t.DropProbability[key]; ok {
		return fmt.Errorf("duplicate key for list DropProbability %v", key)
	}

	t.DropProbability[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) NewProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile)
	}

	key := Profile

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile{
		Profile: Profile,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) RenameProfile(oldK, newK E_SrlNokiaQos_RewriteProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Profile = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetOrCreateProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile {
	key := Profile

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Profile)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile {
	if t == nil {
		return nil
	}

	key := Profile

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) DeleteProfile(Profile E_SrlNokiaQos_RewriteProfile) {
	key := Profile

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile struct to the
// list Profile of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) AppendProfile(
	v *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile,
) error {
	key := v.Profile

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetDscp() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) GetForwardingClass() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.DropProbability {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy/map/drop-probability YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability struct {
	DropProbability E_SrlNokiaQos_DropProbability                                          `path:"drop-probability" module:"srl_nokia-qos"`
	Dscp            SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) IsYANGGoStruct() {}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) GetDropProbability() E_SrlNokiaQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) GetDscp() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_DropProbability) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile represents the /srl_nokia-qos/qos/rewrite-rules/dscp-policy/map/profile YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile struct {
	Dscp    SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Profile E_SrlNokiaQos_RewriteProfile                                   `path:"profile" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) GetDscp() SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) GetProfile() E_SrlNokiaQos_RewriteProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile": t.Profile,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile.
func (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy represents the /srl_nokia-qos/qos/rewrite-rules/ip-remark-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy struct {
	Exceed *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed `path:"exceed" module:"srl_nokia-qos"`
	In     *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In     `path:"in" module:"srl_nokia-qos"`
	InPlus *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus `path:"in-plus" module:"srl_nokia-qos"`
	Name   *string                                             `path:"name" module:"srl_nokia-qos"`
	Out    *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out    `path:"out" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) IsYANGGoStruct() {}

// GetOrCreateExceed retrieves the value of the Exceed field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetOrCreateExceed() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed {
	if t.Exceed != nil {
		return t.Exceed
	}
	t.Exceed = &SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed{}
	return t.Exceed
}

// GetOrCreateIn retrieves the value of the In field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetOrCreateIn() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In {
	if t.In != nil {
		return t.In
	}
	t.In = &SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In{}
	return t.In
}

// GetOrCreateInPlus retrieves the value of the InPlus field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetOrCreateInPlus() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus {
	if t.InPlus != nil {
		return t.InPlus
	}
	t.InPlus = &SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus{}
	return t.InPlus
}

// GetOrCreateOut retrieves the value of the Out field
// or returns the existing field if it already exists.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetOrCreateOut() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out {
	if t.Out != nil {
		return t.Out
	}
	t.Out = &SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out{}
	return t.Out
}

// GetExceed returns the value of the Exceed struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy. If the receiver or the field Exceed is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetExceed() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed {
	if t != nil && t.Exceed != nil {
		return t.Exceed
	}
	return nil
}

// GetIn returns the value of the In struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy. If the receiver or the field In is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetIn() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In {
	if t != nil && t.In != nil {
		return t.In
	}
	return nil
}

// GetInPlus returns the value of the InPlus struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy. If the receiver or the field InPlus is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetInPlus() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus {
	if t != nil && t.InPlus != nil {
		return t.InPlus
	}
	return nil
}

// GetOut returns the value of the Out struct pointer
// from SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy. If the receiver or the field Out is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetOut() *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out {
	if t != nil && t.Out != nil {
		return t.Out
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Exceed.PopulateDefaults()
	t.In.PopulateDefaults()
	t.InPlus.PopulateDefaults()
	t.Out.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed represents the /srl_nokia-qos/qos/rewrite-rules/ip-remark-policy/exceed YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                        `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Exceed) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In represents the /srl_nokia-qos/qos/rewrite-rules/ip-remark-policy/in YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                    `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_In) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus represents the /srl_nokia-qos/qos/rewrite-rules/ip-remark-policy/in-plus YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                        `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_InPlus) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out represents the /srl_nokia-qos/qos/rewrite-rules/ip-remark-policy/out YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out struct {
	Dscp       SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out_Dscp_Union `path:"dscp" module:"srl_nokia-qos"`
	Precedence *uint8                                                     `path:"precedence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) GetDscp() SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out_Dscp_Union {
	if t == nil || t.Dscp == nil {
		return nil
	}
	return t.Dscp
}

// GetPrecedence retrieves the value of the leaf Precedence from the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Precedence is set, it can
// safely use t.GetPrecedence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Precedence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) GetPrecedence() uint8 {
	if t == nil || t.Precedence == nil {
		return 0
	}
	return *t.Precedence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out.
func (*SrlNokiaQos_Qos_RewriteRules_IpRemarkPolicy_Out) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct {
	Map  map[SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map `path:"map" module:"srl_nokia-qos"`
	Name *string                                                                                                                                    `path:"name" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) IsYANGGoStruct() {}

// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) NewMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// RenameMap renames an entry in the list Map within
// the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) RenameMap(
	oldK, newK SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) error {
	if _, ok := t.Map[newK]; ok {
		return fmt.Errorf("key %v already exists in Map", newK)
	}

	e, ok := t.Map[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Map", oldK)
	}
	e.ForwardingClass = newK

	t.Map[newK] = e
	delete(t.Map, oldK)
	return nil
}

// GetOrCreateMap retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) GetOrCreateMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map {
	key := ForwardingClass

	if v, ok := t.Map[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMap(ForwardingClass)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMap got unexpected error: %v", err))
	}
	return v
}

// GetMap retrieves the value with the specified key from
// the Map map field of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) GetMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map {
	if t == nil {
		return nil
	}

	key := ForwardingClass

	if lm, ok := t.Map[key]; ok {
		return lm
	}
	return nil
}

// DeleteMap deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) DeleteMap(
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union,
) {
	key := ForwardingClass

	delete(t.Map, key)
}

// AppendMap appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct to the
// list Map of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) AppendMap(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map,
) error {
	key := v.ForwardingClass

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map)
	}

	if _, ok := t.Map[key]; ok {
		return fmt.Errorf("duplicate key for list Map %v", key)
	}

	t.Map[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Map {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy/map YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct {
	DropProbability map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	ForwardingClass SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union                              `path:"forwarding-class" module:"srl_nokia-qos"`
	Profile         map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile          `path:"profile" module:"srl_nokia-qos"`
	TrafficClass    *uint8                                                                                                     `path:"traffic-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) IsYANGGoStruct() {}

// NewDropProbability creates a new entry in the DropProbability list of the
// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) NewDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability)
	}

	key := DropProbability

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DropProbability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DropProbability", key)
	}

	t.DropProbability[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability{
		DropProbability: DropProbability,
	}

	return t.DropProbability[key], nil
}

// RenameDropProbability renames an entry in the list DropProbability within
// the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) RenameDropProbability(oldK, newK E_SrlNokiaQos_DropProbability) error {
	if _, ok := t.DropProbability[newK]; ok {
		return fmt.Errorf("key %v already exists in DropProbability", newK)
	}

	e, ok := t.DropProbability[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DropProbability", oldK)
	}
	e.DropProbability = newK

	t.DropProbability[newK] = e
	delete(t.DropProbability, oldK)
	return nil
}

// GetOrCreateDropProbability retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetOrCreateDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability {
	key := DropProbability

	if v, ok := t.DropProbability[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDropProbability(DropProbability)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDropProbability got unexpected error: %v", err))
	}
	return v
}

// GetDropProbability retrieves the value with the specified key from
// the DropProbability map field of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetDropProbability(
	DropProbability E_SrlNokiaQos_DropProbability,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability {
	if t == nil {
		return nil
	}

	key := DropProbability

	if lm, ok := t.DropProbability[key]; ok {
		return lm
	}
	return nil
}

// DeleteDropProbability deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) DeleteDropProbability(DropProbability E_SrlNokiaQos_DropProbability) {
	key := DropProbability

	delete(t.DropProbability, key)
}

// AppendDropProbability appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability struct to the
// list DropProbability of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) AppendDropProbability(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability,
) error {
	key := v.DropProbability

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DropProbability == nil {
		t.DropProbability = make(map[E_SrlNokiaQos_DropProbability]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability)
	}

	if _, ok := t.DropProbability[key]; ok {
		return fmt.Errorf("duplicate key for list DropProbability %v", key)
	}

	t.DropProbability[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) NewProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile)
	}

	key := Profile

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile{
		Profile: Profile,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) RenameProfile(oldK, newK E_SrlNokiaQos_RewriteProfile) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Profile = newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetOrCreateProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile {
	key := Profile

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Profile)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetProfile(
	Profile E_SrlNokiaQos_RewriteProfile,
) *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile {
	if t == nil {
		return nil
	}

	key := Profile

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) DeleteProfile(Profile E_SrlNokiaQos_RewriteProfile) {
	key := Profile

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile struct to the
// list Profile of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) AppendProfile(
	v *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile,
) error {
	key := v.Profile

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[E_SrlNokiaQos_RewriteProfile]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetForwardingClass() SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_ForwardingClass_Union {
	if t == nil || t.ForwardingClass == nil {
		return nil
	}
	return t.ForwardingClass
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.DropProbability {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy/map/drop-probability YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability struct {
	DropProbability E_SrlNokiaQos_DropProbability `path:"drop-probability" module:"srl_nokia-qos"`
	TrafficClass    *uint8                        `path:"traffic-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) IsYANGGoStruct() {}

// GetDropProbability retrieves the value of the leaf DropProbability from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropProbability is set, it can
// safely use t.GetDropProbability() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropProbability == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) GetDropProbability() E_SrlNokiaQos_DropProbability {
	if t == nil || t.DropProbability == 0 {
		return 0
	}
	return t.DropProbability
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"drop-probability": t.DropProbability,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_DropProbability) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile represents the /srl_nokia-qos/qos/rewrite-rules/mpls-traffic-class-policy/map/profile YANG schema element.
type SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile struct {
	Profile      E_SrlNokiaQos_RewriteProfile `path:"profile" module:"srl_nokia-qos"`
	TrafficClass *uint8                       `path:"traffic-class" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) IsYANGGoStruct() {}

// GetProfile retrieves the value of the leaf Profile from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Profile is set, it can
// safely use t.GetProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Profile == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) GetProfile() E_SrlNokiaQos_RewriteProfile {
	if t == nil || t.Profile == 0 {
		return 0
	}
	return t.Profile
}

// GetTrafficClass retrieves the value of the leaf TrafficClass from the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrafficClass is set, it can
// safely use t.GetTrafficClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrafficClass == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) GetTrafficClass() uint8 {
	if t == nil || t.TrafficClass == nil {
		return 0
	}
	return *t.TrafficClass
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"profile": t.Profile,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile.
func (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map_Profile) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies represents the /srl_nokia-qos/qos/scheduler-policies YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies struct {
	SchedulerPolicy map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy `path:"scheduler-policy" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies) IsYANGGoStruct() {}

// NewSchedulerPolicy creates a new entry in the SchedulerPolicy list of the
// SrlNokiaQos_Qos_SchedulerPolicies struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) NewSchedulerPolicy(Name string) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedulerPolicy == nil {
		t.SchedulerPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SchedulerPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SchedulerPolicy", key)
	}

	t.SchedulerPolicy[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy{
		Name: &Name,
	}

	return t.SchedulerPolicy[key], nil
}

// RenameSchedulerPolicy renames an entry in the list SchedulerPolicy within
// the SrlNokiaQos_Qos_SchedulerPolicies struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) RenameSchedulerPolicy(oldK, newK string) error {
	if _, ok := t.SchedulerPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in SchedulerPolicy", newK)
	}

	e, ok := t.SchedulerPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SchedulerPolicy", oldK)
	}
	e.Name = &newK

	t.SchedulerPolicy[newK] = e
	delete(t.SchedulerPolicy, oldK)
	return nil
}

// GetOrCreateSchedulerPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetOrCreateSchedulerPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy {
	key := Name

	if v, ok := t.SchedulerPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSchedulerPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSchedulerPolicy got unexpected error: %v", err))
	}
	return v
}

// GetSchedulerPolicy retrieves the value with the specified key from
// the SchedulerPolicy map field of SrlNokiaQos_Qos_SchedulerPolicies. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) GetSchedulerPolicy(Name string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.SchedulerPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteSchedulerPolicy deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) DeleteSchedulerPolicy(Name string) {
	key := Name

	delete(t.SchedulerPolicy, key)
}

// AppendSchedulerPolicy appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct to the
// list SchedulerPolicy of SrlNokiaQos_Qos_SchedulerPolicies. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) AppendSchedulerPolicy(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SchedulerPolicy == nil {
		t.SchedulerPolicy = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy)
	}

	if _, ok := t.SchedulerPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list SchedulerPolicy %v", key)
	}

	t.SchedulerPolicy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.SchedulerPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies.
func (*SrlNokiaQos_Qos_SchedulerPolicies) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy represents the /srl_nokia-qos/qos/scheduler-policies/scheduler-policy YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct {
	Name      *string                                                                 `path:"name" module:"srl_nokia-qos"`
	Scheduler map[uint32]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler `path:"scheduler" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) IsYANGGoStruct() {}

// NewScheduler creates a new entry in the Scheduler list of the
// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) NewScheduler(Sequence uint32) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint32]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler)
	}

	key := Sequence

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Scheduler[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Scheduler", key)
	}

	t.Scheduler[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler{
		Sequence: &Sequence,
	}

	return t.Scheduler[key], nil
}

// RenameScheduler renames an entry in the list Scheduler within
// the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) RenameScheduler(oldK, newK uint32) error {
	if _, ok := t.Scheduler[newK]; ok {
		return fmt.Errorf("key %v already exists in Scheduler", newK)
	}

	e, ok := t.Scheduler[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Scheduler", oldK)
	}
	e.Sequence = &newK

	t.Scheduler[newK] = e
	delete(t.Scheduler, oldK)
	return nil
}

// GetOrCreateScheduler retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) GetOrCreateScheduler(Sequence uint32) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler {
	key := Sequence

	if v, ok := t.Scheduler[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewScheduler(Sequence)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateScheduler got unexpected error: %v", err))
	}
	return v
}

// GetScheduler retrieves the value with the specified key from
// the Scheduler map field of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) GetScheduler(Sequence uint32) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler {
	if t == nil {
		return nil
	}

	key := Sequence

	if lm, ok := t.Scheduler[key]; ok {
		return lm
	}
	return nil
}

// DeleteScheduler deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) DeleteScheduler(Sequence uint32) {
	key := Sequence

	delete(t.Scheduler, key)
}

// AppendScheduler appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct to the
// list Scheduler of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) AppendScheduler(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler,
) error {
	if v.Sequence == nil {
		return fmt.Errorf("invalid nil key received for Sequence")
	}

	key := *v.Sequence

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Scheduler == nil {
		t.Scheduler = make(map[uint32]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler)
	}

	if _, ok := t.Scheduler[key]; ok {
		return fmt.Errorf("duplicate key for list Scheduler %v", key)
	}

	t.Scheduler[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Scheduler {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler represents the /srl_nokia-qos/qos/scheduler-policies/scheduler-policy/scheduler YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct {
	Input    map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input `path:"input" module:"srl_nokia-qos"`
	Priority E_SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Priority        `path:"priority" module:"srl_nokia-qos"`
	Sequence *uint32                                                                       `path:"sequence" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) IsYANGGoStruct() {}

// NewInput creates a new entry in the Input list of the
// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) NewInput(Id string) (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Input == nil {
		t.Input = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Input[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Input", key)
	}

	t.Input[key] = &SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input{
		Id: &Id,
	}

	return t.Input[key], nil
}

// RenameInput renames an entry in the list Input within
// the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) RenameInput(oldK, newK string) error {
	if _, ok := t.Input[newK]; ok {
		return fmt.Errorf("key %v already exists in Input", newK)
	}

	e, ok := t.Input[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Input", oldK)
	}
	e.Id = &newK

	t.Input[newK] = e
	delete(t.Input, oldK)
	return nil
}

// GetOrCreateInput retrieves the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetOrCreateInput(Id string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input {
	key := Id

	if v, ok := t.Input[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInput(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInput got unexpected error: %v", err))
	}
	return v
}

// GetInput retrieves the value with the specified key from
// the Input map field of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetInput(Id string) *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Input[key]; ok {
		return lm
	}
	return nil
}

// DeleteInput deletes the value with the specified keys from
// the receiver SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) DeleteInput(Id string) {
	key := Id

	delete(t.Input, key)
}

// AppendInput appends the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input struct to the
// list Input of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler. If the key value(s) specified in
// the supplied SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input already exist in the list, an error is
// returned.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) AppendInput(
	v *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input,
) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Input == nil {
		t.Input = make(map[string]*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input)
	}

	if _, ok := t.Input[key]; ok {
		return fmt.Errorf("duplicate key for list Input %v", key)
	}

	t.Input[key] = v
	return nil
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetPriority() E_SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Priority {
	if t == nil || t.Priority == 0 {
		return 0
	}
	return t.Priority
}

// GetSequence retrieves the value of the leaf Sequence from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sequence is set, it can
// safely use t.GetSequence() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sequence == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) GetSequence() uint32 {
	if t == nil || t.Sequence == nil {
		return 0
	}
	return *t.Sequence
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Input {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Sequence == nil {
		return nil, fmt.Errorf("nil value for key Sequence")
	}

	return map[string]interface{}{
		"sequence": *t.Sequence,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input represents the /srl_nokia-qos/qos/scheduler-policies/scheduler-policy/scheduler/input YANG schema element.
type SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input struct {
	Id     *string                                                                       `path:"id" module:"srl_nokia-qos"`
	Queue  SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_Queue_Union `path:"queue" module:"srl_nokia-qos"`
	Weight *uint8                                                                        `path:"weight" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetQueue retrieves the value of the leaf Queue from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Queue is set, it can
// safely use t.GetQueue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Queue == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetQueue() SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input_Queue_Union {
	if t == nil || t.Queue == nil {
		return nil
	}
	return t.Queue
}

// GetWeight retrieves the value of the leaf Weight from the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input.
func (*SrlNokiaQos_Qos_SchedulerPolicies_SchedulerPolicy_Scheduler_Input) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaRoutingPolicy_RoutingPolicy represents the /srl_nokia-routing-policy/routing-policy YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy struct {
	AsPathSet    map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet    `path:"as-path-set" module:"srl_nokia-routing-policy"`
	CommunitySet map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet `path:"community-set" module:"srl_nokia-routing-policy"`
	Policy       map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy       `path:"policy" module:"srl_nokia-routing-policy"`
	PrefixSet    map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet    `path:"prefix-set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy) IsYANGGoStruct() {}

// NewAsPathSet creates a new entry in the AsPathSet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewAsPathSet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AsPathSet == nil {
		t.AsPathSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AsPathSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AsPathSet", key)
	}

	t.AsPathSet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet{
		Name: &Name,
	}

	return t.AsPathSet[key], nil
}

// RenameAsPathSet renames an entry in the list AsPathSet within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenameAsPathSet(oldK, newK string) error {
	if _, ok := t.AsPathSet[newK]; ok {
		return fmt.Errorf("key %v already exists in AsPathSet", newK)
	}

	e, ok := t.AsPathSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AsPathSet", oldK)
	}
	e.Name = &newK

	t.AsPathSet[newK] = e
	delete(t.AsPathSet, oldK)
	return nil
}

// GetOrCreateAsPathSet retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreateAsPathSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet {
	key := Name

	if v, ok := t.AsPathSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAsPathSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAsPathSet got unexpected error: %v", err))
	}
	return v
}

// GetAsPathSet retrieves the value with the specified key from
// the AsPathSet map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetAsPathSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.AsPathSet[key]; ok {
		return lm
	}
	return nil
}

// DeleteAsPathSet deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeleteAsPathSet(Name string) {
	key := Name

	delete(t.AsPathSet, key)
}

// AppendAsPathSet appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet struct to the
// list AsPathSet of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendAsPathSet(v *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AsPathSet == nil {
		t.AsPathSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet)
	}

	if _, ok := t.AsPathSet[key]; ok {
		return fmt.Errorf("duplicate key for list AsPathSet %v", key)
	}

	t.AsPathSet[key] = v
	return nil
}

// NewCommunitySet creates a new entry in the CommunitySet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewCommunitySet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CommunitySet == nil {
		t.CommunitySet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CommunitySet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CommunitySet", key)
	}

	t.CommunitySet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet{
		Name: &Name,
	}

	return t.CommunitySet[key], nil
}

// RenameCommunitySet renames an entry in the list CommunitySet within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenameCommunitySet(oldK, newK string) error {
	if _, ok := t.CommunitySet[newK]; ok {
		return fmt.Errorf("key %v already exists in CommunitySet", newK)
	}

	e, ok := t.CommunitySet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CommunitySet", oldK)
	}
	e.Name = &newK

	t.CommunitySet[newK] = e
	delete(t.CommunitySet, oldK)
	return nil
}

// GetOrCreateCommunitySet retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreateCommunitySet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet {
	key := Name

	if v, ok := t.CommunitySet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCommunitySet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCommunitySet got unexpected error: %v", err))
	}
	return v
}

// GetCommunitySet retrieves the value with the specified key from
// the CommunitySet map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetCommunitySet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.CommunitySet[key]; ok {
		return lm
	}
	return nil
}

// DeleteCommunitySet deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeleteCommunitySet(Name string) {
	key := Name

	delete(t.CommunitySet, key)
}

// AppendCommunitySet appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet struct to the
// list CommunitySet of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendCommunitySet(
	v *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CommunitySet == nil {
		t.CommunitySet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet)
	}

	if _, ok := t.CommunitySet[key]; ok {
		return fmt.Errorf("duplicate key for list CommunitySet %v", key)
	}

	t.CommunitySet[key] = v
	return nil
}

// NewPolicy creates a new entry in the Policy list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewPolicy(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy{
		Name: &Name,
	}

	return t.Policy[key], nil
}

// RenamePolicy renames an entry in the list Policy within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenamePolicy(oldK, newK string) error {
	if _, ok := t.Policy[newK]; ok {
		return fmt.Errorf("key %v already exists in Policy", newK)
	}

	e, ok := t.Policy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policy", oldK)
	}
	e.Name = &newK

	t.Policy[newK] = e
	delete(t.Policy, oldK)
	return nil
}

// GetOrCreatePolicy retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreatePolicy(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy {
	key := Name

	if v, ok := t.Policy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicy got unexpected error: %v", err))
	}
	return v
}

// GetPolicy retrieves the value with the specified key from
// the Policy map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetPolicy(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Policy[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicy deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeletePolicy(Name string) {
	key := Name

	delete(t.Policy, key)
}

// AppendPolicy appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct to the
// list Policy of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendPolicy(v *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy)
	}

	if _, ok := t.Policy[key]; ok {
		return fmt.Errorf("duplicate key for list Policy %v", key)
	}

	t.Policy[key] = v
	return nil
}

// NewPrefixSet creates a new entry in the PrefixSet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewPrefixSet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSet", key)
	}

	t.PrefixSet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet{
		Name: &Name,
	}

	return t.PrefixSet[key], nil
}

// RenamePrefixSet renames an entry in the list PrefixSet within
// the SrlNokiaRoutingPolicy_RoutingPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) RenamePrefixSet(oldK, newK string) error {
	if _, ok := t.PrefixSet[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixSet", newK)
	}

	e, ok := t.PrefixSet[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixSet", oldK)
	}
	e.Name = &newK

	t.PrefixSet[newK] = e
	delete(t.PrefixSet, oldK)
	return nil
}

// GetOrCreatePrefixSet retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetOrCreatePrefixSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet {
	key := Name

	if v, ok := t.PrefixSet[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixSet(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixSet got unexpected error: %v", err))
	}
	return v
}

// GetPrefixSet retrieves the value with the specified key from
// the PrefixSet map field of SrlNokiaRoutingPolicy_RoutingPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) GetPrefixSet(Name string) *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.PrefixSet[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixSet deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) DeletePrefixSet(Name string) {
	key := Name

	delete(t.PrefixSet, key)
}

// AppendPrefixSet appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct to the
// list PrefixSet of SrlNokiaRoutingPolicy_RoutingPolicy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) AppendPrefixSet(v *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet)
	}

	if _, ok := t.PrefixSet[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixSet %v", key)
	}

	t.PrefixSet[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AsPathSet {
		e.PopulateDefaults()
	}
	for _, e := range t.CommunitySet {
		e.PopulateDefaults()
	}
	for _, e := range t.Policy {
		e.PopulateDefaults()
	}
	for _, e := range t.PrefixSet {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy.
func (*SrlNokiaRoutingPolicy_RoutingPolicy) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet represents the /srl_nokia-routing-policy/routing-policy/as-path-set YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet struct {
	Expression *string `path:"expression" module:"srl_nokia-routing-policy"`
	Name       *string `path:"name" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) IsYANGGoStruct() {}

// GetExpression retrieves the value of the leaf Expression from the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Expression is set, it can
// safely use t.GetExpression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Expression == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) GetExpression() string {
	if t == nil || t.Expression == nil {
		return ""
	}
	return *t.Expression
}

// GetName retrieves the value of the leaf Name from the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet represents the /srl_nokia-routing-policy/routing-policy/community-set YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet struct {
	Member []SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet_Member_Union `path:"member" module:"srl_nokia-routing-policy"`
	Name   *string                                                         `path:"name" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) IsYANGGoStruct() {}

// GetMember retrieves the value of the leaf Member from the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Member is set, it can
// safely use t.GetMember() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Member == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) GetMember() []SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet_Member_Union {
	if t == nil || t.Member == nil {
		return nil
	}
	return t.Member
}

// GetName retrieves the value of the leaf Name from the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy represents the /srl_nokia-routing-policy/routing-policy/policy YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct {
	DefaultAction *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction        `path:"default-action" module:"srl_nokia-routing-policy"`
	Name          *string                                                          `path:"name" module:"srl_nokia-routing-policy"`
	Statement     map[uint32]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement `path:"statement" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy) IsYANGGoStruct() {}

// NewStatement creates a new entry in the Statement list of the
// SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) NewStatement(SequenceId uint32) (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Statement == nil {
		t.Statement = make(map[uint32]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Statement[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Statement", key)
	}

	t.Statement[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement{
		SequenceId: &SequenceId,
	}

	return t.Statement[key], nil
}

// RenameStatement renames an entry in the list Statement within
// the SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) RenameStatement(oldK, newK uint32) error {
	if _, ok := t.Statement[newK]; ok {
		return fmt.Errorf("key %v already exists in Statement", newK)
	}

	e, ok := t.Statement[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Statement", oldK)
	}
	e.SequenceId = &newK

	t.Statement[newK] = e
	delete(t.Statement, oldK)
	return nil
}

// GetOrCreateStatement retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetOrCreateStatement(SequenceId uint32) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement {
	key := SequenceId

	if v, ok := t.Statement[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatement(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatement got unexpected error: %v", err))
	}
	return v
}

// GetStatement retrieves the value with the specified key from
// the Statement map field of SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetStatement(SequenceId uint32) *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Statement[key]; ok {
		return lm
	}
	return nil
}

// DeleteStatement deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) DeleteStatement(SequenceId uint32) {
	key := SequenceId

	delete(t.Statement, key)
}

// AppendStatement appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement struct to the
// list Statement of SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) AppendStatement(
	v *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Statement == nil {
		t.Statement = make(map[uint32]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement)
	}

	if _, ok := t.Statement[key]; ok {
		return fmt.Errorf("duplicate key for list Statement %v", key)
	}

	t.Statement[key] = v
	return nil
}

// GetOrCreateDefaultAction retrieves the value of the DefaultAction field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetOrCreateDefaultAction() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction {
	if t.DefaultAction != nil {
		return t.DefaultAction
	}
	t.DefaultAction = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction{}
	return t.DefaultAction
}

// GetDefaultAction returns the value of the DefaultAction struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy. If the receiver or the field DefaultAction is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetDefaultAction() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction {
	if t != nil && t.DefaultAction != nil {
		return t.DefaultAction
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DefaultAction.PopulateDefaults()
	for _, e := range t.Statement {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction represents the /srl_nokia-routing-policy/routing-policy/policy/default-action YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction struct {
	Bgp          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp `path:"bgp" module:"srl_nokia-routing-policy"`
	PolicyResult E_SrlNokiaPolicyTypes_PolicyResultType                        `path:"policy-result" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) IsYANGGoStruct() {}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetOrCreateBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp{}
	return t.Bgp
}

// GetBgp returns the value of the Bgp struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetPolicyResult retrieves the value of the leaf PolicyResult from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicyResult is set, it can
// safely use t.GetPolicyResult() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicyResult == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) GetPolicyResult() E_SrlNokiaPolicyTypes_PolicyResultType {
	if t == nil || t.PolicyResult == 0 {
		return 0
	}
	return t.PolicyResult
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp struct {
	AsPath          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath          `path:"as-path" module:"srl_nokia-routing-policy"`
	Communities     *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities     `path:"communities" module:"srl_nokia-routing-policy"`
	LocalPreference *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference `path:"local-preference" module:"srl_nokia-routing-policy"`
	Med             *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med             `path:"med" module:"srl_nokia-routing-policy"`
	Origin          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin          `path:"origin" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) IsYANGGoStruct() {}

// GetOrCreateAsPath retrieves the value of the AsPath field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateAsPath() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath {
	if t.AsPath != nil {
		return t.AsPath
	}
	t.AsPath = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath{}
	return t.AsPath
}

// GetOrCreateCommunities retrieves the value of the Communities field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateCommunities() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities {
	if t.Communities != nil {
		return t.Communities
	}
	t.Communities = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities{}
	return t.Communities
}

// GetOrCreateLocalPreference retrieves the value of the LocalPreference field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateLocalPreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference {
	if t.LocalPreference != nil {
		return t.LocalPreference
	}
	t.LocalPreference = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference{}
	return t.LocalPreference
}

// GetOrCreateMed retrieves the value of the Med field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateMed() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med {
	if t.Med != nil {
		return t.Med
	}
	t.Med = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med{}
	return t.Med
}

// GetOrCreateOrigin retrieves the value of the Origin field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrCreateOrigin() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin {
	if t.Origin != nil {
		return t.Origin
	}
	t.Origin = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin{}
	return t.Origin
}

// GetAsPath returns the value of the AsPath struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field AsPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetAsPath() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath {
	if t != nil && t.AsPath != nil {
		return t.AsPath
	}
	return nil
}

// GetCommunities returns the value of the Communities struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field Communities is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetCommunities() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities {
	if t != nil && t.Communities != nil {
		return t.Communities
	}
	return nil
}

// GetLocalPreference returns the value of the LocalPreference struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field LocalPreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetLocalPreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference {
	if t != nil && t.LocalPreference != nil {
		return t.LocalPreference
	}
	return nil
}

// GetMed returns the value of the Med struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field Med is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetMed() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med {
	if t != nil && t.Med != nil {
		return t.Med
	}
	return nil
}

// GetOrigin returns the value of the Origin struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp. If the receiver or the field Origin is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) GetOrigin() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin {
	if t != nil && t.Origin != nil {
		return t.Origin
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AsPath.PopulateDefaults()
	t.Communities.PopulateDefaults()
	t.LocalPreference.PopulateDefaults()
	t.Med.PopulateDefaults()
	t.Origin.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp/as-path YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath struct {
	Prepend *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend `path:"prepend" module:"srl_nokia-routing-policy"`
	Remove  *bool                                                                        `path:"remove" module:"srl_nokia-routing-policy"`
	Replace []uint32                                                                     `path:"replace" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) IsYANGGoStruct() {}

// GetOrCreatePrepend retrieves the value of the Prepend field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetOrCreatePrepend() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend {
	if t.Prepend != nil {
		return t.Prepend
	}
	t.Prepend = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend{}
	return t.Prepend
}

// GetPrepend returns the value of the Prepend struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath. If the receiver or the field Prepend is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetPrepend() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend {
	if t != nil && t.Prepend != nil {
		return t.Prepend
	}
	return nil
}

// GetRemove retrieves the value of the leaf Remove from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Remove is set, it can
// safely use t.GetRemove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Remove == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetRemove() bool {
	if t == nil || t.Remove == nil {
		return false
	}
	return *t.Remove
}

// GetReplace retrieves the value of the leaf Replace from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Replace is set, it can
// safely use t.GetReplace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Replace == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) GetReplace() []uint32 {
	if t == nil || t.Replace == nil {
		return nil
	}
	return t.Replace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Prepend.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp/as-path/prepend YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend struct {
	AsNumber SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend_AsNumber_Union `path:"as-number" module:"srl_nokia-routing-policy"`
	RepeatN  *uint8                                                                                     `path:"repeat-n" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) IsYANGGoStruct() {
}

// GetAsNumber retrieves the value of the leaf AsNumber from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AsNumber is set, it can
// safely use t.GetAsNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AsNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) GetAsNumber() SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend_AsNumber_Union {
	if t == nil || t.AsNumber == nil {
		return nil
	}
	return t.AsNumber
}

// GetRepeatN retrieves the value of the leaf RepeatN from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RepeatN is set, it can
// safely use t.GetRepeatN() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RepeatN == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) GetRepeatN() uint8 {
	if t == nil || t.RepeatN == nil {
		return 1
	}
	return *t.RepeatN
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RepeatN == nil {
		var v uint8 = 1
		t.RepeatN = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_AsPath_Prepend) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp/communities YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities struct {
	Add     *string `path:"add" module:"srl_nokia-routing-policy"`
	Remove  *string `path:"remove" module:"srl_nokia-routing-policy"`
	Replace *string `path:"replace" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) IsYANGGoStruct() {}

// GetAdd retrieves the value of the leaf Add from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Add is set, it can
// safely use t.GetAdd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Add == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) GetAdd() string {
	if t == nil || t.Add == nil {
		return ""
	}
	return *t.Add
}

// GetRemove retrieves the value of the leaf Remove from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Remove is set, it can
// safely use t.GetRemove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Remove == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) GetRemove() string {
	if t == nil || t.Remove == nil {
		return ""
	}
	return *t.Remove
}

// GetReplace retrieves the value of the leaf Replace from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Replace is set, it can
// safely use t.GetReplace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Replace == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) GetReplace() string {
	if t == nil || t.Replace == nil {
		return ""
	}
	return *t.Replace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Communities) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp/local-preference YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference struct {
	Set *uint32 `path:"set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference) IsYANGGoStruct() {
}

// GetSet retrieves the value of the leaf Set from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Set is set, it can
// safely use t.GetSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Set == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference) GetSet() uint32 {
	if t == nil || t.Set == nil {
		return 0
	}
	return *t.Set
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_LocalPreference) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp/med YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med struct {
	Set SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med_Set_Union `path:"set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med) IsYANGGoStruct() {}

// GetSet retrieves the value of the leaf Set from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Set is set, it can
// safely use t.GetSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Set == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med) GetSet() SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med_Set_Union {
	if t == nil || t.Set == nil {
		return nil
	}
	return t.Set
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Med) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin represents the /srl_nokia-routing-policy/routing-policy/policy/default-action/bgp/origin YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin struct {
	Set E_SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin_Set `path:"set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin) IsYANGGoStruct() {}

// GetSet retrieves the value of the leaf Set from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Set is set, it can
// safely use t.GetSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Set == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin) GetSet() E_SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin_Set {
	if t == nil || t.Set == 0 {
		return 0
	}
	return t.Set
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement represents the /srl_nokia-routing-policy/routing-policy/policy/statement YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement struct {
	Action     *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action `path:"action" module:"srl_nokia-routing-policy"`
	Match      *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match  `path:"match" module:"srl_nokia-routing-policy"`
	SequenceId *uint32                                                      `path:"sequence-id" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) GetOrCreateAction() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) GetOrCreateMatch() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) GetAction() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) GetMatch() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action struct {
	Bgp          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp `path:"bgp" module:"srl_nokia-routing-policy"`
	PolicyResult E_SrlNokiaPolicyTypes_PolicyResultType                           `path:"policy-result" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) IsYANGGoStruct() {}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) GetOrCreateBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp{}
	return t.Bgp
}

// GetBgp returns the value of the Bgp struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) GetBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetPolicyResult retrieves the value of the leaf PolicyResult from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicyResult is set, it can
// safely use t.GetPolicyResult() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicyResult == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) GetPolicyResult() E_SrlNokiaPolicyTypes_PolicyResultType {
	if t == nil || t.PolicyResult == 0 {
		return 0
	}
	return t.PolicyResult
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action/bgp YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp struct {
	AsPath          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath          `path:"as-path" module:"srl_nokia-routing-policy"`
	Communities     *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities     `path:"communities" module:"srl_nokia-routing-policy"`
	LocalPreference *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference `path:"local-preference" module:"srl_nokia-routing-policy"`
	Med             *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med             `path:"med" module:"srl_nokia-routing-policy"`
	Origin          *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin          `path:"origin" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) IsYANGGoStruct() {}

// GetOrCreateAsPath retrieves the value of the AsPath field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetOrCreateAsPath() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath {
	if t.AsPath != nil {
		return t.AsPath
	}
	t.AsPath = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath{}
	return t.AsPath
}

// GetOrCreateCommunities retrieves the value of the Communities field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetOrCreateCommunities() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities {
	if t.Communities != nil {
		return t.Communities
	}
	t.Communities = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities{}
	return t.Communities
}

// GetOrCreateLocalPreference retrieves the value of the LocalPreference field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetOrCreateLocalPreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference {
	if t.LocalPreference != nil {
		return t.LocalPreference
	}
	t.LocalPreference = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference{}
	return t.LocalPreference
}

// GetOrCreateMed retrieves the value of the Med field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetOrCreateMed() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med {
	if t.Med != nil {
		return t.Med
	}
	t.Med = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med{}
	return t.Med
}

// GetOrCreateOrigin retrieves the value of the Origin field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetOrCreateOrigin() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin {
	if t.Origin != nil {
		return t.Origin
	}
	t.Origin = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin{}
	return t.Origin
}

// GetAsPath returns the value of the AsPath struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp. If the receiver or the field AsPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetAsPath() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath {
	if t != nil && t.AsPath != nil {
		return t.AsPath
	}
	return nil
}

// GetCommunities returns the value of the Communities struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp. If the receiver or the field Communities is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetCommunities() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities {
	if t != nil && t.Communities != nil {
		return t.Communities
	}
	return nil
}

// GetLocalPreference returns the value of the LocalPreference struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp. If the receiver or the field LocalPreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetLocalPreference() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference {
	if t != nil && t.LocalPreference != nil {
		return t.LocalPreference
	}
	return nil
}

// GetMed returns the value of the Med struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp. If the receiver or the field Med is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetMed() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med {
	if t != nil && t.Med != nil {
		return t.Med
	}
	return nil
}

// GetOrigin returns the value of the Origin struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp. If the receiver or the field Origin is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) GetOrigin() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin {
	if t != nil && t.Origin != nil {
		return t.Origin
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AsPath.PopulateDefaults()
	t.Communities.PopulateDefaults()
	t.LocalPreference.PopulateDefaults()
	t.Med.PopulateDefaults()
	t.Origin.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action/bgp/as-path YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath struct {
	Prepend *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend `path:"prepend" module:"srl_nokia-routing-policy"`
	Remove  *bool                                                                           `path:"remove" module:"srl_nokia-routing-policy"`
	Replace []uint32                                                                        `path:"replace" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) IsYANGGoStruct() {}

// GetOrCreatePrepend retrieves the value of the Prepend field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) GetOrCreatePrepend() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend {
	if t.Prepend != nil {
		return t.Prepend
	}
	t.Prepend = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend{}
	return t.Prepend
}

// GetPrepend returns the value of the Prepend struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath. If the receiver or the field Prepend is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) GetPrepend() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend {
	if t != nil && t.Prepend != nil {
		return t.Prepend
	}
	return nil
}

// GetRemove retrieves the value of the leaf Remove from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Remove is set, it can
// safely use t.GetRemove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Remove == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) GetRemove() bool {
	if t == nil || t.Remove == nil {
		return false
	}
	return *t.Remove
}

// GetReplace retrieves the value of the leaf Replace from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Replace is set, it can
// safely use t.GetReplace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Replace == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) GetReplace() []uint32 {
	if t == nil || t.Replace == nil {
		return nil
	}
	return t.Replace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Prepend.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action/bgp/as-path/prepend YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend struct {
	AsNumber SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend_AsNumber_Union `path:"as-number" module:"srl_nokia-routing-policy"`
	RepeatN  *uint8                                                                                        `path:"repeat-n" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) IsYANGGoStruct() {
}

// GetAsNumber retrieves the value of the leaf AsNumber from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AsNumber is set, it can
// safely use t.GetAsNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AsNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) GetAsNumber() SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend_AsNumber_Union {
	if t == nil || t.AsNumber == nil {
		return nil
	}
	return t.AsNumber
}

// GetRepeatN retrieves the value of the leaf RepeatN from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RepeatN is set, it can
// safely use t.GetRepeatN() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RepeatN == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) GetRepeatN() uint8 {
	if t == nil || t.RepeatN == nil {
		return 1
	}
	return *t.RepeatN
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RepeatN == nil {
		var v uint8 = 1
		t.RepeatN = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_AsPath_Prepend) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action/bgp/communities YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities struct {
	Add     *string `path:"add" module:"srl_nokia-routing-policy"`
	Remove  *string `path:"remove" module:"srl_nokia-routing-policy"`
	Replace *string `path:"replace" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) IsYANGGoStruct() {
}

// GetAdd retrieves the value of the leaf Add from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Add is set, it can
// safely use t.GetAdd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Add == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) GetAdd() string {
	if t == nil || t.Add == nil {
		return ""
	}
	return *t.Add
}

// GetRemove retrieves the value of the leaf Remove from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Remove is set, it can
// safely use t.GetRemove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Remove == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) GetRemove() string {
	if t == nil || t.Remove == nil {
		return ""
	}
	return *t.Remove
}

// GetReplace retrieves the value of the leaf Replace from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Replace is set, it can
// safely use t.GetReplace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Replace == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) GetReplace() string {
	if t == nil || t.Replace == nil {
		return ""
	}
	return *t.Replace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Communities) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}
