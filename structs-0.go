/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /root/go/pkg/mod/github.com/openconfig/ygot@v0.24.4/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/macsec/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-sr-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-reboot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"encoding/json"
	"fmt"
	"reflect"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// ΓModelData contains the catalogue information corresponding to the modules for
// which Go code was generated.
var ΓModelData = []*gpb.ModelData{
	{
		Name:         "ietf-inet-types",
		Organization: "IETF NETMOD (NETCONF Data Modeling Language) Working Group",
	},
	{
		Name:         "ietf-yang-types",
		Organization: "IETF NETMOD (NETCONF Data Modeling Language) Working Group",
	},
	{
		Name: "srl_nokia-aaa",
	},
	{
		Name: "srl_nokia-aaa-password",
	},
	{
		Name: "srl_nokia-aaa-tacacs",
	},
	{
		Name: "srl_nokia-aaa-types",
	},
	{
		Name:         "srl_nokia-acl",
		Organization: "Nokia",
	},
	{
		Name:         "srl_nokia-acl-qos",
		Organization: "Nokia",
	},
	{
		Name: "srl_nokia-aggregate-routes",
	},
	{
		Name: "srl_nokia-app-mgmt",
	},
	{
		Name: "srl_nokia-bfd",
	},
	{
		Name: "srl_nokia-bgp",
	},
	{
		Name: "srl_nokia-bgp-evpn",
	},
	{
		Name: "srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations",
	},
	{
		Name: "srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics",
	},
	{
		Name: "srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations",
	},
	{
		Name: "srl_nokia-bgp-vpn",
	},
	{
		Name: "srl_nokia-boot",
	},
	{
		Name: "srl_nokia-bridge-table",
	},
	{
		Name: "srl_nokia-bridge-table-mac-duplication",
	},
	{
		Name: "srl_nokia-bridge-table-mac-duplication-entries",
	},
	{
		Name: "srl_nokia-bridge-table-mac-learning",
	},
	{
		Name: "srl_nokia-bridge-table-mac-learning-entries",
	},
	{
		Name: "srl_nokia-bridge-table-mac-limit",
	},
	{
		Name: "srl_nokia-bridge-table-mac-table",
	},
	{
		Name: "srl_nokia-bridge-table-proxy-arp-nd",
	},
	{
		Name: "srl_nokia-bridge-table-reserved-macs",
	},
	{
		Name: "srl_nokia-bridge-table-static-mac",
	},
	{
		Name: "srl_nokia-common",
	},
	{
		Name: "srl_nokia-configuration",
	},
	{
		Name: "srl_nokia-configuration-role",
	},
	{
		Name: "srl_nokia-dhcp-server",
	},
	{
		Name: "srl_nokia-dns",
	},
	{
		Name: "srl_nokia-ethcfm",
	},
	{
		Name: "srl_nokia-ethcfm-pm",
	},
	{
		Name: "srl_nokia-ethcfm-types",
	},
	{
		Name: "srl_nokia-event-handler",
	},
	{
		Name: "srl_nokia-extensions",
	},
	{
		Name: "srl_nokia-features",
	},
	{
		Name: "srl_nokia-ftp",
	},
	{
		Name: "srl_nokia-gnmi-server",
	},
	{
		Name: "srl_nokia-gribi-server",
	},
	{
		Name: "srl_nokia-icmp",
	},
	{
		Name: "srl_nokia-if-ip",
	},
	{
		Name: "srl_nokia-if-mpls",
	},
	{
		Name: "srl_nokia-igmp",
	},
	{
		Name: "srl_nokia-igmp-snooping",
	},
	{
		Name: "srl_nokia-igmp-types",
	},
	{
		Name: "srl_nokia-interfaces",
	},
	{
		Name: "srl_nokia-interfaces-bridge-table",
	},
	{
		Name: "srl_nokia-interfaces-bridge-table-mac-duplication-entries",
	},
	{
		Name: "srl_nokia-interfaces-bridge-table-mac-learning-entries",
	},
	{
		Name: "srl_nokia-interfaces-bridge-table-mac-table",
	},
	{
		Name: "srl_nokia-interfaces-bridge-table-statistics",
	},
	{
		Name: "srl_nokia-interfaces-ethernet-segment-association",
	},
	{
		Name: "srl_nokia-interfaces-ip-dhcp",
	},
	{
		Name: "srl_nokia-interfaces-ip-dhcp-relay",
	},
	{
		Name: "srl_nokia-interfaces-ip-dhcp-server",
	},
	{
		Name: "srl_nokia-interfaces-ip-vrrp",
	},
	{
		Name: "srl_nokia-interfaces-l2cp",
	},
	{
		Name: "srl_nokia-interfaces-lag",
	},
	{
		Name: "srl_nokia-interfaces-local-mirror-destination",
	},
	{
		Name: "srl_nokia-interfaces-nbr",
	},
	{
		Name: "srl_nokia-interfaces-nbr-evpn",
	},
	{
		Name: "srl_nokia-interfaces-nbr-virtual-ip-discovery",
	},
	{
		Name: "srl_nokia-interfaces-p4rt",
	},
	{
		Name: "srl_nokia-interfaces-router-adv",
	},
	{
		Name: "srl_nokia-interfaces-vlans",
	},
	{
		Name: "srl_nokia-interfaces-vxdp",
	},
	{
		Name: "srl_nokia-ip-route-tables",
	},
	{
		Name: "srl_nokia-isis",
	},
	{
		Name: "srl_nokia-json-rpc",
	},
	{
		Name: "srl_nokia-keychains",
	},
	{
		Name: "srl_nokia-lacp",
	},
	{
		Name: "srl_nokia-ldp",
	},
	{
		Name: "srl_nokia-license",
	},
	{
		Name: "srl_nokia-linux",
	},
	{
		Name: "srl_nokia-lldp",
	},
	{
		Name: "srl_nokia-lldp-types",
	},
	{
		Name: "srl_nokia-load-balancing",
	},
	{
		Name: "srl_nokia-logging",
	},
	{
		Name: "srl_nokia-macsec",
	},
	{
		Name: "srl_nokia-maintenance-mode",
	},
	{
		Name: "srl_nokia-micro-bfd",
	},
	{
		Name: "srl_nokia-mirroring",
	},
	{
		Name: "srl_nokia-mld",
	},
	{
		Name: "srl_nokia-mld-snooping",
	},
	{
		Name: "srl_nokia-mpls",
	},
	{
		Name: "srl_nokia-mpls-label-management",
	},
	{
		Name: "srl_nokia-mpls-route-tables",
	},
	{
		Name: "srl_nokia-mpls-services-evpn-label-management",
	},
	{
		Name: "srl_nokia-mtu",
	},
	{
		Name: "srl_nokia-network-instance",
	},
	{
		Name: "srl_nokia-network-instance-mtu",
	},
	{
		Name: "srl_nokia-next-hop-groups",
	},
	{
		Name: "srl_nokia-ntp",
	},
	{
		Name: "srl_nokia-oam",
	},
	{
		Name: "srl_nokia-openconfig",
	},
	{
		Name: "srl_nokia-ospf",
	},
	{
		Name: "srl_nokia-ospf-types",
	},
	{
		Name: "srl_nokia-p4rt-server",
	},
	{
		Name:         "srl_nokia-packet-match-types",
		Organization: "Nokia",
	},
	{
		Name: "srl_nokia-pim",
	},
	{
		Name: "srl_nokia-platform",
	},
	{
		Name: "srl_nokia-platform-acl",
	},
	{
		Name: "srl_nokia-platform-cgroup",
	},
	{
		Name: "srl_nokia-platform-chassis",
	},
	{
		Name: "srl_nokia-platform-control",
	},
	{
		Name: "srl_nokia-platform-cpu",
	},
	{
		Name: "srl_nokia-platform-datapath-resources",
	},
	{
		Name: "srl_nokia-platform-disk",
	},
	{
		Name: "srl_nokia-platform-fabric",
	},
	{
		Name: "srl_nokia-platform-fan",
	},
	{
		Name: "srl_nokia-platform-lc",
	},
	{
		Name: "srl_nokia-platform-memory",
	},
	{
		Name: "srl_nokia-platform-mtu",
	},
	{
		Name: "srl_nokia-platform-p4rt",
	},
	{
		Name: "srl_nokia-platform-pipeline-counters",
	},
	{
		Name: "srl_nokia-platform-psu",
	},
	{
		Name: "srl_nokia-platform-qos",
	},
	{
		Name: "srl_nokia-platform-redundancy",
	},
	{
		Name: "srl_nokia-platform-resource-mgmt",
	},
	{
		Name: "srl_nokia-platform-resource-monitoring",
	},
	{
		Name: "srl_nokia-platform-tcam",
	},
	{
		Name: "srl_nokia-platform-vxdp",
	},
	{
		Name:         "srl_nokia-policy-forwarding",
		Organization: "Nokia",
	},
	{
		Name: "srl_nokia-policy-types",
	},
	{
		Name: "srl_nokia-qos",
	},
	{
		Name: "srl_nokia-qos-policers",
	},
	{
		Name: "srl_nokia-ra_guard",
	},
	{
		Name: "srl_nokia-rib-bgp",
	},
	{
		Name: "srl_nokia-routing-policy",
	},
	{
		Name: "srl_nokia-segment-routing",
	},
	{
		Name: "srl_nokia-sflow",
	},
	{
		Name: "srl_nokia-snmp",
	},
	{
		Name: "srl_nokia-snmp-trace",
	},
	{
		Name: "srl_nokia-sr-policies",
	},
	{
		Name: "srl_nokia-ssh",
	},
	{
		Name: "srl_nokia-static-routes",
	},
	{
		Name: "srl_nokia-sync",
	},
	{
		Name: "srl_nokia-sync-freq",
	},
	{
		Name: "srl_nokia-sync-interfaces",
	},
	{
		Name: "srl_nokia-sync-ptp",
	},
	{
		Name: "srl_nokia-sync-types",
	},
	{
		Name: "srl_nokia-system",
	},
	{
		Name: "srl_nokia-system-banner",
	},
	{
		Name: "srl_nokia-system-bridge-table",
	},
	{
		Name: "srl_nokia-system-bridge-table-proxy-arp",
	},
	{
		Name: "srl_nokia-system-info",
	},
	{
		Name: "srl_nokia-system-name",
	},
	{
		Name: "srl_nokia-system-network-instance",
	},
	{
		Name: "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments",
	},
	{
		Name: "srl_nokia-system-network-instance-bgp-vpn",
	},
	{
		Name: "srl_nokia-system-reboot",
	},
	{
		Name: "srl_nokia-tcp-udp",
	},
	{
		Name:         "srl_nokia-timezone",
		Organization: "Nokia",
	},
	{
		Name: "srl_nokia-tls",
	},
	{
		Name: "srl_nokia-traffic-engineering",
	},
	{
		Name: "srl_nokia-tunnel",
	},
	{
		Name: "srl_nokia-tunnel-interfaces",
	},
	{
		Name: "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table",
	},
	{
		Name: "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations",
	},
	{
		Name: "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations",
	},
	{
		Name: "srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps",
	},
	{
		Name: "srl_nokia-tunnel-tables",
	},
	{
		Name: "srl_nokia-twamp",
	},
	{
		Name: "srl_nokia-vxlan-tunnel-vtep",
	},
}

// Device represents the /Device YANG schema element.
type Device struct {
	Acl             *SrlNokiaAcl_Acl                                     `path:"acl" module:"srl_nokia-acl"`
	Bfd             *SrlNokiaBfd_Bfd                                     `path:"bfd" module:"srl_nokia-bfd" yangPresence:"true"`
	Interface       map[string]*SrlNokiaInterfaces_Interface             `path:"interface" module:"srl_nokia-interfaces"`
	Macsec          *SrlNokiaMacsec_Macsec                               `path:"macsec" module:"srl_nokia-macsec"`
	NetworkInstance map[string]*SrlNokiaNetworkInstance_NetworkInstance  `path:"network-instance" module:"srl_nokia-network-instance"`
	Oam             *SrlNokiaOam_Oam                                     `path:"oam" module:"srl_nokia-oam"`
	Platform        *SrlNokiaPlatform_Platform                           `path:"platform" module:"srl_nokia-platform"`
	Qos             *SrlNokiaQos_Qos                                     `path:"qos" module:"srl_nokia-qos"`
	RoutingPolicy   *SrlNokiaRoutingPolicy_RoutingPolicy                 `path:"routing-policy" module:"srl_nokia-routing-policy"`
	System          *SrlNokiaSystem_System                               `path:"system" module:"srl_nokia-system"`
	Tunnel          *SrlNokiaTunnel_Tunnel                               `path:"tunnel" module:"srl_nokia-tunnel"`
	TunnelInterface map[string]*SrlNokiaTunnelInterfaces_TunnelInterface `path:"tunnel-interface" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*SrlNokiaInterfaces_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaInterfaces_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaInterfaces_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *SrlNokiaInterfaces_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *SrlNokiaInterfaces_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaInterfaces_Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *SrlNokiaInterfaces_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaInterfaces_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewNetworkInstance(Name string) (*SrlNokiaNetworkInstance_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaNetworkInstance_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateNetworkInstance(Name string) *SrlNokiaNetworkInstance_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetNetworkInstance(Name string) *SrlNokiaNetworkInstance_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaNetworkInstance_NetworkInstance struct to the
// list NetworkInstance of Device. If the key value(s) specified in
// the supplied SrlNokiaNetworkInstance_NetworkInstance already exist in the list, an error is
// returned.
func (t *Device) AppendNetworkInstance(v *SrlNokiaNetworkInstance_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// NewTunnelInterface creates a new entry in the TunnelInterface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewTunnelInterface(Name string) (*SrlNokiaTunnelInterfaces_TunnelInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelInterface == nil {
		t.TunnelInterface = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TunnelInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TunnelInterface", key)
	}

	t.TunnelInterface[key] = &SrlNokiaTunnelInterfaces_TunnelInterface{
		Name: &Name,
	}

	return t.TunnelInterface[key], nil
}

// RenameTunnelInterface renames an entry in the list TunnelInterface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameTunnelInterface(oldK, newK string) error {
	if _, ok := t.TunnelInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TunnelInterface", newK)
	}

	e, ok := t.TunnelInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TunnelInterface", oldK)
	}
	e.Name = &newK

	t.TunnelInterface[newK] = e
	delete(t.TunnelInterface, oldK)
	return nil
}

// GetOrCreateTunnelInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateTunnelInterface(Name string) *SrlNokiaTunnelInterfaces_TunnelInterface {
	key := Name

	if v, ok := t.TunnelInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnelInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnelInterface got unexpected error: %v", err))
	}
	return v
}

// GetTunnelInterface retrieves the value with the specified key from
// the TunnelInterface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetTunnelInterface(Name string) *SrlNokiaTunnelInterfaces_TunnelInterface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.TunnelInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnelInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteTunnelInterface(Name string) {
	key := Name

	delete(t.TunnelInterface, key)
}

// AppendTunnelInterface appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface struct to the
// list TunnelInterface of Device. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface already exist in the list, an error is
// returned.
func (t *Device) AppendTunnelInterface(v *SrlNokiaTunnelInterfaces_TunnelInterface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelInterface == nil {
		t.TunnelInterface = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface)
	}

	if _, ok := t.TunnelInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TunnelInterface %v", key)
	}

	t.TunnelInterface[key] = v
	return nil
}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateAcl() *SrlNokiaAcl_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &SrlNokiaAcl_Acl{}
	return t.Acl
}

// GetOrCreateBfd retrieves the value of the Bfd field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateBfd() *SrlNokiaBfd_Bfd {
	if t.Bfd != nil {
		return t.Bfd
	}
	t.Bfd = &SrlNokiaBfd_Bfd{}
	return t.Bfd
}

// GetOrCreateMacsec retrieves the value of the Macsec field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateMacsec() *SrlNokiaMacsec_Macsec {
	if t.Macsec != nil {
		return t.Macsec
	}
	t.Macsec = &SrlNokiaMacsec_Macsec{}
	return t.Macsec
}

// GetOrCreateOam retrieves the value of the Oam field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateOam() *SrlNokiaOam_Oam {
	if t.Oam != nil {
		return t.Oam
	}
	t.Oam = &SrlNokiaOam_Oam{}
	return t.Oam
}

// GetOrCreatePlatform retrieves the value of the Platform field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreatePlatform() *SrlNokiaPlatform_Platform {
	if t.Platform != nil {
		return t.Platform
	}
	t.Platform = &SrlNokiaPlatform_Platform{}
	return t.Platform
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateQos() *SrlNokiaQos_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &SrlNokiaQos_Qos{}
	return t.Qos
}

// GetOrCreateRoutingPolicy retrieves the value of the RoutingPolicy field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateRoutingPolicy() *SrlNokiaRoutingPolicy_RoutingPolicy {
	if t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	t.RoutingPolicy = &SrlNokiaRoutingPolicy_RoutingPolicy{}
	return t.RoutingPolicy
}

// GetOrCreateSystem retrieves the value of the System field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateSystem() *SrlNokiaSystem_System {
	if t.System != nil {
		return t.System
	}
	t.System = &SrlNokiaSystem_System{}
	return t.System
}

// GetOrCreateTunnel retrieves the value of the Tunnel field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateTunnel() *SrlNokiaTunnel_Tunnel {
	if t.Tunnel != nil {
		return t.Tunnel
	}
	t.Tunnel = &SrlNokiaTunnel_Tunnel{}
	return t.Tunnel
}

// GetAcl returns the value of the Acl struct pointer
// from Device. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetAcl() *SrlNokiaAcl_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetBfd returns the value of the Bfd struct pointer
// from Device. If the receiver or the field Bfd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetBfd() *SrlNokiaBfd_Bfd {
	if t != nil && t.Bfd != nil {
		return t.Bfd
	}
	return nil
}

// GetMacsec returns the value of the Macsec struct pointer
// from Device. If the receiver or the field Macsec is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetMacsec() *SrlNokiaMacsec_Macsec {
	if t != nil && t.Macsec != nil {
		return t.Macsec
	}
	return nil
}

// GetOam returns the value of the Oam struct pointer
// from Device. If the receiver or the field Oam is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetOam() *SrlNokiaOam_Oam {
	if t != nil && t.Oam != nil {
		return t.Oam
	}
	return nil
}

// GetPlatform returns the value of the Platform struct pointer
// from Device. If the receiver or the field Platform is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetPlatform() *SrlNokiaPlatform_Platform {
	if t != nil && t.Platform != nil {
		return t.Platform
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from Device. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetQos() *SrlNokiaQos_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetRoutingPolicy returns the value of the RoutingPolicy struct pointer
// from Device. If the receiver or the field RoutingPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetRoutingPolicy() *SrlNokiaRoutingPolicy_RoutingPolicy {
	if t != nil && t.RoutingPolicy != nil {
		return t.RoutingPolicy
	}
	return nil
}

// GetSystem returns the value of the System struct pointer
// from Device. If the receiver or the field System is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetSystem() *SrlNokiaSystem_System {
	if t != nil && t.System != nil {
		return t.System
	}
	return nil
}

// GetTunnel returns the value of the Tunnel struct pointer
// from Device. If the receiver or the field Tunnel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetTunnel() *SrlNokiaTunnel_Tunnel {
	if t != nil && t.Tunnel != nil {
		return t.Tunnel
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Device
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Device) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Acl.PopulateDefaults()
	t.Bfd.PopulateDefaults()
	t.Macsec.PopulateDefaults()
	t.Oam.PopulateDefaults()
	t.Platform.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.RoutingPolicy.PopulateDefaults()
	t.System.PopulateDefaults()
	t.Tunnel.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
	for _, e := range t.TunnelInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}

// SrlNokiaAcl_Acl represents the /srl_nokia-acl/acl YANG schema element.
type SrlNokiaAcl_Acl struct {
	CaptureFilter      *SrlNokiaAcl_Acl_CaptureFilter         `path:"capture-filter" module:"srl_nokia-acl"`
	CpmFilter          *SrlNokiaAcl_Acl_CpmFilter             `path:"cpm-filter" module:"srl_nokia-acl"`
	EgressMacFiltering *bool                                  `path:"egress-mac-filtering" module:"srl_nokia-acl"`
	Ipv4Filter         map[string]*SrlNokiaAcl_Acl_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter         map[string]*SrlNokiaAcl_Acl_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter          map[string]*SrlNokiaAcl_Acl_MacFilter  `path:"mac-filter" module:"srl_nokia-acl"`
	Policers           *SrlNokiaAcl_Acl_Policers              `path:"policers" module:"srl_nokia-acl"`
	SystemFilter       *SrlNokiaAcl_Acl_SystemFilter          `path:"system-filter" module:"srl_nokia-acl"`
	TcamProfile        E_SrlNokiaAcl_Acl_TcamProfile          `path:"tcam-profile" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl) IsYANGGoStruct() {}

// NewIpv4Filter creates a new entry in the Ipv4Filter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewIpv4Filter(Name string) (*SrlNokiaAcl_Acl_Ipv4Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Filter == nil {
		t.Ipv4Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv4Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Filter", key)
	}

	t.Ipv4Filter[key] = &SrlNokiaAcl_Acl_Ipv4Filter{
		Name: &Name,
	}

	return t.Ipv4Filter[key], nil
}

// RenameIpv4Filter renames an entry in the list Ipv4Filter within
// the SrlNokiaAcl_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl) RenameIpv4Filter(oldK, newK string) error {
	if _, ok := t.Ipv4Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Filter", newK)
	}

	e, ok := t.Ipv4Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Filter", oldK)
	}
	e.Name = &newK

	t.Ipv4Filter[newK] = e
	delete(t.Ipv4Filter, oldK)
	return nil
}

// GetOrCreateIpv4Filter retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl) GetOrCreateIpv4Filter(Name string) *SrlNokiaAcl_Acl_Ipv4Filter {
	key := Name

	if v, ok := t.Ipv4Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Filter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Filter got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Filter retrieves the value with the specified key from
// the Ipv4Filter map field of SrlNokiaAcl_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl) GetIpv4Filter(Name string) *SrlNokiaAcl_Acl_Ipv4Filter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv4Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Filter deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl) DeleteIpv4Filter(Name string) {
	key := Name

	delete(t.Ipv4Filter, key)
}

// AppendIpv4Filter appends the supplied SrlNokiaAcl_Acl_Ipv4Filter struct to the
// list Ipv4Filter of SrlNokiaAcl_Acl. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Ipv4Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl) AppendIpv4Filter(v *SrlNokiaAcl_Acl_Ipv4Filter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Filter == nil {
		t.Ipv4Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv4Filter)
	}

	if _, ok := t.Ipv4Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Filter %v", key)
	}

	t.Ipv4Filter[key] = v
	return nil
}

// NewIpv6Filter creates a new entry in the Ipv6Filter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewIpv6Filter(Name string) (*SrlNokiaAcl_Acl_Ipv6Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Filter == nil {
		t.Ipv6Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv6Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Filter", key)
	}

	t.Ipv6Filter[key] = &SrlNokiaAcl_Acl_Ipv6Filter{
		Name: &Name,
	}

	return t.Ipv6Filter[key], nil
}

// RenameIpv6Filter renames an entry in the list Ipv6Filter within
// the SrlNokiaAcl_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl) RenameIpv6Filter(oldK, newK string) error {
	if _, ok := t.Ipv6Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Filter", newK)
	}

	e, ok := t.Ipv6Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Filter", oldK)
	}
	e.Name = &newK

	t.Ipv6Filter[newK] = e
	delete(t.Ipv6Filter, oldK)
	return nil
}

// GetOrCreateIpv6Filter retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl) GetOrCreateIpv6Filter(Name string) *SrlNokiaAcl_Acl_Ipv6Filter {
	key := Name

	if v, ok := t.Ipv6Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Filter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Filter got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Filter retrieves the value with the specified key from
// the Ipv6Filter map field of SrlNokiaAcl_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl) GetIpv6Filter(Name string) *SrlNokiaAcl_Acl_Ipv6Filter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv6Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Filter deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl) DeleteIpv6Filter(Name string) {
	key := Name

	delete(t.Ipv6Filter, key)
}

// AppendIpv6Filter appends the supplied SrlNokiaAcl_Acl_Ipv6Filter struct to the
// list Ipv6Filter of SrlNokiaAcl_Acl. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Ipv6Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl) AppendIpv6Filter(v *SrlNokiaAcl_Acl_Ipv6Filter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Filter == nil {
		t.Ipv6Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv6Filter)
	}

	if _, ok := t.Ipv6Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Filter %v", key)
	}

	t.Ipv6Filter[key] = v
	return nil
}

// NewMacFilter creates a new entry in the MacFilter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewMacFilter(Name string) (*SrlNokiaAcl_Acl_MacFilter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacFilter == nil {
		t.MacFilter = make(map[string]*SrlNokiaAcl_Acl_MacFilter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MacFilter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MacFilter", key)
	}

	t.MacFilter[key] = &SrlNokiaAcl_Acl_MacFilter{
		Name: &Name,
	}

	return t.MacFilter[key], nil
}

// RenameMacFilter renames an entry in the list MacFilter within
// the SrlNokiaAcl_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl) RenameMacFilter(oldK, newK string) error {
	if _, ok := t.MacFilter[newK]; ok {
		return fmt.Errorf("key %v already exists in MacFilter", newK)
	}

	e, ok := t.MacFilter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MacFilter", oldK)
	}
	e.Name = &newK

	t.MacFilter[newK] = e
	delete(t.MacFilter, oldK)
	return nil
}

// GetOrCreateMacFilter retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl) GetOrCreateMacFilter(Name string) *SrlNokiaAcl_Acl_MacFilter {
	key := Name

	if v, ok := t.MacFilter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacFilter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacFilter got unexpected error: %v", err))
	}
	return v
}

// GetMacFilter retrieves the value with the specified key from
// the MacFilter map field of SrlNokiaAcl_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl) GetMacFilter(Name string) *SrlNokiaAcl_Acl_MacFilter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.MacFilter[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacFilter deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl) DeleteMacFilter(Name string) {
	key := Name

	delete(t.MacFilter, key)
}

// AppendMacFilter appends the supplied SrlNokiaAcl_Acl_MacFilter struct to the
// list MacFilter of SrlNokiaAcl_Acl. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_MacFilter already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl) AppendMacFilter(v *SrlNokiaAcl_Acl_MacFilter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MacFilter == nil {
		t.MacFilter = make(map[string]*SrlNokiaAcl_Acl_MacFilter)
	}

	if _, ok := t.MacFilter[key]; ok {
		return fmt.Errorf("duplicate key for list MacFilter %v", key)
	}

	t.MacFilter[key] = v
	return nil
}

// GetOrCreateCaptureFilter retrieves the value of the CaptureFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreateCaptureFilter() *SrlNokiaAcl_Acl_CaptureFilter {
	if t.CaptureFilter != nil {
		return t.CaptureFilter
	}
	t.CaptureFilter = &SrlNokiaAcl_Acl_CaptureFilter{}
	return t.CaptureFilter
}

// GetOrCreateCpmFilter retrieves the value of the CpmFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreateCpmFilter() *SrlNokiaAcl_Acl_CpmFilter {
	if t.CpmFilter != nil {
		return t.CpmFilter
	}
	t.CpmFilter = &SrlNokiaAcl_Acl_CpmFilter{}
	return t.CpmFilter
}

// GetOrCreatePolicers retrieves the value of the Policers field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreatePolicers() *SrlNokiaAcl_Acl_Policers {
	if t.Policers != nil {
		return t.Policers
	}
	t.Policers = &SrlNokiaAcl_Acl_Policers{}
	return t.Policers
}

// GetOrCreateSystemFilter retrieves the value of the SystemFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl) GetOrCreateSystemFilter() *SrlNokiaAcl_Acl_SystemFilter {
	if t.SystemFilter != nil {
		return t.SystemFilter
	}
	t.SystemFilter = &SrlNokiaAcl_Acl_SystemFilter{}
	return t.SystemFilter
}

// GetCaptureFilter returns the value of the CaptureFilter struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field CaptureFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetCaptureFilter() *SrlNokiaAcl_Acl_CaptureFilter {
	if t != nil && t.CaptureFilter != nil {
		return t.CaptureFilter
	}
	return nil
}

// GetCpmFilter returns the value of the CpmFilter struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field CpmFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetCpmFilter() *SrlNokiaAcl_Acl_CpmFilter {
	if t != nil && t.CpmFilter != nil {
		return t.CpmFilter
	}
	return nil
}

// GetPolicers returns the value of the Policers struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field Policers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetPolicers() *SrlNokiaAcl_Acl_Policers {
	if t != nil && t.Policers != nil {
		return t.Policers
	}
	return nil
}

// GetSystemFilter returns the value of the SystemFilter struct pointer
// from SrlNokiaAcl_Acl. If the receiver or the field SystemFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl) GetSystemFilter() *SrlNokiaAcl_Acl_SystemFilter {
	if t != nil && t.SystemFilter != nil {
		return t.SystemFilter
	}
	return nil
}

// GetEgressMacFiltering retrieves the value of the leaf EgressMacFiltering from the SrlNokiaAcl_Acl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EgressMacFiltering is set, it can
// safely use t.GetEgressMacFiltering() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EgressMacFiltering == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl) GetEgressMacFiltering() bool {
	if t == nil || t.EgressMacFiltering == nil {
		return false
	}
	return *t.EgressMacFiltering
}

// GetTcamProfile retrieves the value of the leaf TcamProfile from the SrlNokiaAcl_Acl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcamProfile is set, it can
// safely use t.GetTcamProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcamProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl) GetTcamProfile() E_SrlNokiaAcl_Acl_TcamProfile {
	if t == nil || t.TcamProfile == 0 {
		return 0
	}
	return t.TcamProfile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EgressMacFiltering == nil {
		var v bool = false
		t.EgressMacFiltering = &v
	}
	t.CaptureFilter.PopulateDefaults()
	t.CpmFilter.PopulateDefaults()
	t.Policers.PopulateDefaults()
	t.SystemFilter.PopulateDefaults()
	for _, e := range t.Ipv4Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.MacFilter {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl.
func (*SrlNokiaAcl_Acl) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter represents the /srl_nokia-acl/acl/capture-filter YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter struct {
	Ipv4Filter *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter) IsYANGGoStruct() {}

// GetOrCreateIpv4Filter retrieves the value of the Ipv4Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetOrCreateIpv4Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter {
	if t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	t.Ipv4Filter = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter{}
	return t.Ipv4Filter
}

// GetOrCreateIpv6Filter retrieves the value of the Ipv6Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetOrCreateIpv6Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter {
	if t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	t.Ipv6Filter = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter{}
	return t.Ipv6Filter
}

// GetIpv4Filter returns the value of the Ipv4Filter struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter. If the receiver or the field Ipv4Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetIpv4Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter {
	if t != nil && t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	return nil
}

// GetIpv6Filter returns the value of the Ipv6Filter struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter. If the receiver or the field Ipv6Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter) GetIpv6Filter() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter {
	if t != nil && t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4Filter.PopulateDefaults()
	t.Ipv6Filter.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter.
func (*SrlNokiaAcl_Acl_CaptureFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter struct {
	Entry map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry `path:"entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) AppendEntry(v *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                                `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                                `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Copy   *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy   `path:"copy" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateCopy retrieves the value of the Copy field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetOrCreateCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy {
	if t.Copy != nil {
		return t.Copy
	}
	t.Copy = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy{}
	return t.Copy
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetCopy returns the value of the Copy struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action. If the receiver or the field Copy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) GetCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy {
	if t != nil && t.Copy != nil {
		return t.Copy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Copy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/action/copy YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	FirstFragment   *bool                                                                 `path:"first-fragment" module:"srl_nokia-acl"`
	Fragment        *bool                                                                 `path:"fragment" module:"srl_nokia-acl"`
	Icmp            *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp            `path:"icmp" module:"srl_nokia-acl"`
	Protocol        SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Protocol_Union   `path:"protocol" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                               `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateIcmp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetIcmp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetFirstFragment retrieves the value of the leaf FirstFragment from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirstFragment is set, it can
// safely use t.GetFirstFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirstFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetFirstFragment() bool {
	if t == nil || t.FirstFragment == nil {
		return false
	}
	return *t.FirstFragment
}

// GetFragment retrieves the value of the leaf Fragment from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetFragment() bool {
	if t == nil || t.Fragment == nil {
		return false
	}
	return *t.Fragment
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetProtocol() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                              `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/icmp YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp struct {
	Code []uint8                                                              `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) GetType() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                         `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv4-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter struct {
	Entry map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry `path:"entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) AppendEntry(v *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                                `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                                `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Copy   *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy   `path:"copy" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateCopy retrieves the value of the Copy field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetOrCreateCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy {
	if t.Copy != nil {
		return t.Copy
	}
	t.Copy = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy{}
	return t.Copy
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetCopy returns the value of the Copy struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action. If the receiver or the field Copy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) GetCopy() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy {
	if t != nil && t.Copy != nil {
		return t.Copy
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Copy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/action/copy YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	Icmp6           *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl"`
	NextHeader      SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                               `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateIcmp6() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetIcmp6() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetNextHeader() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                              `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/icmp6 YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 struct {
	Code []uint8                                                               `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) GetType() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                         `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/capture-filter/ipv6-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter represents the /srl_nokia-acl/acl/cpm-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter struct {
	Ipv4Filter *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter  *SrlNokiaAcl_Acl_CpmFilter_MacFilter  `path:"mac-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter) IsYANGGoStruct() {}

// GetOrCreateIpv4Filter retrieves the value of the Ipv4Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetOrCreateIpv4Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter {
	if t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	t.Ipv4Filter = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter{}
	return t.Ipv4Filter
}

// GetOrCreateIpv6Filter retrieves the value of the Ipv6Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetOrCreateIpv6Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter {
	if t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	t.Ipv6Filter = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter{}
	return t.Ipv6Filter
}

// GetOrCreateMacFilter retrieves the value of the MacFilter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetOrCreateMacFilter() *SrlNokiaAcl_Acl_CpmFilter_MacFilter {
	if t.MacFilter != nil {
		return t.MacFilter
	}
	t.MacFilter = &SrlNokiaAcl_Acl_CpmFilter_MacFilter{}
	return t.MacFilter
}

// GetIpv4Filter returns the value of the Ipv4Filter struct pointer
// from SrlNokiaAcl_Acl_CpmFilter. If the receiver or the field Ipv4Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetIpv4Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter {
	if t != nil && t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	return nil
}

// GetIpv6Filter returns the value of the Ipv6Filter struct pointer
// from SrlNokiaAcl_Acl_CpmFilter. If the receiver or the field Ipv6Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetIpv6Filter() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter {
	if t != nil && t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	return nil
}

// GetMacFilter returns the value of the MacFilter struct pointer
// from SrlNokiaAcl_Acl_CpmFilter. If the receiver or the field MacFilter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter) GetMacFilter() *SrlNokiaAcl_Acl_CpmFilter_MacFilter {
	if t != nil && t.MacFilter != nil {
		return t.MacFilter
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4Filter.PopulateDefaults()
	t.Ipv6Filter.PopulateDefaults()
	t.MacFilter.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter.
func (*SrlNokiaAcl_Acl_CpmFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter struct {
	Entry              map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry `path:"entry" module:"srl_nokia-acl"`
	StatisticsPerEntry *bool                                                  `path:"statistics-per-entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) AppendEntry(v *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                            `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                            `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept struct {
	Log       *bool                                                               `path:"log" module:"srl_nokia-acl"`
	RateLimit *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit `path:"rate-limit" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) GetOrCreateRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit{}
	return t.RateLimit
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) GetRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
	t.RateLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action/accept/rate-limit YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit struct {
	DistributedPolicer *string `path:"distributed-policer" module:"srl_nokia-acl"`
	SystemCpuPolicer   *string `path:"system-cpu-policer" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) IsYANGGoStruct() {}

// GetDistributedPolicer retrieves the value of the leaf DistributedPolicer from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DistributedPolicer is set, it can
// safely use t.GetDistributedPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DistributedPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) GetDistributedPolicer() string {
	if t == nil || t.DistributedPolicer == nil {
		return ""
	}
	return *t.DistributedPolicer
}

// GetSystemCpuPolicer retrieves the value of the leaf SystemCpuPolicer from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemCpuPolicer is set, it can
// safely use t.GetSystemCpuPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemCpuPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) GetSystemCpuPolicer() string {
	if t == nil || t.SystemCpuPolicer == nil {
		return ""
	}
	return *t.SystemCpuPolicer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	FirstFragment   *bool                                                             `path:"first-fragment" module:"srl_nokia-acl"`
	Fragment        *bool                                                             `path:"fragment" module:"srl_nokia-acl"`
	Icmp            *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp            `path:"icmp" module:"srl_nokia-acl"`
	Protocol        SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Protocol_Union   `path:"protocol" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                           `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateIcmp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetIcmp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetFirstFragment retrieves the value of the leaf FirstFragment from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirstFragment is set, it can
// safely use t.GetFirstFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirstFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetFirstFragment() bool {
	if t == nil || t.FirstFragment == nil {
		return false
	}
	return *t.FirstFragment
}

// GetFragment retrieves the value of the leaf Fragment from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetFragment() bool {
	if t == nil || t.Fragment == nil {
		return false
	}
	return *t.Fragment
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetProtocol() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                          `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/icmp YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp struct {
	Code []uint8                                                          `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) GetType() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                     `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv4-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter struct {
	Entry              map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry `path:"entry" module:"srl_nokia-acl"`
	StatisticsPerEntry *bool                                                  `path:"statistics-per-entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) AppendEntry(v *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                            `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                            `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetAction() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept struct {
	Log       *bool                                                               `path:"log" module:"srl_nokia-acl"`
	RateLimit *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit `path:"rate-limit" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) GetOrCreateRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit{}
	return t.RateLimit
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) GetRateLimit() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
	t.RateLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action/accept/rate-limit YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit struct {
	DistributedPolicer *string `path:"distributed-policer" module:"srl_nokia-acl"`
	SystemCpuPolicer   *string `path:"system-cpu-policer" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) IsYANGGoStruct() {}

// GetDistributedPolicer retrieves the value of the leaf DistributedPolicer from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DistributedPolicer is set, it can
// safely use t.GetDistributedPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DistributedPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) GetDistributedPolicer() string {
	if t == nil || t.DistributedPolicer == nil {
		return ""
	}
	return *t.DistributedPolicer
}

// GetSystemCpuPolicer retrieves the value of the leaf SystemCpuPolicer from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemCpuPolicer is set, it can
// safely use t.GetSystemCpuPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemCpuPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) GetSystemCpuPolicer() string {
	if t == nil || t.SystemCpuPolicer == nil {
		return ""
	}
	return *t.SystemCpuPolicer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	Icmp6           *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl"`
	NextHeader      SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                           `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateIcmp6() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetIcmp6() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetNextHeader() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                          `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/icmp6 YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 struct {
	Code []uint8                                                           `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) GetType() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                     `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/cpm-filter/ipv6-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter represents the /srl_nokia-acl/acl/cpm-filter/mac-filter YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter struct {
	Entry              map[uint32]*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry `path:"entry" module:"srl_nokia-acl"`
	StatisticsPerEntry *bool                                                 `path:"statistics-per-entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_MacFilter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_CpmFilter_MacFilter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_MacFilter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_CpmFilter_MacFilter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_CpmFilter_MacFilter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_CpmFilter_MacFilter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) AppendEntry(v *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_CpmFilter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry struct {
	Action      *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                           `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                           `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetAction() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetMatch() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept struct {
	Log       *bool                                                              `path:"log" module:"srl_nokia-acl"`
	RateLimit *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit `path:"rate-limit" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) GetOrCreateRateLimit() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit{}
	return t.RateLimit
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) GetRateLimit() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
	t.RateLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action/accept/rate-limit YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit struct {
	DistributedPolicer *string `path:"distributed-policer" module:"srl_nokia-acl"`
	SystemCpuPolicer   *string `path:"system-cpu-policer" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) IsYANGGoStruct() {}

// GetDistributedPolicer retrieves the value of the leaf DistributedPolicer from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DistributedPolicer is set, it can
// safely use t.GetDistributedPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DistributedPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) GetDistributedPolicer() string {
	if t == nil || t.DistributedPolicer == nil {
		return ""
	}
	return *t.DistributedPolicer
}

// GetSystemCpuPolicer retrieves the value of the leaf SystemCpuPolicer from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemCpuPolicer is set, it can
// safely use t.GetSystemCpuPolicer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemCpuPolicer == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) GetSystemCpuPolicer() string {
	if t == nil || t.SystemCpuPolicer == nil {
		return ""
	}
	return *t.SystemCpuPolicer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Accept_RateLimit) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match struct {
	DestinationMac *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac `path:"destination-mac" module:"srl_nokia-acl"`
	Ethertype      SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Ethertype_Union `path:"ethertype" module:"srl_nokia-acl"`
	SourceMac      *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac      `path:"source-mac" module:"srl_nokia-acl"`
	Vlan           *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan           `path:"vlan" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationMac retrieves the value of the DestinationMac field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetOrCreateDestinationMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac {
	if t.DestinationMac != nil {
		return t.DestinationMac
	}
	t.DestinationMac = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac{}
	return t.DestinationMac
}

// GetOrCreateSourceMac retrieves the value of the SourceMac field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetOrCreateSourceMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac {
	if t.SourceMac != nil {
		return t.SourceMac
	}
	t.SourceMac = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac{}
	return t.SourceMac
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetOrCreateVlan() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan{}
	return t.Vlan
}

// GetDestinationMac returns the value of the DestinationMac struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match. If the receiver or the field DestinationMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetDestinationMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac {
	if t != nil && t.DestinationMac != nil {
		return t.DestinationMac
	}
	return nil
}

// GetSourceMac returns the value of the SourceMac struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match. If the receiver or the field SourceMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetSourceMac() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac {
	if t != nil && t.SourceMac != nil {
		return t.SourceMac
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetVlan() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetEthertype retrieves the value of the leaf Ethertype from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ethertype is set, it can
// safely use t.GetEthertype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ethertype == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) GetEthertype() SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Ethertype_Union {
	if t == nil || t.Ethertype == nil {
		return nil
	}
	return t.Ethertype
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationMac.PopulateDefaults()
	t.SourceMac.PopulateDefaults()
	t.Vlan.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match/destination-mac YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_DestinationMac) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match/source-mac YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_SourceMac) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match/vlan YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan struct {
	OutermostVlanId *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId `path:"outermost-vlan-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) IsYANGGoStruct() {}

// GetOrCreateOutermostVlanId retrieves the value of the OutermostVlanId field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) GetOrCreateOutermostVlanId() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId {
	if t.OutermostVlanId != nil {
		return t.OutermostVlanId
	}
	t.OutermostVlanId = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId{}
	return t.OutermostVlanId
}

// GetOutermostVlanId returns the value of the OutermostVlanId struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan. If the receiver or the field OutermostVlanId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) GetOutermostVlanId() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId {
	if t != nil && t.OutermostVlanId != nil {
		return t.OutermostVlanId
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.OutermostVlanId.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match/vlan/outermost-vlan-id YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId struct {
	None     YANGEmpty                                                                   `path:"none" module:"srl_nokia-acl"`
	Operator E_SrlNokiaPacketMatchTypes_Operator                                         `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range `path:"range" module:"srl_nokia-acl"`
	Value    *uint16                                                                     `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetOrCreateRange() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetRange() *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetNone retrieves the value of the leaf None from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if None is set, it can
// safely use t.GetNone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.None == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetNone() YANGEmpty {
	if t == nil || t.None == false {
		return false
	}
	return t.None
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetValue() uint16 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range represents the /srl_nokia-acl/acl/cpm-filter/mac-filter/entry/match/vlan/outermost-vlan-id/range YANG schema element.
type SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range struct {
	End   *uint16 `path:"end" module:"srl_nokia-acl"`
	Start *uint16 `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range.
func (*SrlNokiaAcl_Acl_CpmFilter_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter represents the /srl_nokia-acl/acl/ipv4-filter YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter struct {
	Description          *string                                           `path:"description" module:"srl_nokia-acl"`
	Entry                map[uint32]*SrlNokiaAcl_Acl_Ipv4Filter_Entry      `path:"entry" module:"srl_nokia-acl"`
	Name                 *string                                           `path:"name" module:"srl_nokia-acl"`
	StatisticsPerEntry   *bool                                             `path:"statistics-per-entry" module:"srl_nokia-acl"`
	SubinterfaceSpecific E_SrlNokiaAcl_Acl_Ipv4Filter_SubinterfaceSpecific `path:"subinterface-specific" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_Ipv4Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_Ipv4Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Ipv4Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_Ipv4Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_Ipv4Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_Ipv4Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Ipv4Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_Ipv4Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_Ipv4Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Ipv4Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) AppendEntry(v *SrlNokiaAcl_Acl_Ipv4Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_Ipv4Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_Ipv4Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaAcl_Acl_Ipv4Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_Ipv4Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// GetSubinterfaceSpecific retrieves the value of the leaf SubinterfaceSpecific from the SrlNokiaAcl_Acl_Ipv4Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubinterfaceSpecific is set, it can
// safely use t.GetSubinterfaceSpecific() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubinterfaceSpecific == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) GetSubinterfaceSpecific() E_SrlNokiaAcl_Acl_Ipv4Filter_SubinterfaceSpecific {
	if t == nil || t.SubinterfaceSpecific == 0 {
		return SrlNokiaAcl_Acl_Ipv4Filter_SubinterfaceSpecific_disabled
	}
	return t.SubinterfaceSpecific
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SubinterfaceSpecific == 0 {
		t.SubinterfaceSpecific = SrlNokiaAcl_Acl_Ipv4Filter_SubinterfaceSpecific_disabled
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv4Filter struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter.
func (*SrlNokiaAcl_Acl_Ipv4Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry represents the /srl_nokia-acl/acl/ipv4-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                  `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                  `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) GetAction() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action represents the /srl_nokia-acl/acl/ipv4-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/ipv4-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/ipv4-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match represents the /srl_nokia-acl/acl/ipv4-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	FirstFragment   *bool                                                   `path:"first-fragment" module:"srl_nokia-acl"`
	Fragment        *bool                                                   `path:"fragment" module:"srl_nokia-acl"`
	Icmp            *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp            `path:"icmp" module:"srl_nokia-acl"`
	Protocol        SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Protocol_Union   `path:"protocol" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                 `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetOrCreateIcmp() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetIcmp() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetFirstFragment retrieves the value of the leaf FirstFragment from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirstFragment is set, it can
// safely use t.GetFirstFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirstFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetFirstFragment() bool {
	if t == nil || t.FirstFragment == nil {
		return false
	}
	return *t.FirstFragment
}

// GetFragment retrieves the value of the leaf Fragment from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetFragment() bool {
	if t == nil || t.Fragment == nil {
		return false
	}
	return *t.Fragment
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetProtocol() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/ipv4-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/ipv4-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/ipv4-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp represents the /srl_nokia-acl/acl/ipv4-filter/entry/match/icmp YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp struct {
	Code []uint8                                                `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) GetType() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/ipv4-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/ipv4-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                           `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/ipv4-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter represents the /srl_nokia-acl/acl/ipv6-filter YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter struct {
	Description          *string                                           `path:"description" module:"srl_nokia-acl"`
	Entry                map[uint32]*SrlNokiaAcl_Acl_Ipv6Filter_Entry      `path:"entry" module:"srl_nokia-acl"`
	Name                 *string                                           `path:"name" module:"srl_nokia-acl"`
	StatisticsPerEntry   *bool                                             `path:"statistics-per-entry" module:"srl_nokia-acl"`
	SubinterfaceSpecific E_SrlNokiaAcl_Acl_Ipv6Filter_SubinterfaceSpecific `path:"subinterface-specific" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_Ipv6Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_Ipv6Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_Ipv6Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_Ipv6Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_Ipv6Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) AppendEntry(v *SrlNokiaAcl_Acl_Ipv6Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaAcl_Acl_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// GetSubinterfaceSpecific retrieves the value of the leaf SubinterfaceSpecific from the SrlNokiaAcl_Acl_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubinterfaceSpecific is set, it can
// safely use t.GetSubinterfaceSpecific() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubinterfaceSpecific == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) GetSubinterfaceSpecific() E_SrlNokiaAcl_Acl_Ipv6Filter_SubinterfaceSpecific {
	if t == nil || t.SubinterfaceSpecific == 0 {
		return SrlNokiaAcl_Acl_Ipv6Filter_SubinterfaceSpecific_disabled
	}
	return t.SubinterfaceSpecific
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SubinterfaceSpecific == 0 {
		t.SubinterfaceSpecific = SrlNokiaAcl_Acl_Ipv6Filter_SubinterfaceSpecific_disabled
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv6Filter struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter.
func (*SrlNokiaAcl_Acl_Ipv6Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry represents the /srl_nokia-acl/acl/ipv6-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                  `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                  `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) GetAction() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action represents the /srl_nokia-acl/acl/ipv6-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/ipv6-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/ipv6-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match represents the /srl_nokia-acl/acl/ipv6-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	Icmp6           *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl"`
	NextHeader      SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                 `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetOrCreateIcmp6() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetIcmp6() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetNextHeader() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/ipv6-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/ipv6-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/ipv6-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6 represents the /srl_nokia-acl/acl/ipv6-filter/entry/match/icmp6 YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6 struct {
	Code []uint8                                                 `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) GetType() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/ipv6-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/ipv6-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                           `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/ipv6-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter represents the /srl_nokia-acl/acl/mac-filter YANG schema element.
type SrlNokiaAcl_Acl_MacFilter struct {
	Description          *string                                          `path:"description" module:"srl_nokia-acl"`
	Entry                map[uint32]*SrlNokiaAcl_Acl_MacFilter_Entry      `path:"entry" module:"srl_nokia-acl"`
	Name                 *string                                          `path:"name" module:"srl_nokia-acl"`
	StatisticsPerEntry   *bool                                            `path:"statistics-per-entry" module:"srl_nokia-acl"`
	SubinterfaceSpecific E_SrlNokiaAcl_Acl_MacFilter_SubinterfaceSpecific `path:"subinterface-specific" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_MacFilter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_MacFilter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_MacFilter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_MacFilter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_MacFilter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_MacFilter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_MacFilter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_MacFilter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_MacFilter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_MacFilter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_MacFilter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_MacFilter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_MacFilter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_MacFilter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_MacFilter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_MacFilter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_MacFilter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_MacFilter) AppendEntry(v *SrlNokiaAcl_Acl_MacFilter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_MacFilter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaAcl_Acl_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetStatisticsPerEntry retrieves the value of the leaf StatisticsPerEntry from the SrlNokiaAcl_Acl_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StatisticsPerEntry is set, it can
// safely use t.GetStatisticsPerEntry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StatisticsPerEntry == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter) GetStatisticsPerEntry() bool {
	if t == nil || t.StatisticsPerEntry == nil {
		return false
	}
	return *t.StatisticsPerEntry
}

// GetSubinterfaceSpecific retrieves the value of the leaf SubinterfaceSpecific from the SrlNokiaAcl_Acl_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubinterfaceSpecific is set, it can
// safely use t.GetSubinterfaceSpecific() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubinterfaceSpecific == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter) GetSubinterfaceSpecific() E_SrlNokiaAcl_Acl_MacFilter_SubinterfaceSpecific {
	if t == nil || t.SubinterfaceSpecific == 0 {
		return SrlNokiaAcl_Acl_MacFilter_SubinterfaceSpecific_disabled
	}
	return t.SubinterfaceSpecific
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SubinterfaceSpecific == 0 {
		t.SubinterfaceSpecific = SrlNokiaAcl_Acl_MacFilter_SubinterfaceSpecific_disabled
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_MacFilter struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_MacFilter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter.
func (*SrlNokiaAcl_Acl_MacFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry represents the /srl_nokia-acl/acl/mac-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry struct {
	Action      *SrlNokiaAcl_Acl_MacFilter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                 `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_MacFilter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                 `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_MacFilter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_MacFilter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_MacFilter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_MacFilter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) GetAction() *SrlNokiaAcl_Acl_MacFilter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) GetMatch() *SrlNokiaAcl_Acl_MacFilter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_MacFilter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry.
func (*SrlNokiaAcl_Acl_MacFilter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Action represents the /srl_nokia-acl/acl/mac-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Action.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept represents the /srl_nokia-acl/acl/mac-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop represents the /srl_nokia-acl/acl/mac-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Match represents the /srl_nokia-acl/acl/mac-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Match struct {
	DestinationMac *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac `path:"destination-mac" module:"srl_nokia-acl"`
	Ethertype      SrlNokiaAcl_Acl_MacFilter_Entry_Match_Ethertype_Union `path:"ethertype" module:"srl_nokia-acl"`
	SourceMac      *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac      `path:"source-mac" module:"srl_nokia-acl"`
	Vlan           *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan           `path:"vlan" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationMac retrieves the value of the DestinationMac field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) GetOrCreateDestinationMac() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac {
	if t.DestinationMac != nil {
		return t.DestinationMac
	}
	t.DestinationMac = &SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac{}
	return t.DestinationMac
}

// GetOrCreateSourceMac retrieves the value of the SourceMac field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) GetOrCreateSourceMac() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac {
	if t.SourceMac != nil {
		return t.SourceMac
	}
	t.SourceMac = &SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac{}
	return t.SourceMac
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) GetOrCreateVlan() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan{}
	return t.Vlan
}

// GetDestinationMac returns the value of the DestinationMac struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry_Match. If the receiver or the field DestinationMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) GetDestinationMac() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac {
	if t != nil && t.DestinationMac != nil {
		return t.DestinationMac
	}
	return nil
}

// GetSourceMac returns the value of the SourceMac struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry_Match. If the receiver or the field SourceMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) GetSourceMac() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac {
	if t != nil && t.SourceMac != nil {
		return t.SourceMac
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry_Match. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) GetVlan() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetEthertype retrieves the value of the leaf Ethertype from the SrlNokiaAcl_Acl_MacFilter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ethertype is set, it can
// safely use t.GetEthertype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ethertype == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) GetEthertype() SrlNokiaAcl_Acl_MacFilter_Entry_Match_Ethertype_Union {
	if t == nil || t.Ethertype == nil {
		return nil
	}
	return t.Ethertype
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationMac.PopulateDefaults()
	t.SourceMac.PopulateDefaults()
	t.Vlan.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Match.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac represents the /srl_nokia-acl/acl/mac-filter/entry/match/destination-mac YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_DestinationMac) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac represents the /srl_nokia-acl/acl/mac-filter/entry/match/source-mac YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_SourceMac) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan represents the /srl_nokia-acl/acl/mac-filter/entry/match/vlan YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan struct {
	OutermostVlanId *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId `path:"outermost-vlan-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) IsYANGGoStruct() {}

// GetOrCreateOutermostVlanId retrieves the value of the OutermostVlanId field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) GetOrCreateOutermostVlanId() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId {
	if t.OutermostVlanId != nil {
		return t.OutermostVlanId
	}
	t.OutermostVlanId = &SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId{}
	return t.OutermostVlanId
}

// GetOutermostVlanId returns the value of the OutermostVlanId struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan. If the receiver or the field OutermostVlanId is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) GetOutermostVlanId() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId {
	if t != nil && t.OutermostVlanId != nil {
		return t.OutermostVlanId
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.OutermostVlanId.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId represents the /srl_nokia-acl/acl/mac-filter/entry/match/vlan/outermost-vlan-id YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId struct {
	None     YANGEmpty                                                         `path:"none" module:"srl_nokia-acl"`
	Operator E_SrlNokiaPacketMatchTypes_Operator                               `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range `path:"range" module:"srl_nokia-acl"`
	Value    *uint16                                                           `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetOrCreateRange() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetRange() *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetNone retrieves the value of the leaf None from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if None is set, it can
// safely use t.GetNone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.None == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetNone() YANGEmpty {
	if t == nil || t.None == false {
		return false
	}
	return t.None
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) GetValue() uint16 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range represents the /srl_nokia-acl/acl/mac-filter/entry/match/vlan/outermost-vlan-id/range YANG schema element.
type SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range struct {
	End   *uint16 `path:"end" module:"srl_nokia-acl"`
	Start *uint16 `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range.
func (*SrlNokiaAcl_Acl_MacFilter_Entry_Match_Vlan_OutermostVlanId_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Policers represents the /srl_nokia-acl/acl/policers YANG schema element.
type SrlNokiaAcl_Acl_Policers struct {
	Policer          map[string]*SrlNokiaAcl_Acl_Policers_Policer          `path:"policer" module:"srl_nokia-acl"`
	SystemCpuPolicer map[string]*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer `path:"system-cpu-policer" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Policers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Policers) IsYANGGoStruct() {}

// NewPolicer creates a new entry in the Policer list of the
// SrlNokiaAcl_Acl_Policers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Policers) NewPolicer(Name string) (*SrlNokiaAcl_Acl_Policers_Policer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[string]*SrlNokiaAcl_Acl_Policers_Policer)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policer", key)
	}

	t.Policer[key] = &SrlNokiaAcl_Acl_Policers_Policer{
		Name: &Name,
	}

	return t.Policer[key], nil
}

// RenamePolicer renames an entry in the list Policer within
// the SrlNokiaAcl_Acl_Policers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_Policers) RenamePolicer(oldK, newK string) error {
	if _, ok := t.Policer[newK]; ok {
		return fmt.Errorf("key %v already exists in Policer", newK)
	}

	e, ok := t.Policer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policer", oldK)
	}
	e.Name = &newK

	t.Policer[newK] = e
	delete(t.Policer, oldK)
	return nil
}

// GetOrCreatePolicer retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Policers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_Policers) GetOrCreatePolicer(Name string) *SrlNokiaAcl_Acl_Policers_Policer {
	key := Name

	if v, ok := t.Policer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicer(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicer got unexpected error: %v", err))
	}
	return v
}

// GetPolicer retrieves the value with the specified key from
// the Policer map field of SrlNokiaAcl_Acl_Policers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_Policers) GetPolicer(Name string) *SrlNokiaAcl_Acl_Policers_Policer {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Policer[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicer deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Policers. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_Policers) DeletePolicer(Name string) {
	key := Name

	delete(t.Policer, key)
}

// AppendPolicer appends the supplied SrlNokiaAcl_Acl_Policers_Policer struct to the
// list Policer of SrlNokiaAcl_Acl_Policers. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Policers_Policer already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_Policers) AppendPolicer(v *SrlNokiaAcl_Acl_Policers_Policer) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[string]*SrlNokiaAcl_Acl_Policers_Policer)
	}

	if _, ok := t.Policer[key]; ok {
		return fmt.Errorf("duplicate key for list Policer %v", key)
	}

	t.Policer[key] = v
	return nil
}

// NewSystemCpuPolicer creates a new entry in the SystemCpuPolicer list of the
// SrlNokiaAcl_Acl_Policers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Policers) NewSystemCpuPolicer(Name string) (*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SystemCpuPolicer == nil {
		t.SystemCpuPolicer = make(map[string]*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SystemCpuPolicer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SystemCpuPolicer", key)
	}

	t.SystemCpuPolicer[key] = &SrlNokiaAcl_Acl_Policers_SystemCpuPolicer{
		Name: &Name,
	}

	return t.SystemCpuPolicer[key], nil
}

// RenameSystemCpuPolicer renames an entry in the list SystemCpuPolicer within
// the SrlNokiaAcl_Acl_Policers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_Policers) RenameSystemCpuPolicer(oldK, newK string) error {
	if _, ok := t.SystemCpuPolicer[newK]; ok {
		return fmt.Errorf("key %v already exists in SystemCpuPolicer", newK)
	}

	e, ok := t.SystemCpuPolicer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SystemCpuPolicer", oldK)
	}
	e.Name = &newK

	t.SystemCpuPolicer[newK] = e
	delete(t.SystemCpuPolicer, oldK)
	return nil
}

// GetOrCreateSystemCpuPolicer retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Policers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_Policers) GetOrCreateSystemCpuPolicer(Name string) *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer {
	key := Name

	if v, ok := t.SystemCpuPolicer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSystemCpuPolicer(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSystemCpuPolicer got unexpected error: %v", err))
	}
	return v
}

// GetSystemCpuPolicer retrieves the value with the specified key from
// the SystemCpuPolicer map field of SrlNokiaAcl_Acl_Policers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_Policers) GetSystemCpuPolicer(Name string) *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.SystemCpuPolicer[key]; ok {
		return lm
	}
	return nil
}

// DeleteSystemCpuPolicer deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_Policers. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_Policers) DeleteSystemCpuPolicer(Name string) {
	key := Name

	delete(t.SystemCpuPolicer, key)
}

// AppendSystemCpuPolicer appends the supplied SrlNokiaAcl_Acl_Policers_SystemCpuPolicer struct to the
// list SystemCpuPolicer of SrlNokiaAcl_Acl_Policers. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_Policers_SystemCpuPolicer already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_Policers) AppendSystemCpuPolicer(v *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SystemCpuPolicer == nil {
		t.SystemCpuPolicer = make(map[string]*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer)
	}

	if _, ok := t.SystemCpuPolicer[key]; ok {
		return fmt.Errorf("duplicate key for list SystemCpuPolicer %v", key)
	}

	t.SystemCpuPolicer[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Policers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Policers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Policer {
		e.PopulateDefaults()
	}
	for _, e := range t.SystemCpuPolicer {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Policers.
func (*SrlNokiaAcl_Acl_Policers) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Policers_Policer represents the /srl_nokia-acl/acl/policers/policer YANG schema element.
type SrlNokiaAcl_Acl_Policers_Policer struct {
	EntrySpecific *bool   `path:"entry-specific" module:"srl_nokia-acl"`
	MaxBurst      *uint32 `path:"max-burst" module:"srl_nokia-acl"`
	Name          *string `path:"name" module:"srl_nokia-acl"`
	PeakRate      *uint32 `path:"peak-rate" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Policers_Policer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Policers_Policer) IsYANGGoStruct() {}

// GetEntrySpecific retrieves the value of the leaf EntrySpecific from the SrlNokiaAcl_Acl_Policers_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntrySpecific is set, it can
// safely use t.GetEntrySpecific() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntrySpecific == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_Policer) GetEntrySpecific() bool {
	if t == nil || t.EntrySpecific == nil {
		return false
	}
	return *t.EntrySpecific
}

// GetMaxBurst retrieves the value of the leaf MaxBurst from the SrlNokiaAcl_Acl_Policers_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxBurst is set, it can
// safely use t.GetMaxBurst() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxBurst == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_Policer) GetMaxBurst() uint32 {
	if t == nil || t.MaxBurst == nil {
		return 0
	}
	return *t.MaxBurst
}

// GetName retrieves the value of the leaf Name from the SrlNokiaAcl_Acl_Policers_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_Policer) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPeakRate retrieves the value of the leaf PeakRate from the SrlNokiaAcl_Acl_Policers_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRate is set, it can
// safely use t.GetPeakRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_Policer) GetPeakRate() uint32 {
	if t == nil || t.PeakRate == nil {
		return 0
	}
	return *t.PeakRate
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Policers_Policer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Policers_Policer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EntrySpecific == nil {
		var v bool = false
		t.EntrySpecific = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Policers_Policer struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Policers_Policer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_Policer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers_Policer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_Policer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers_Policer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Policers_Policer.
func (*SrlNokiaAcl_Acl_Policers_Policer) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_Policers_SystemCpuPolicer represents the /srl_nokia-acl/acl/policers/system-cpu-policer YANG schema element.
type SrlNokiaAcl_Acl_Policers_SystemCpuPolicer struct {
	EntrySpecific  *bool   `path:"entry-specific" module:"srl_nokia-acl"`
	MaxPacketBurst *uint32 `path:"max-packet-burst" module:"srl_nokia-acl"`
	Name           *string `path:"name" module:"srl_nokia-acl"`
	PeakPacketRate *uint32 `path:"peak-packet-rate" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_Policers_SystemCpuPolicer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) IsYANGGoStruct() {}

// GetEntrySpecific retrieves the value of the leaf EntrySpecific from the SrlNokiaAcl_Acl_Policers_SystemCpuPolicer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntrySpecific is set, it can
// safely use t.GetEntrySpecific() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntrySpecific == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) GetEntrySpecific() bool {
	if t == nil || t.EntrySpecific == nil {
		return false
	}
	return *t.EntrySpecific
}

// GetMaxPacketBurst retrieves the value of the leaf MaxPacketBurst from the SrlNokiaAcl_Acl_Policers_SystemCpuPolicer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPacketBurst is set, it can
// safely use t.GetMaxPacketBurst() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPacketBurst == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) GetMaxPacketBurst() uint32 {
	if t == nil || t.MaxPacketBurst == nil {
		return 16
	}
	return *t.MaxPacketBurst
}

// GetName retrieves the value of the leaf Name from the SrlNokiaAcl_Acl_Policers_SystemCpuPolicer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPeakPacketRate retrieves the value of the leaf PeakPacketRate from the SrlNokiaAcl_Acl_Policers_SystemCpuPolicer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakPacketRate is set, it can
// safely use t.GetPeakPacketRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakPacketRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) GetPeakPacketRate() uint32 {
	if t == nil || t.PeakPacketRate == nil {
		return 0
	}
	return *t.PeakPacketRate
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_Policers_SystemCpuPolicer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EntrySpecific == nil {
		var v bool = false
		t.EntrySpecific = &v
	}
	if t.MaxPacketBurst == nil {
		var v uint32 = 16
		t.MaxPacketBurst = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Policers_SystemCpuPolicer struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers_SystemCpuPolicer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_Policers_SystemCpuPolicer.
func (*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter represents the /srl_nokia-acl/acl/system-filter YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter struct {
	Ipv4Filter *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter) IsYANGGoStruct() {}

// GetOrCreateIpv4Filter retrieves the value of the Ipv4Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter) GetOrCreateIpv4Filter() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter {
	if t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	t.Ipv4Filter = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter{}
	return t.Ipv4Filter
}

// GetOrCreateIpv6Filter retrieves the value of the Ipv6Filter field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter) GetOrCreateIpv6Filter() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter {
	if t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	t.Ipv6Filter = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter{}
	return t.Ipv6Filter
}

// GetIpv4Filter returns the value of the Ipv4Filter struct pointer
// from SrlNokiaAcl_Acl_SystemFilter. If the receiver or the field Ipv4Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter) GetIpv4Filter() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter {
	if t != nil && t.Ipv4Filter != nil {
		return t.Ipv4Filter
	}
	return nil
}

// GetIpv6Filter returns the value of the Ipv6Filter struct pointer
// from SrlNokiaAcl_Acl_SystemFilter. If the receiver or the field Ipv6Filter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter) GetIpv6Filter() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter {
	if t != nil && t.Ipv6Filter != nil {
		return t.Ipv6Filter
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Ipv4Filter.PopulateDefaults()
	t.Ipv6Filter.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter.
func (*SrlNokiaAcl_Acl_SystemFilter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter represents the /srl_nokia-acl/acl/system-filter/ipv4-filter YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter struct {
	Entry map[uint32]*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry `path:"entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) AppendEntry(v *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                               `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                               `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) GetAction() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	FirstFragment   *bool                                                                `path:"first-fragment" module:"srl_nokia-acl"`
	Fragment        *bool                                                                `path:"fragment" module:"srl_nokia-acl"`
	Icmp            *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp            `path:"icmp" module:"srl_nokia-acl"`
	Protocol        SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Protocol_Union   `path:"protocol" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                              `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetOrCreateIcmp() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetIcmp() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetFirstFragment retrieves the value of the leaf FirstFragment from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FirstFragment is set, it can
// safely use t.GetFirstFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FirstFragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetFirstFragment() bool {
	if t == nil || t.FirstFragment == nil {
		return false
	}
	return *t.FirstFragment
}

// GetFragment retrieves the value of the leaf Fragment from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetFragment() bool {
	if t == nil || t.Fragment == nil {
		return false
	}
	return *t.Fragment
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetProtocol() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Protocol_Union {
	if t == nil || t.Protocol == nil {
		return nil
	}
	return t.Protocol
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                             `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match/icmp YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp struct {
	Code []uint8                                                             `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) GetType() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_Icmp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                        `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/system-filter/ipv4-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter represents the /srl_nokia-acl/acl/system-filter/ipv6-filter YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter struct {
	Entry map[uint32]*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry `path:"entry" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) GetOrCreateEntry(SequenceId uint32) *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) GetEntry(SequenceId uint32) *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry struct to the
// list Entry of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter. If the key value(s) specified in
// the supplied SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) AppendEntry(v *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry struct {
	Action      *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action `path:"action" module:"srl_nokia-acl"`
	Description *string                                               `path:"description" module:"srl_nokia-acl"`
	Match       *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match  `path:"match" module:"srl_nokia-acl"`
	SequenceId  *uint32                                               `path:"sequence-id" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) GetOrCreateAction() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) GetOrCreateMatch() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) GetAction() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) GetMatch() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/action YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action struct {
	Accept *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept `path:"accept" module:"srl_nokia-acl" yangPresence:"true"`
	Drop   *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop   `path:"drop" module:"srl_nokia-acl" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAccept retrieves the value of the Accept field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetOrCreateAccept() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept {
	if t.Accept != nil {
		return t.Accept
	}
	t.Accept = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept{}
	return t.Accept
}

// GetOrCreateDrop retrieves the value of the Drop field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetOrCreateDrop() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop {
	if t.Drop != nil {
		return t.Drop
	}
	t.Drop = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop{}
	return t.Drop
}

// GetAccept returns the value of the Accept struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action. If the receiver or the field Accept is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetAccept() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept {
	if t != nil && t.Accept != nil {
		return t.Accept
	}
	return nil
}

// GetDrop returns the value of the Drop struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action. If the receiver or the field Drop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) GetDrop() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop {
	if t != nil && t.Drop != nil {
		return t.Drop
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accept.PopulateDefaults()
	t.Drop.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/action/accept YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept struct{}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Accept) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/action/drop YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop struct {
	Log *bool `path:"log" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) IsYANGGoStruct() {}

// GetLog retrieves the value of the leaf Log from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) GetLog() bool {
	if t == nil || t.Log == nil {
		return false
	}
	return *t.Log
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Log == nil {
		var v bool = false
		t.Log = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Action_Drop) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match struct {
	DestinationIp   *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp   `path:"destination-ip" module:"srl_nokia-acl"`
	DestinationPort *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort `path:"destination-port" module:"srl_nokia-acl"`
	DscpSet         []SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DscpSet_Union  `path:"dscp-set" module:"srl_nokia-acl"`
	Icmp6           *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6           `path:"icmp6" module:"srl_nokia-acl"`
	NextHeader      SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"srl_nokia-acl"`
	SourceIp        *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp        `path:"source-ip" module:"srl_nokia-acl"`
	SourcePort      *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort      `path:"source-port" module:"srl_nokia-acl"`
	TcpFlags        *string                                                              `path:"tcp-flags" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDestinationIp retrieves the value of the DestinationIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t.DestinationIp != nil {
		return t.DestinationIp
	}
	t.DestinationIp = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp{}
	return t.DestinationIp
}

// GetOrCreateDestinationPort retrieves the value of the DestinationPort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateDestinationPort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t.DestinationPort != nil {
		return t.DestinationPort
	}
	t.DestinationPort = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort{}
	return t.DestinationPort
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateIcmp6() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6{}
	return t.Icmp6
}

// GetOrCreateSourceIp retrieves the value of the SourceIp field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateSourceIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t.SourceIp != nil {
		return t.SourceIp
	}
	t.SourceIp = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp{}
	return t.SourceIp
}

// GetOrCreateSourcePort retrieves the value of the SourcePort field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetOrCreateSourcePort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t.SourcePort != nil {
		return t.SourcePort
	}
	t.SourcePort = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort{}
	return t.SourcePort
}

// GetDestinationIp returns the value of the DestinationIp struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetDestinationIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp {
	if t != nil && t.DestinationIp != nil {
		return t.DestinationIp
	}
	return nil
}

// GetDestinationPort returns the value of the DestinationPort struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field DestinationPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetDestinationPort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort {
	if t != nil && t.DestinationPort != nil {
		return t.DestinationPort
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetIcmp6() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetSourceIp returns the value of the SourceIp struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourceIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetSourceIp() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp {
	if t != nil && t.SourceIp != nil {
		return t.SourceIp
	}
	return nil
}

// GetSourcePort returns the value of the SourcePort struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match. If the receiver or the field SourcePort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetSourcePort() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort {
	if t != nil && t.SourcePort != nil {
		return t.SourcePort
	}
	return nil
}

// GetDscpSet retrieves the value of the leaf DscpSet from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DscpSet is set, it can
// safely use t.GetDscpSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DscpSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetDscpSet() []SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DscpSet_Union {
	if t == nil || t.DscpSet == nil {
		return nil
	}
	return t.DscpSet
}

// GetNextHeader retrieves the value of the leaf NextHeader from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetNextHeader() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetTcpFlags retrieves the value of the leaf TcpFlags from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpFlags is set, it can
// safely use t.GetTcpFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpFlags == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) GetTcpFlags() string {
	if t == nil || t.TcpFlags == nil {
		return ""
	}
	return *t.TcpFlags
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DestinationIp.PopulateDefaults()
	t.DestinationPort.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.SourceIp.PopulateDefaults()
	t.SourcePort.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/destination-ip YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/destination-port YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                             `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOrCreateRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) GetValue() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/destination-port/range YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range struct {
	End   SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetEnd() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) GetStart() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/icmp6 YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 struct {
	Code []uint8                                                              `path:"code" module:"srl_nokia-acl"`
	Type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union `path:"type" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) GetCode() []uint8 {
	if t == nil || t.Code == nil {
		return nil
	}
	return t.Code
}

// GetType retrieves the value of the leaf Type from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) GetType() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6_Type_Union {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_Icmp6) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/source-ip YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp struct {
	Address *string `path:"address" module:"srl_nokia-acl"`
	Mask    *string `path:"mask" module:"srl_nokia-acl"`
	Prefix  *string `path:"prefix" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourceIp) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/source-port YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort struct {
	Operator E_SrlNokiaPacketMatchTypes_Operator                                        `path:"operator" module:"srl_nokia-acl"`
	Range    *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range      `path:"range" module:"srl_nokia-acl"`
	Value    SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union `path:"value" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetOrCreateRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetRange() *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetOperator() E_SrlNokiaPacketMatchTypes_Operator {
	if t == nil || t.Operator == 0 {
		return 0
	}
	return t.Operator
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) GetValue() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range represents the /srl_nokia-acl/acl/system-filter/ipv6-filter/entry/match/source-port/range YANG schema element.
type SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range struct {
	End   SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union   `path:"end" module:"srl_nokia-acl"`
	Start SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union `path:"start" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetEnd() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) GetStart() SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range.
func (*SrlNokiaAcl_Acl_SystemFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaBfd_Bfd represents the /srl_nokia-bfd/bfd YANG schema element.
type SrlNokiaBfd_Bfd struct {
	MicroBfdSessions *SrlNokiaBfd_Bfd_MicroBfdSessions        `path:"micro-bfd-sessions" module:"srl_nokia-micro-bfd"`
	Subinterface     map[string]*SrlNokiaBfd_Bfd_Subinterface `path:"subinterface" module:"srl_nokia-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd) IsYANGGoStruct() {}

// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaBfd_Bfd struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaBfd_Bfd) NewSubinterface(Id string) (*SrlNokiaBfd_Bfd_Subinterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaBfd_Bfd_Subinterface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaBfd_Bfd_Subinterface{
		Id: &Id,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the SrlNokiaBfd_Bfd struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaBfd_Bfd) RenameSubinterface(oldK, newK string) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Id = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaBfd_Bfd) GetOrCreateSubinterface(Id string) *SrlNokiaBfd_Bfd_Subinterface {
	key := Id

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of SrlNokiaBfd_Bfd. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaBfd_Bfd) GetSubinterface(Id string) *SrlNokiaBfd_Bfd_Subinterface {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaBfd_Bfd) DeleteSubinterface(Id string) {
	key := Id

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied SrlNokiaBfd_Bfd_Subinterface struct to the
// list Subinterface of SrlNokiaBfd_Bfd. If the key value(s) specified in
// the supplied SrlNokiaBfd_Bfd_Subinterface already exist in the list, an error is
// returned.
func (t *SrlNokiaBfd_Bfd) AppendSubinterface(v *SrlNokiaBfd_Bfd_Subinterface) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaBfd_Bfd_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateMicroBfdSessions retrieves the value of the MicroBfdSessions field
// or returns the existing field if it already exists.
func (t *SrlNokiaBfd_Bfd) GetOrCreateMicroBfdSessions() *SrlNokiaBfd_Bfd_MicroBfdSessions {
	if t.MicroBfdSessions != nil {
		return t.MicroBfdSessions
	}
	t.MicroBfdSessions = &SrlNokiaBfd_Bfd_MicroBfdSessions{}
	return t.MicroBfdSessions
}

// GetMicroBfdSessions returns the value of the MicroBfdSessions struct pointer
// from SrlNokiaBfd_Bfd. If the receiver or the field MicroBfdSessions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaBfd_Bfd) GetMicroBfdSessions() *SrlNokiaBfd_Bfd_MicroBfdSessions {
	if t != nil && t.MicroBfdSessions != nil {
		return t.MicroBfdSessions
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MicroBfdSessions.PopulateDefaults()
	for _, e := range t.Subinterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd.
func (*SrlNokiaBfd_Bfd) ΛBelongingModule() string {
	return "srl_nokia-bfd"
}

// SrlNokiaBfd_Bfd_MicroBfdSessions represents the /srl_nokia-bfd/bfd/micro-bfd-sessions YANG schema element.
type SrlNokiaBfd_Bfd_MicroBfdSessions struct {
	LagInterface map[string]*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface `path:"lag-interface" module:"srl_nokia-micro-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd_MicroBfdSessions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions) IsYANGGoStruct() {}

// NewLagInterface creates a new entry in the LagInterface list of the
// SrlNokiaBfd_Bfd_MicroBfdSessions struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) NewLagInterface(Name string) (*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LagInterface == nil {
		t.LagInterface = make(map[string]*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LagInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LagInterface", key)
	}

	t.LagInterface[key] = &SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface{
		Name: &Name,
	}

	return t.LagInterface[key], nil
}

// RenameLagInterface renames an entry in the list LagInterface within
// the SrlNokiaBfd_Bfd_MicroBfdSessions struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) RenameLagInterface(oldK, newK string) error {
	if _, ok := t.LagInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in LagInterface", newK)
	}

	e, ok := t.LagInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LagInterface", oldK)
	}
	e.Name = &newK

	t.LagInterface[newK] = e
	delete(t.LagInterface, oldK)
	return nil
}

// GetOrCreateLagInterface retrieves the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd_MicroBfdSessions. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) GetOrCreateLagInterface(Name string) *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface {
	key := Name

	if v, ok := t.LagInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLagInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLagInterface got unexpected error: %v", err))
	}
	return v
}

// GetLagInterface retrieves the value with the specified key from
// the LagInterface map field of SrlNokiaBfd_Bfd_MicroBfdSessions. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) GetLagInterface(Name string) *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.LagInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteLagInterface deletes the value with the specified keys from
// the receiver SrlNokiaBfd_Bfd_MicroBfdSessions. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) DeleteLagInterface(Name string) {
	key := Name

	delete(t.LagInterface, key)
}

// AppendLagInterface appends the supplied SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface struct to the
// list LagInterface of SrlNokiaBfd_Bfd_MicroBfdSessions. If the key value(s) specified in
// the supplied SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) AppendLagInterface(v *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LagInterface == nil {
		t.LagInterface = make(map[string]*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface)
	}

	if _, ok := t.LagInterface[key]; ok {
		return fmt.Errorf("duplicate key for list LagInterface %v", key)
	}

	t.LagInterface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd_MicroBfdSessions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LagInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_MicroBfdSessions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd_MicroBfdSessions.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions) ΛBelongingModule() string {
	return "srl_nokia-micro-bfd"
}

// SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface represents the /srl_nokia-bfd/bfd/micro-bfd-sessions/lag-interface YANG schema element.
type SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface struct {
	AdminState                     E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-micro-bfd"`
	DesiredMinimumTransmitInterval *uint32                     `path:"desired-minimum-transmit-interval" module:"srl_nokia-micro-bfd"`
	DetectionMultiplier            *uint8                      `path:"detection-multiplier" module:"srl_nokia-micro-bfd"`
	LocalAddress                   *string                     `path:"local-address" module:"srl_nokia-micro-bfd"`
	Name                           *string                     `path:"name" module:"srl_nokia-micro-bfd"`
	RemoteAddress                  *string                     `path:"remote-address" module:"srl_nokia-micro-bfd"`
	RequiredMinimumReceive         *uint32                     `path:"required-minimum-receive" module:"srl_nokia-micro-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDesiredMinimumTransmitInterval retrieves the value of the leaf DesiredMinimumTransmitInterval from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DesiredMinimumTransmitInterval is set, it can
// safely use t.GetDesiredMinimumTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DesiredMinimumTransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetDesiredMinimumTransmitInterval() uint32 {
	if t == nil || t.DesiredMinimumTransmitInterval == nil {
		return 1000000
	}
	return *t.DesiredMinimumTransmitInterval
}

// GetDetectionMultiplier retrieves the value of the leaf DetectionMultiplier from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DetectionMultiplier is set, it can
// safely use t.GetDetectionMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DetectionMultiplier == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetDetectionMultiplier() uint8 {
	if t == nil || t.DetectionMultiplier == nil {
		return 3
	}
	return *t.DetectionMultiplier
}

// GetLocalAddress retrieves the value of the leaf LocalAddress from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalAddress is set, it can
// safely use t.GetLocalAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetLocalAddress() string {
	if t == nil || t.LocalAddress == nil {
		return ""
	}
	return *t.LocalAddress
}

// GetName retrieves the value of the leaf Name from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRemoteAddress retrieves the value of the leaf RemoteAddress from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteAddress is set, it can
// safely use t.GetRemoteAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetRemoteAddress() string {
	if t == nil || t.RemoteAddress == nil {
		return ""
	}
	return *t.RemoteAddress
}

// GetRequiredMinimumReceive retrieves the value of the leaf RequiredMinimumReceive from the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RequiredMinimumReceive is set, it can
// safely use t.GetRequiredMinimumReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RequiredMinimumReceive == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) GetRequiredMinimumReceive() uint32 {
	if t == nil || t.RequiredMinimumReceive == nil {
		return 1000000
	}
	return *t.RequiredMinimumReceive
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DesiredMinimumTransmitInterval == nil {
		var v uint32 = 1000000
		t.DesiredMinimumTransmitInterval = &v
	}
	if t.DetectionMultiplier == nil {
		var v uint8 = 3
		t.DetectionMultiplier = &v
	}
	if t.RequiredMinimumReceive == nil {
		var v uint32 = 1000000
		t.RequiredMinimumReceive = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface struct, which is a YANG list entry.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface.
func (*SrlNokiaBfd_Bfd_MicroBfdSessions_LagInterface) ΛBelongingModule() string {
	return "srl_nokia-micro-bfd"
}

// SrlNokiaBfd_Bfd_Subinterface represents the /srl_nokia-bfd/bfd/subinterface YANG schema element.
type SrlNokiaBfd_Bfd_Subinterface struct {
	AdminState                     E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-bfd"`
	DesiredMinimumTransmitInterval *uint32                     `path:"desired-minimum-transmit-interval" module:"srl_nokia-bfd"`
	DetectionMultiplier            *uint8                      `path:"detection-multiplier" module:"srl_nokia-bfd"`
	Id                             *string                     `path:"id" module:"srl_nokia-bfd"`
	MaxHopCount                    *uint8                      `path:"max-hop-count" module:"srl_nokia-bfd"`
	MinimumEchoReceiveInterval     *uint32                     `path:"minimum-echo-receive-interval" module:"srl_nokia-bfd"`
	RequiredMinimumReceive         *uint32                     `path:"required-minimum-receive" module:"srl_nokia-bfd"`
}

// IsYANGGoStruct ensures that SrlNokiaBfd_Bfd_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaBfd_Bfd_Subinterface) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDesiredMinimumTransmitInterval retrieves the value of the leaf DesiredMinimumTransmitInterval from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DesiredMinimumTransmitInterval is set, it can
// safely use t.GetDesiredMinimumTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DesiredMinimumTransmitInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetDesiredMinimumTransmitInterval() uint32 {
	if t == nil || t.DesiredMinimumTransmitInterval == nil {
		return 1000000
	}
	return *t.DesiredMinimumTransmitInterval
}

// GetDetectionMultiplier retrieves the value of the leaf DetectionMultiplier from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DetectionMultiplier is set, it can
// safely use t.GetDetectionMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DetectionMultiplier == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetDetectionMultiplier() uint8 {
	if t == nil || t.DetectionMultiplier == nil {
		return 3
	}
	return *t.DetectionMultiplier
}

// GetId retrieves the value of the leaf Id from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetMaxHopCount retrieves the value of the leaf MaxHopCount from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxHopCount is set, it can
// safely use t.GetMaxHopCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxHopCount == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetMaxHopCount() uint8 {
	if t == nil || t.MaxHopCount == nil {
		return 255
	}
	return *t.MaxHopCount
}

// GetMinimumEchoReceiveInterval retrieves the value of the leaf MinimumEchoReceiveInterval from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumEchoReceiveInterval is set, it can
// safely use t.GetMinimumEchoReceiveInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumEchoReceiveInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetMinimumEchoReceiveInterval() uint32 {
	if t == nil || t.MinimumEchoReceiveInterval == nil {
		return 0
	}
	return *t.MinimumEchoReceiveInterval
}

// GetRequiredMinimumReceive retrieves the value of the leaf RequiredMinimumReceive from the SrlNokiaBfd_Bfd_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RequiredMinimumReceive is set, it can
// safely use t.GetRequiredMinimumReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RequiredMinimumReceive == nil' before retrieving the leaf's value.
func (t *SrlNokiaBfd_Bfd_Subinterface) GetRequiredMinimumReceive() uint32 {
	if t == nil || t.RequiredMinimumReceive == nil {
		return 1000000
	}
	return *t.RequiredMinimumReceive
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaBfd_Bfd_Subinterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaBfd_Bfd_Subinterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.DesiredMinimumTransmitInterval == nil {
		var v uint32 = 1000000
		t.DesiredMinimumTransmitInterval = &v
	}
	if t.DetectionMultiplier == nil {
		var v uint8 = 3
		t.DetectionMultiplier = &v
	}
	if t.MaxHopCount == nil {
		var v uint8 = 255
		t.MaxHopCount = &v
	}
	if t.MinimumEchoReceiveInterval == nil {
		var v uint32 = 0
		t.MinimumEchoReceiveInterval = &v
	}
	if t.RequiredMinimumReceive == nil {
		var v uint32 = 1000000
		t.RequiredMinimumReceive = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaBfd_Bfd_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaBfd_Bfd_Subinterface.
func (*SrlNokiaBfd_Bfd_Subinterface) ΛBelongingModule() string {
	return "srl_nokia-bfd"
}

// SrlNokiaInterfaces_Interface represents the /srl_nokia-interfaces/interface YANG schema element.
type SrlNokiaInterfaces_Interface struct {
	AdminState   E_SrlNokiaCommon_AdminState                           `path:"admin-state" module:"srl_nokia-interfaces"`
	BreakoutMode *SrlNokiaInterfaces_Interface_BreakoutMode            `path:"breakout-mode" module:"srl_nokia-interfaces" yangPresence:"true"`
	Description  *string                                               `path:"description" module:"srl_nokia-interfaces"`
	Ethernet     *SrlNokiaInterfaces_Interface_Ethernet                `path:"ethernet" module:"srl_nokia-interfaces"`
	Lag          *SrlNokiaInterfaces_Interface_Lag                     `path:"lag" module:"srl_nokia-interfaces-lag" yangPresence:"true"`
	Linux        *SrlNokiaInterfaces_Interface_Linux                   `path:"linux" module:"srl_nokia-interfaces-vxdp"`
	LoopbackMode *bool                                                 `path:"loopback-mode" module:"srl_nokia-interfaces"`
	Mtu          *uint16                                               `path:"mtu" module:"srl_nokia-interfaces"`
	Name         *string                                               `path:"name" module:"srl_nokia-interfaces"`
	P4Rt         *SrlNokiaInterfaces_Interface_P4Rt                    `path:"p4rt" module:"srl_nokia-interfaces-p4rt" yangPresence:"true"`
	Qos          *SrlNokiaInterfaces_Interface_Qos                     `path:"qos" module:"srl_nokia-qos" yangPresence:"true"`
	Sflow        *SrlNokiaInterfaces_Interface_Sflow                   `path:"sflow" module:"srl_nokia-interfaces"`
	Subinterface map[uint32]*SrlNokiaInterfaces_Interface_Subinterface `path:"subinterface" module:"srl_nokia-interfaces"`
	Tpid         E_SrlNokiaInterfacesVlans_TPID_TYPES                  `path:"tpid" module:"srl_nokia-interfaces-vlans"`
	Transceiver  *SrlNokiaInterfaces_Interface_Transceiver             `path:"transceiver" module:"srl_nokia-interfaces"`
	Uuid         *string                                               `path:"uuid" module:"srl_nokia-interfaces-vxdp"`
	Vhost        *SrlNokiaInterfaces_Interface_Vhost                   `path:"vhost" module:"srl_nokia-interfaces-vxdp" yangPresence:"true"`
	VlanTagging  *bool                                                 `path:"vlan-tagging" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface) IsYANGGoStruct() {}

// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaInterfaces_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface) NewSubinterface(Index uint32) (*SrlNokiaInterfaces_Interface_Subinterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*SrlNokiaInterfaces_Interface_Subinterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaInterfaces_Interface_Subinterface{
		Index: &Index,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the SrlNokiaInterfaces_Interface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface) RenameSubinterface(oldK, newK uint32) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Index = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateSubinterface(Index uint32) *SrlNokiaInterfaces_Interface_Subinterface {
	key := Index

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of SrlNokiaInterfaces_Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetSubinterface(Index uint32) *SrlNokiaInterfaces_Interface_Subinterface {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface) DeleteSubinterface(Index uint32) {
	key := Index

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied SrlNokiaInterfaces_Interface_Subinterface struct to the
// list Subinterface of SrlNokiaInterfaces_Interface. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface) AppendSubinterface(v *SrlNokiaInterfaces_Interface_Subinterface) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*SrlNokiaInterfaces_Interface_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateBreakoutMode retrieves the value of the BreakoutMode field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateBreakoutMode() *SrlNokiaInterfaces_Interface_BreakoutMode {
	if t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	t.BreakoutMode = &SrlNokiaInterfaces_Interface_BreakoutMode{}
	return t.BreakoutMode
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateEthernet() *SrlNokiaInterfaces_Interface_Ethernet {
	if t.Ethernet != nil {
		return t.Ethernet
	}
	t.Ethernet = &SrlNokiaInterfaces_Interface_Ethernet{}
	return t.Ethernet
}

// GetOrCreateLag retrieves the value of the Lag field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateLag() *SrlNokiaInterfaces_Interface_Lag {
	if t.Lag != nil {
		return t.Lag
	}
	t.Lag = &SrlNokiaInterfaces_Interface_Lag{}
	return t.Lag
}

// GetOrCreateLinux retrieves the value of the Linux field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateLinux() *SrlNokiaInterfaces_Interface_Linux {
	if t.Linux != nil {
		return t.Linux
	}
	t.Linux = &SrlNokiaInterfaces_Interface_Linux{}
	return t.Linux
}

// GetOrCreateP4Rt retrieves the value of the P4Rt field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateP4Rt() *SrlNokiaInterfaces_Interface_P4Rt {
	if t.P4Rt != nil {
		return t.P4Rt
	}
	t.P4Rt = &SrlNokiaInterfaces_Interface_P4Rt{}
	return t.P4Rt
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateQos() *SrlNokiaInterfaces_Interface_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &SrlNokiaInterfaces_Interface_Qos{}
	return t.Qos
}

// GetOrCreateSflow retrieves the value of the Sflow field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateSflow() *SrlNokiaInterfaces_Interface_Sflow {
	if t.Sflow != nil {
		return t.Sflow
	}
	t.Sflow = &SrlNokiaInterfaces_Interface_Sflow{}
	return t.Sflow
}

// GetOrCreateTransceiver retrieves the value of the Transceiver field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateTransceiver() *SrlNokiaInterfaces_Interface_Transceiver {
	if t.Transceiver != nil {
		return t.Transceiver
	}
	t.Transceiver = &SrlNokiaInterfaces_Interface_Transceiver{}
	return t.Transceiver
}

// GetOrCreateVhost retrieves the value of the Vhost field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface) GetOrCreateVhost() *SrlNokiaInterfaces_Interface_Vhost {
	if t.Vhost != nil {
		return t.Vhost
	}
	t.Vhost = &SrlNokiaInterfaces_Interface_Vhost{}
	return t.Vhost
}

// GetBreakoutMode returns the value of the BreakoutMode struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field BreakoutMode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetBreakoutMode() *SrlNokiaInterfaces_Interface_BreakoutMode {
	if t != nil && t.BreakoutMode != nil {
		return t.BreakoutMode
	}
	return nil
}

// GetEthernet returns the value of the Ethernet struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetEthernet() *SrlNokiaInterfaces_Interface_Ethernet {
	if t != nil && t.Ethernet != nil {
		return t.Ethernet
	}
	return nil
}

// GetLag returns the value of the Lag struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Lag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetLag() *SrlNokiaInterfaces_Interface_Lag {
	if t != nil && t.Lag != nil {
		return t.Lag
	}
	return nil
}

// GetLinux returns the value of the Linux struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Linux is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetLinux() *SrlNokiaInterfaces_Interface_Linux {
	if t != nil && t.Linux != nil {
		return t.Linux
	}
	return nil
}

// GetP4Rt returns the value of the P4Rt struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field P4Rt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetP4Rt() *SrlNokiaInterfaces_Interface_P4Rt {
	if t != nil && t.P4Rt != nil {
		return t.P4Rt
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetQos() *SrlNokiaInterfaces_Interface_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetSflow returns the value of the Sflow struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Sflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetSflow() *SrlNokiaInterfaces_Interface_Sflow {
	if t != nil && t.Sflow != nil {
		return t.Sflow
	}
	return nil
}

// GetTransceiver returns the value of the Transceiver struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Transceiver is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetTransceiver() *SrlNokiaInterfaces_Interface_Transceiver {
	if t != nil && t.Transceiver != nil {
		return t.Transceiver
	}
	return nil
}

// GetVhost returns the value of the Vhost struct pointer
// from SrlNokiaInterfaces_Interface. If the receiver or the field Vhost is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface) GetVhost() *SrlNokiaInterfaces_Interface_Vhost {
	if t != nil && t.Vhost != nil {
		return t.Vhost
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetLoopbackMode retrieves the value of the leaf LoopbackMode from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LoopbackMode is set, it can
// safely use t.GetLoopbackMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LoopbackMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetLoopbackMode() bool {
	if t == nil || t.LoopbackMode == nil {
		return false
	}
	return *t.LoopbackMode
}

// GetMtu retrieves the value of the leaf Mtu from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetMtu() uint16 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// GetName retrieves the value of the leaf Name from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTpid retrieves the value of the leaf Tpid from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tpid is set, it can
// safely use t.GetTpid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tpid == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetTpid() E_SrlNokiaInterfacesVlans_TPID_TYPES {
	if t == nil || t.Tpid == 0 {
		return 0
	}
	return t.Tpid
}

// GetUuid retrieves the value of the leaf Uuid from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uuid is set, it can
// safely use t.GetUuid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uuid == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetUuid() string {
	if t == nil || t.Uuid == nil {
		return ""
	}
	return *t.Uuid
}

// GetVlanTagging retrieves the value of the leaf VlanTagging from the SrlNokiaInterfaces_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VlanTagging is set, it can
// safely use t.GetVlanTagging() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VlanTagging == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface) GetVlanTagging() bool {
	if t == nil || t.VlanTagging == nil {
		return false
	}
	return *t.VlanTagging
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.BreakoutMode.PopulateDefaults()
	t.Ethernet.PopulateDefaults()
	t.Lag.PopulateDefaults()
	t.Linux.PopulateDefaults()
	t.P4Rt.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.Sflow.PopulateDefaults()
	t.Transceiver.PopulateDefaults()
	t.Vhost.PopulateDefaults()
	for _, e := range t.Subinterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface.
func (*SrlNokiaInterfaces_Interface) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_BreakoutMode represents the /srl_nokia-interfaces/interface/breakout-mode YANG schema element.
type SrlNokiaInterfaces_Interface_BreakoutMode struct {
	BreakoutPortSpeed E_SrlNokiaInterfaces_Interface_BreakoutMode_BreakoutPortSpeed `path:"breakout-port-speed" module:"srl_nokia-interfaces"`
	NumBreakoutPorts  E_SrlNokiaInterfaces_Interface_BreakoutMode_NumBreakoutPorts  `path:"num-breakout-ports" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_BreakoutMode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_BreakoutMode) IsYANGGoStruct() {}

// GetBreakoutPortSpeed retrieves the value of the leaf BreakoutPortSpeed from the SrlNokiaInterfaces_Interface_BreakoutMode
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BreakoutPortSpeed is set, it can
// safely use t.GetBreakoutPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BreakoutPortSpeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) GetBreakoutPortSpeed() E_SrlNokiaInterfaces_Interface_BreakoutMode_BreakoutPortSpeed {
	if t == nil || t.BreakoutPortSpeed == 0 {
		return 0
	}
	return t.BreakoutPortSpeed
}

// GetNumBreakoutPorts retrieves the value of the leaf NumBreakoutPorts from the SrlNokiaInterfaces_Interface_BreakoutMode
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NumBreakoutPorts is set, it can
// safely use t.GetNumBreakoutPorts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NumBreakoutPorts == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) GetNumBreakoutPorts() E_SrlNokiaInterfaces_Interface_BreakoutMode_NumBreakoutPorts {
	if t == nil || t.NumBreakoutPorts == 0 {
		return 0
	}
	return t.NumBreakoutPorts
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_BreakoutMode
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_BreakoutMode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_BreakoutMode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_BreakoutMode.
func (*SrlNokiaInterfaces_Interface_BreakoutMode) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet represents the /srl_nokia-interfaces/interface/ethernet YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet struct {
	AggregateId      *string                                                  `path:"aggregate-id" module:"srl_nokia-interfaces"`
	AutoNegotiate    *bool                                                    `path:"auto-negotiate" module:"srl_nokia-interfaces"`
	DacLinkTraining  *bool                                                    `path:"dac-link-training" module:"srl_nokia-interfaces"`
	DuplexMode       E_SrlNokiaInterfaces_Interface_Ethernet_DuplexMode       `path:"duplex-mode" module:"srl_nokia-interfaces"`
	FlowControl      *SrlNokiaInterfaces_Interface_Ethernet_FlowControl       `path:"flow-control" module:"srl_nokia-interfaces"`
	ForwardingViable *bool                                                    `path:"forwarding-viable" module:"srl_nokia-interfaces"`
	HoldTime         *SrlNokiaInterfaces_Interface_Ethernet_HoldTime          `path:"hold-time" module:"srl_nokia-interfaces" yangPresence:"true"`
	L2CpTransparency *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency  `path:"l2cp-transparency" module:"srl_nokia-interfaces-l2cp" yangPresence:"true"`
	LacpPortPriority *uint16                                                  `path:"lacp-port-priority" module:"srl_nokia-interfaces"`
	MacAddress       *string                                                  `path:"mac-address" module:"srl_nokia-interfaces"`
	PortSpeed        E_SrlNokiaInterfaces_Interface_Ethernet_PortSpeed        `path:"port-speed" module:"srl_nokia-interfaces"`
	PtpAsymmetry     *int32                                                   `path:"ptp-asymmetry" module:"srl_nokia-interfaces"`
	ReloadDelay      *uint32                                                  `path:"reload-delay" module:"srl_nokia-interfaces"`
	StandbySignaling E_SrlNokiaInterfaces_Interface_Ethernet_StandbySignaling `path:"standby-signaling" module:"srl_nokia-interfaces"`
	StormControl     *SrlNokiaInterfaces_Interface_Ethernet_StormControl      `path:"storm-control" module:"srl_nokia-interfaces" yangPresence:"true"`
	Synce            *SrlNokiaInterfaces_Interface_Ethernet_Synce             `path:"synce" module:"srl_nokia-interfaces" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet) IsYANGGoStruct() {}

// GetOrCreateFlowControl retrieves the value of the FlowControl field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateFlowControl() *SrlNokiaInterfaces_Interface_Ethernet_FlowControl {
	if t.FlowControl != nil {
		return t.FlowControl
	}
	t.FlowControl = &SrlNokiaInterfaces_Interface_Ethernet_FlowControl{}
	return t.FlowControl
}

// GetOrCreateHoldTime retrieves the value of the HoldTime field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateHoldTime() *SrlNokiaInterfaces_Interface_Ethernet_HoldTime {
	if t.HoldTime != nil {
		return t.HoldTime
	}
	t.HoldTime = &SrlNokiaInterfaces_Interface_Ethernet_HoldTime{}
	return t.HoldTime
}

// GetOrCreateL2CpTransparency retrieves the value of the L2CpTransparency field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateL2CpTransparency() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency {
	if t.L2CpTransparency != nil {
		return t.L2CpTransparency
	}
	t.L2CpTransparency = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency{}
	return t.L2CpTransparency
}

// GetOrCreateStormControl retrieves the value of the StormControl field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateStormControl() *SrlNokiaInterfaces_Interface_Ethernet_StormControl {
	if t.StormControl != nil {
		return t.StormControl
	}
	t.StormControl = &SrlNokiaInterfaces_Interface_Ethernet_StormControl{}
	return t.StormControl
}

// GetOrCreateSynce retrieves the value of the Synce field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetOrCreateSynce() *SrlNokiaInterfaces_Interface_Ethernet_Synce {
	if t.Synce != nil {
		return t.Synce
	}
	t.Synce = &SrlNokiaInterfaces_Interface_Ethernet_Synce{}
	return t.Synce
}

// GetFlowControl returns the value of the FlowControl struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field FlowControl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetFlowControl() *SrlNokiaInterfaces_Interface_Ethernet_FlowControl {
	if t != nil && t.FlowControl != nil {
		return t.FlowControl
	}
	return nil
}

// GetHoldTime returns the value of the HoldTime struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field HoldTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetHoldTime() *SrlNokiaInterfaces_Interface_Ethernet_HoldTime {
	if t != nil && t.HoldTime != nil {
		return t.HoldTime
	}
	return nil
}

// GetL2CpTransparency returns the value of the L2CpTransparency struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field L2CpTransparency is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetL2CpTransparency() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency {
	if t != nil && t.L2CpTransparency != nil {
		return t.L2CpTransparency
	}
	return nil
}

// GetStormControl returns the value of the StormControl struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field StormControl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetStormControl() *SrlNokiaInterfaces_Interface_Ethernet_StormControl {
	if t != nil && t.StormControl != nil {
		return t.StormControl
	}
	return nil
}

// GetSynce returns the value of the Synce struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet. If the receiver or the field Synce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetSynce() *SrlNokiaInterfaces_Interface_Ethernet_Synce {
	if t != nil && t.Synce != nil {
		return t.Synce
	}
	return nil
}

// GetAggregateId retrieves the value of the leaf AggregateId from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AggregateId is set, it can
// safely use t.GetAggregateId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AggregateId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetAggregateId() string {
	if t == nil || t.AggregateId == nil {
		return ""
	}
	return *t.AggregateId
}

// GetAutoNegotiate retrieves the value of the leaf AutoNegotiate from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoNegotiate is set, it can
// safely use t.GetAutoNegotiate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoNegotiate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetAutoNegotiate() bool {
	if t == nil || t.AutoNegotiate == nil {
		return false
	}
	return *t.AutoNegotiate
}

// GetDacLinkTraining retrieves the value of the leaf DacLinkTraining from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DacLinkTraining is set, it can
// safely use t.GetDacLinkTraining() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DacLinkTraining == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetDacLinkTraining() bool {
	if t == nil || t.DacLinkTraining == nil {
		return false
	}
	return *t.DacLinkTraining
}

// GetDuplexMode retrieves the value of the leaf DuplexMode from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplexMode is set, it can
// safely use t.GetDuplexMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplexMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetDuplexMode() E_SrlNokiaInterfaces_Interface_Ethernet_DuplexMode {
	if t == nil || t.DuplexMode == 0 {
		return 0
	}
	return t.DuplexMode
}

// GetForwardingViable retrieves the value of the leaf ForwardingViable from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingViable is set, it can
// safely use t.GetForwardingViable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingViable == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetForwardingViable() bool {
	if t == nil || t.ForwardingViable == nil {
		return false
	}
	return *t.ForwardingViable
}

// GetLacpPortPriority retrieves the value of the leaf LacpPortPriority from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpPortPriority is set, it can
// safely use t.GetLacpPortPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpPortPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetLacpPortPriority() uint16 {
	if t == nil || t.LacpPortPriority == nil {
		return 0
	}
	return *t.LacpPortPriority
}

// GetMacAddress retrieves the value of the leaf MacAddress from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetPortSpeed retrieves the value of the leaf PortSpeed from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortSpeed is set, it can
// safely use t.GetPortSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortSpeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetPortSpeed() E_SrlNokiaInterfaces_Interface_Ethernet_PortSpeed {
	if t == nil || t.PortSpeed == 0 {
		return 0
	}
	return t.PortSpeed
}

// GetPtpAsymmetry retrieves the value of the leaf PtpAsymmetry from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PtpAsymmetry is set, it can
// safely use t.GetPtpAsymmetry() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PtpAsymmetry == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetPtpAsymmetry() int32 {
	if t == nil || t.PtpAsymmetry == nil {
		return 0
	}
	return *t.PtpAsymmetry
}

// GetReloadDelay retrieves the value of the leaf ReloadDelay from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReloadDelay is set, it can
// safely use t.GetReloadDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReloadDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetReloadDelay() uint32 {
	if t == nil || t.ReloadDelay == nil {
		return 0
	}
	return *t.ReloadDelay
}

// GetStandbySignaling retrieves the value of the leaf StandbySignaling from the SrlNokiaInterfaces_Interface_Ethernet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StandbySignaling is set, it can
// safely use t.GetStandbySignaling() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StandbySignaling == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet) GetStandbySignaling() E_SrlNokiaInterfaces_Interface_Ethernet_StandbySignaling {
	if t == nil || t.StandbySignaling == 0 {
		return 0
	}
	return t.StandbySignaling
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FlowControl.PopulateDefaults()
	t.HoldTime.PopulateDefaults()
	t.L2CpTransparency.PopulateDefaults()
	t.StormControl.PopulateDefaults()
	t.Synce.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet.
func (*SrlNokiaInterfaces_Interface_Ethernet) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_FlowControl represents the /srl_nokia-interfaces/interface/ethernet/flow-control YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_FlowControl struct {
	Receive  *bool `path:"receive" module:"srl_nokia-interfaces"`
	Transmit *bool `path:"transmit" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_FlowControl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_FlowControl) IsYANGGoStruct() {}

// GetReceive retrieves the value of the leaf Receive from the SrlNokiaInterfaces_Interface_Ethernet_FlowControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Receive is set, it can
// safely use t.GetReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Receive == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) GetReceive() bool {
	if t == nil || t.Receive == nil {
		return false
	}
	return *t.Receive
}

// GetTransmit retrieves the value of the leaf Transmit from the SrlNokiaInterfaces_Interface_Ethernet_FlowControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Transmit is set, it can
// safely use t.GetTransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Transmit == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) GetTransmit() bool {
	if t == nil || t.Transmit == nil {
		return false
	}
	return *t.Transmit
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_FlowControl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_FlowControl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_FlowControl.
func (*SrlNokiaInterfaces_Interface_Ethernet_FlowControl) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_HoldTime represents the /srl_nokia-interfaces/interface/ethernet/hold-time YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_HoldTime struct {
	Down *uint32 `path:"down" module:"srl_nokia-interfaces"`
	Up   *uint32 `path:"up" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_HoldTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_HoldTime) IsYANGGoStruct() {}

// GetDown retrieves the value of the leaf Down from the SrlNokiaInterfaces_Interface_Ethernet_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Down is set, it can
// safely use t.GetDown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Down == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) GetDown() uint32 {
	if t == nil || t.Down == nil {
		return 0
	}
	return *t.Down
}

// GetUp retrieves the value of the leaf Up from the SrlNokiaInterfaces_Interface_Ethernet_HoldTime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Up is set, it can
// safely use t.GetUp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Up == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) GetUp() uint32 {
	if t == nil || t.Up == nil {
		return 0
	}
	return *t.Up
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_HoldTime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_HoldTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_HoldTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_HoldTime.
func (*SrlNokiaInterfaces_Interface_Ethernet_HoldTime) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency struct {
	Dot1X         *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X `path:"dot1x" module:"srl_nokia-interfaces-l2cp"`
	Lacp          *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp  `path:"lacp" module:"srl_nokia-interfaces-l2cp"`
	Lldp          *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp  `path:"lldp" module:"srl_nokia-interfaces-l2cp"`
	Ptp           *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp   `path:"ptp" module:"srl_nokia-interfaces-l2cp"`
	TunnelAllL2Cp *bool                                                         `path:"tunnel-all-l2cp" module:"srl_nokia-interfaces-l2cp"`
	Xstp          *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp  `path:"xstp" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) IsYANGGoStruct() {}

// GetOrCreateDot1X retrieves the value of the Dot1X field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateDot1X() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X {
	if t.Dot1X != nil {
		return t.Dot1X
	}
	t.Dot1X = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X{}
	return t.Dot1X
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateLacp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp{}
	return t.Lacp
}

// GetOrCreateLldp retrieves the value of the Lldp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateLldp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp {
	if t.Lldp != nil {
		return t.Lldp
	}
	t.Lldp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp{}
	return t.Lldp
}

// GetOrCreatePtp retrieves the value of the Ptp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreatePtp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp {
	if t.Ptp != nil {
		return t.Ptp
	}
	t.Ptp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp{}
	return t.Ptp
}

// GetOrCreateXstp retrieves the value of the Xstp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetOrCreateXstp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp {
	if t.Xstp != nil {
		return t.Xstp
	}
	t.Xstp = &SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp{}
	return t.Xstp
}

// GetDot1X returns the value of the Dot1X struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Dot1X is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetDot1X() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X {
	if t != nil && t.Dot1X != nil {
		return t.Dot1X
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetLacp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetLldp returns the value of the Lldp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Lldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetLldp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp {
	if t != nil && t.Lldp != nil {
		return t.Lldp
	}
	return nil
}

// GetPtp returns the value of the Ptp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Ptp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetPtp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp {
	if t != nil && t.Ptp != nil {
		return t.Ptp
	}
	return nil
}

// GetXstp returns the value of the Xstp struct pointer
// from SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency. If the receiver or the field Xstp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetXstp() *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp {
	if t != nil && t.Xstp != nil {
		return t.Xstp
	}
	return nil
}

// GetTunnelAllL2Cp retrieves the value of the leaf TunnelAllL2Cp from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelAllL2Cp is set, it can
// safely use t.GetTunnelAllL2Cp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelAllL2Cp == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) GetTunnelAllL2Cp() bool {
	if t == nil || t.TunnelAllL2Cp == nil {
		return false
	}
	return *t.TunnelAllL2Cp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.TunnelAllL2Cp == nil {
		var v bool = false
		t.TunnelAllL2Cp = &v
	}
	t.Dot1X.PopulateDefaults()
	t.Lacp.PopulateDefaults()
	t.Lldp.PopulateDefaults()
	t.Ptp.PopulateDefaults()
	t.Xstp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/dot1x YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Dot1X) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/lacp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lacp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/lldp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Lldp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/ptp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Ptp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp represents the /srl_nokia-interfaces/interface/ethernet/l2cp-transparency/xstp YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp struct {
	Tunnel *bool `path:"tunnel" module:"srl_nokia-interfaces-l2cp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) IsYANGGoStruct() {}

// GetTunnel retrieves the value of the leaf Tunnel from the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tunnel is set, it can
// safely use t.GetTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tunnel == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) GetTunnel() bool {
	if t == nil || t.Tunnel == nil {
		return false
	}
	return *t.Tunnel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Tunnel == nil {
		var v bool = false
		t.Tunnel = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp.
func (*SrlNokiaInterfaces_Interface_Ethernet_L2CpTransparency_Xstp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-l2cp"
}

// SrlNokiaInterfaces_Interface_Ethernet_StormControl represents the /srl_nokia-interfaces/interface/ethernet/storm-control YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_StormControl struct {
	BroadcastRate      *uint32                                                    `path:"broadcast-rate" module:"srl_nokia-interfaces"`
	MulticastRate      *uint32                                                    `path:"multicast-rate" module:"srl_nokia-interfaces"`
	Units              E_SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units `path:"units" module:"srl_nokia-interfaces"`
	UnknownUnicastRate *uint32                                                    `path:"unknown-unicast-rate" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_StormControl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_StormControl) IsYANGGoStruct() {}

// GetBroadcastRate retrieves the value of the leaf BroadcastRate from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BroadcastRate is set, it can
// safely use t.GetBroadcastRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BroadcastRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetBroadcastRate() uint32 {
	if t == nil || t.BroadcastRate == nil {
		return 0
	}
	return *t.BroadcastRate
}

// GetMulticastRate retrieves the value of the leaf MulticastRate from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MulticastRate is set, it can
// safely use t.GetMulticastRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MulticastRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetMulticastRate() uint32 {
	if t == nil || t.MulticastRate == nil {
		return 0
	}
	return *t.MulticastRate
}

// GetUnits retrieves the value of the leaf Units from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Units is set, it can
// safely use t.GetUnits() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Units == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetUnits() E_SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units {
	if t == nil || t.Units == 0 {
		return SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units_percentage
	}
	return t.Units
}

// GetUnknownUnicastRate retrieves the value of the leaf UnknownUnicastRate from the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnknownUnicastRate is set, it can
// safely use t.GetUnknownUnicastRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnknownUnicastRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) GetUnknownUnicastRate() uint32 {
	if t == nil || t.UnknownUnicastRate == nil {
		return 0
	}
	return *t.UnknownUnicastRate
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_StormControl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Units == 0 {
		t.Units = SrlNokiaInterfaces_Interface_Ethernet_StormControl_Units_percentage
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_StormControl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_StormControl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_StormControl.
func (*SrlNokiaInterfaces_Interface_Ethernet_StormControl) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Ethernet_Synce represents the /srl_nokia-interfaces/interface/ethernet/synce YANG schema element.
type SrlNokiaInterfaces_Interface_Ethernet_Synce struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Ethernet_Synce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Ethernet_Synce) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Ethernet_Synce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Ethernet_Synce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_Synce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Synce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Ethernet_Synce.
func (*SrlNokiaInterfaces_Interface_Ethernet_Synce) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Lag represents the /srl_nokia-interfaces/interface/lag YANG schema element.
type SrlNokiaInterfaces_Interface_Lag struct {
	Lacp                *SrlNokiaInterfaces_Interface_Lag_Lacp   `path:"lacp" module:"srl_nokia-lacp" yangPresence:"true"`
	LacpFallbackMode    E_SrlNokiaInterfacesLag_LacpFallbackType `path:"lacp-fallback-mode" module:"srl_nokia-interfaces-lag"`
	LacpFallbackTimeout *uint16                                  `path:"lacp-fallback-timeout" module:"srl_nokia-interfaces-lag"`
	LagType             E_SrlNokiaInterfacesLag_LagType          `path:"lag-type" module:"srl_nokia-interfaces-lag"`
	MemberSpeed         E_SrlNokiaInterfacesLag_MemberSpeedType  `path:"member-speed" module:"srl_nokia-interfaces-lag"`
	MinLinks            *uint16                                  `path:"min-links" module:"srl_nokia-interfaces-lag"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Lag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Lag) IsYANGGoStruct() {}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Lag) GetOrCreateLacp() *SrlNokiaInterfaces_Interface_Lag_Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &SrlNokiaInterfaces_Interface_Lag_Lacp{}
	return t.Lacp
}

// GetLacp returns the value of the Lacp struct pointer
// from SrlNokiaInterfaces_Interface_Lag. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLacp() *SrlNokiaInterfaces_Interface_Lag_Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetLacpFallbackMode retrieves the value of the leaf LacpFallbackMode from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpFallbackMode is set, it can
// safely use t.GetLacpFallbackMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpFallbackMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLacpFallbackMode() E_SrlNokiaInterfacesLag_LacpFallbackType {
	if t == nil || t.LacpFallbackMode == 0 {
		return 0
	}
	return t.LacpFallbackMode
}

// GetLacpFallbackTimeout retrieves the value of the leaf LacpFallbackTimeout from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpFallbackTimeout is set, it can
// safely use t.GetLacpFallbackTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpFallbackTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLacpFallbackTimeout() uint16 {
	if t == nil || t.LacpFallbackTimeout == nil {
		return 0
	}
	return *t.LacpFallbackTimeout
}

// GetLagType retrieves the value of the leaf LagType from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagType is set, it can
// safely use t.GetLagType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetLagType() E_SrlNokiaInterfacesLag_LagType {
	if t == nil || t.LagType == 0 {
		return SrlNokiaInterfacesLag_LagType_static
	}
	return t.LagType
}

// GetMemberSpeed retrieves the value of the leaf MemberSpeed from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MemberSpeed is set, it can
// safely use t.GetMemberSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MemberSpeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetMemberSpeed() E_SrlNokiaInterfacesLag_MemberSpeedType {
	if t == nil || t.MemberSpeed == 0 {
		return 0
	}
	return t.MemberSpeed
}

// GetMinLinks retrieves the value of the leaf MinLinks from the SrlNokiaInterfaces_Interface_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinLinks is set, it can
// safely use t.GetMinLinks() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinLinks == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag) GetMinLinks() uint16 {
	if t == nil || t.MinLinks == nil {
		return 1
	}
	return *t.MinLinks
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Lag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Lag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.LagType == 0 {
		t.LagType = SrlNokiaInterfacesLag_LagType_static
	}
	if t.MinLinks == nil {
		var v uint16 = 1
		t.MinLinks = &v
	}
	t.Lacp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Lag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Lag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Lag.
func (*SrlNokiaInterfaces_Interface_Lag) ΛBelongingModule() string {
	return "srl_nokia-interfaces-lag"
}

// SrlNokiaInterfaces_Interface_Lag_Lacp represents the /srl_nokia-interfaces/interface/lag/lacp YANG schema element.
type SrlNokiaInterfaces_Interface_Lag_Lacp struct {
	AdminKey       *uint16                         `path:"admin-key" module:"srl_nokia-lacp"`
	Interval       E_SrlNokiaLacp_LacpPeriodType   `path:"interval" module:"srl_nokia-lacp"`
	LacpMode       E_SrlNokiaLacp_LacpActivityType `path:"lacp-mode" module:"srl_nokia-lacp"`
	SystemIdMac    *string                         `path:"system-id-mac" module:"srl_nokia-lacp"`
	SystemPriority *uint16                         `path:"system-priority" module:"srl_nokia-lacp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Lag_Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Lag_Lacp) IsYANGGoStruct() {}

// GetAdminKey retrieves the value of the leaf AdminKey from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminKey is set, it can
// safely use t.GetAdminKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminKey == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetAdminKey() uint16 {
	if t == nil || t.AdminKey == nil {
		return 0
	}
	return *t.AdminKey
}

// GetInterval retrieves the value of the leaf Interval from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetInterval() E_SrlNokiaLacp_LacpPeriodType {
	if t == nil || t.Interval == 0 {
		return SrlNokiaLacp_LacpPeriodType_SLOW
	}
	return t.Interval
}

// GetLacpMode retrieves the value of the leaf LacpMode from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpMode is set, it can
// safely use t.GetLacpMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetLacpMode() E_SrlNokiaLacp_LacpActivityType {
	if t == nil || t.LacpMode == 0 {
		return SrlNokiaLacp_LacpActivityType_ACTIVE
	}
	return t.LacpMode
}

// GetSystemIdMac retrieves the value of the leaf SystemIdMac from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemIdMac is set, it can
// safely use t.GetSystemIdMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemIdMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetSystemIdMac() string {
	if t == nil || t.SystemIdMac == nil {
		return ""
	}
	return *t.SystemIdMac
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the SrlNokiaInterfaces_Interface_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Lag_Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interval == 0 {
		t.Interval = SrlNokiaLacp_LacpPeriodType_SLOW
	}
	if t.LacpMode == 0 {
		t.LacpMode = SrlNokiaLacp_LacpActivityType_ACTIVE
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Lag_Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Lag_Lacp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Lag_Lacp.
func (*SrlNokiaInterfaces_Interface_Lag_Lacp) ΛBelongingModule() string {
	return "srl_nokia-lacp"
}

// SrlNokiaInterfaces_Interface_Linux represents the /srl_nokia-interfaces/interface/linux YANG schema element.
type SrlNokiaInterfaces_Interface_Linux struct {
	DeviceName *string `path:"device-name" module:"srl_nokia-interfaces-vxdp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Linux implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Linux) IsYANGGoStruct() {}

// GetDeviceName retrieves the value of the leaf DeviceName from the SrlNokiaInterfaces_Interface_Linux
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DeviceName is set, it can
// safely use t.GetDeviceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DeviceName == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Linux) GetDeviceName() string {
	if t == nil || t.DeviceName == nil {
		return ""
	}
	return *t.DeviceName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Linux
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Linux) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Linux) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Linux"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Linux) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Linux) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Linux.
func (*SrlNokiaInterfaces_Interface_Linux) ΛBelongingModule() string {
	return "srl_nokia-interfaces-vxdp"
}

// SrlNokiaInterfaces_Interface_P4Rt represents the /srl_nokia-interfaces/interface/p4rt YANG schema element.
type SrlNokiaInterfaces_Interface_P4Rt struct {
	Id *uint32 `path:"id" module:"srl_nokia-interfaces-p4rt"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_P4Rt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_P4Rt) IsYANGGoStruct() {}

// GetId retrieves the value of the leaf Id from the SrlNokiaInterfaces_Interface_P4Rt
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_P4Rt) GetId() uint32 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_P4Rt
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_P4Rt) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_P4Rt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_P4Rt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_P4Rt) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_P4Rt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_P4Rt.
func (*SrlNokiaInterfaces_Interface_P4Rt) ΛBelongingModule() string {
	return "srl_nokia-interfaces-p4rt"
}

// SrlNokiaInterfaces_Interface_Qos represents the /srl_nokia-interfaces/interface/qos YANG schema element.
type SrlNokiaInterfaces_Interface_Qos struct {
	Output *SrlNokiaInterfaces_Interface_Qos_Output `path:"output" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos) IsYANGGoStruct() {}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Qos) GetOrCreateOutput() *SrlNokiaInterfaces_Interface_Qos_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &SrlNokiaInterfaces_Interface_Qos_Output{}
	return t.Output
}

// GetOutput returns the value of the Output struct pointer
// from SrlNokiaInterfaces_Interface_Qos. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos) GetOutput() *SrlNokiaInterfaces_Interface_Qos_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Output.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos.
func (*SrlNokiaInterfaces_Interface_Qos) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output represents the /srl_nokia-interfaces/interface/qos/output YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output struct {
	Queue     map[SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union]*SrlNokiaInterfaces_Interface_Qos_Output_Queue `path:"queue" module:"srl_nokia-qos"`
	Scheduler *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler                                                               `path:"scheduler" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output) IsYANGGoStruct() {}

// NewQueue creates a new entry in the Queue list of the
// SrlNokiaInterfaces_Interface_Qos_Output struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) NewQueue(QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union) (*SrlNokiaInterfaces_Interface_Qos_Output_Queue, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union]*SrlNokiaInterfaces_Interface_Qos_Output_Queue)
	}

	key := QueueName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &SrlNokiaInterfaces_Interface_Qos_Output_Queue{
		QueueName: QueueName,
	}

	return t.Queue[key], nil
}

// RenameQueue renames an entry in the list Queue within
// the SrlNokiaInterfaces_Interface_Qos_Output struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) RenameQueue(
	oldK, newK SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union,
) error {
	if _, ok := t.Queue[newK]; ok {
		return fmt.Errorf("key %v already exists in Queue", newK)
	}

	e, ok := t.Queue[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Queue", oldK)
	}
	e.QueueName = newK

	t.Queue[newK] = e
	delete(t.Queue, oldK)
	return nil
}

// GetOrCreateQueue retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetOrCreateQueue(
	QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union,
) *SrlNokiaInterfaces_Interface_Qos_Output_Queue {
	key := QueueName

	if v, ok := t.Queue[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueue(QueueName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueue got unexpected error: %v", err))
	}
	return v
}

// GetQueue retrieves the value with the specified key from
// the Queue map field of SrlNokiaInterfaces_Interface_Qos_Output. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetQueue(QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union) *SrlNokiaInterfaces_Interface_Qos_Output_Queue {
	if t == nil {
		return nil
	}

	key := QueueName

	if lm, ok := t.Queue[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueue deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) DeleteQueue(
	QueueName SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union,
) {
	key := QueueName

	delete(t.Queue, key)
}

// AppendQueue appends the supplied SrlNokiaInterfaces_Interface_Qos_Output_Queue struct to the
// list Queue of SrlNokiaInterfaces_Interface_Qos_Output. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Qos_Output_Queue already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) AppendQueue(v *SrlNokiaInterfaces_Interface_Qos_Output_Queue) error {
	key := v.QueueName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union]*SrlNokiaInterfaces_Interface_Qos_Output_Queue)
	}

	if _, ok := t.Queue[key]; ok {
		return fmt.Errorf("duplicate key for list Queue %v", key)
	}

	t.Queue[key] = v
	return nil
}

// GetOrCreateScheduler retrieves the value of the Scheduler field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetOrCreateScheduler() *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler {
	if t.Scheduler != nil {
		return t.Scheduler
	}
	t.Scheduler = &SrlNokiaInterfaces_Interface_Qos_Output_Scheduler{}
	return t.Scheduler
}

// GetScheduler returns the value of the Scheduler struct pointer
// from SrlNokiaInterfaces_Interface_Qos_Output. If the receiver or the field Scheduler is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) GetScheduler() *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler {
	if t != nil && t.Scheduler != nil {
		return t.Scheduler
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Scheduler.PopulateDefaults()
	for _, e := range t.Queue {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output.
func (*SrlNokiaInterfaces_Interface_Qos_Output) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Queue represents the /srl_nokia-interfaces/interface/qos/output/queue YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Queue struct {
	QueueName   SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union `path:"queue-name" module:"srl_nokia-qos"`
	Scheduling  *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling     `path:"scheduling" module:"srl_nokia-qos"`
	Template    *string                                                       `path:"template" module:"srl_nokia-qos"`
	VoqTemplate *string                                                       `path:"voq-template" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Queue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue) IsYANGGoStruct() {}

// GetOrCreateScheduling retrieves the value of the Scheduling field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetOrCreateScheduling() *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling {
	if t.Scheduling != nil {
		return t.Scheduling
	}
	t.Scheduling = &SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling{}
	return t.Scheduling
}

// GetScheduling returns the value of the Scheduling struct pointer
// from SrlNokiaInterfaces_Interface_Qos_Output_Queue. If the receiver or the field Scheduling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetScheduling() *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling {
	if t != nil && t.Scheduling != nil {
		return t.Scheduling
	}
	return nil
}

// GetQueueName retrieves the value of the leaf QueueName from the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueueName is set, it can
// safely use t.GetQueueName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueueName == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetQueueName() SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueName_Union {
	if t == nil || t.QueueName == nil {
		return nil
	}
	return t.QueueName
}

// GetTemplate retrieves the value of the leaf Template from the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Template is set, it can
// safely use t.GetTemplate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Template == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetTemplate() string {
	if t == nil || t.Template == nil {
		return ""
	}
	return *t.Template
}

// GetVoqTemplate retrieves the value of the leaf VoqTemplate from the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VoqTemplate is set, it can
// safely use t.GetVoqTemplate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VoqTemplate == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) GetVoqTemplate() string {
	if t == nil || t.VoqTemplate == nil {
		return ""
	}
	return *t.VoqTemplate
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Queue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Scheduling.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Qos_Output_Queue struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"queue-name": t.QueueName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Queue.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling represents the /srl_nokia-interfaces/interface/qos/output/queue/scheduling YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling struct {
	PeakRatePercent *uint8 `path:"peak-rate-percent" module:"srl_nokia-qos"`
	StrictPriority  *bool  `path:"strict-priority" module:"srl_nokia-qos"`
	Weight          *uint8 `path:"weight" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) IsYANGGoStruct() {}

// GetPeakRatePercent retrieves the value of the leaf PeakRatePercent from the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeakRatePercent is set, it can
// safely use t.GetPeakRatePercent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeakRatePercent == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) GetPeakRatePercent() uint8 {
	if t == nil || t.PeakRatePercent == nil {
		return 100
	}
	return *t.PeakRatePercent
}

// GetStrictPriority retrieves the value of the leaf StrictPriority from the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StrictPriority is set, it can
// safely use t.GetStrictPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StrictPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) GetStrictPriority() bool {
	if t == nil || t.StrictPriority == nil {
		return false
	}
	return *t.StrictPriority
}

// GetWeight retrieves the value of the leaf Weight from the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 0
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PeakRatePercent == nil {
		var v uint8 = 100
		t.PeakRatePercent = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Queue_Scheduling) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler represents the /srl_nokia-interfaces/interface/qos/output/scheduler YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Scheduler struct {
	SchedulerPolicy *string                                                           `path:"scheduler-policy" module:"srl_nokia-qos"`
	Tier            map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier `path:"tier" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Scheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) IsYANGGoStruct() {}

// NewTier creates a new entry in the Tier list of the
// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) NewTier(Level uint8) (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tier == nil {
		t.Tier = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier)
	}

	key := Level

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tier[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tier", key)
	}

	t.Tier[key] = &SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier{
		Level: &Level,
	}

	return t.Tier[key], nil
}

// RenameTier renames an entry in the list Tier within
// the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) RenameTier(oldK, newK uint8) error {
	if _, ok := t.Tier[newK]; ok {
		return fmt.Errorf("key %v already exists in Tier", newK)
	}

	e, ok := t.Tier[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tier", oldK)
	}
	e.Level = &newK

	t.Tier[newK] = e
	delete(t.Tier, oldK)
	return nil
}

// GetOrCreateTier retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) GetOrCreateTier(Level uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier {
	key := Level

	if v, ok := t.Tier[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTier(Level)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTier got unexpected error: %v", err))
	}
	return v
}

// GetTier retrieves the value with the specified key from
// the Tier map field of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) GetTier(Level uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier {
	if t == nil {
		return nil
	}

	key := Level

	if lm, ok := t.Tier[key]; ok {
		return lm
	}
	return nil
}

// DeleteTier deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) DeleteTier(Level uint8) {
	key := Level

	delete(t.Tier, key)
}

// AppendTier appends the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct to the
// list Tier of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) AppendTier(
	v *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier,
) error {
	if v.Level == nil {
		return fmt.Errorf("invalid nil key received for Level")
	}

	key := *v.Level

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tier == nil {
		t.Tier = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier)
	}

	if _, ok := t.Tier[key]; ok {
		return fmt.Errorf("duplicate key for list Tier %v", key)
	}

	t.Tier[key] = v
	return nil
}

// GetSchedulerPolicy retrieves the value of the leaf SchedulerPolicy from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SchedulerPolicy is set, it can
// safely use t.GetSchedulerPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SchedulerPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) GetSchedulerPolicy() string {
	if t == nil || t.SchedulerPolicy == nil {
		return ""
	}
	return *t.SchedulerPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Tier {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Scheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier represents the /srl_nokia-interfaces/interface/qos/output/scheduler/tier YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct {
	Level *uint8                                                                 `path:"level" module:"srl_nokia-qos"`
	Node  map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node `path:"node" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) IsYANGGoStruct() {}

// NewNode creates a new entry in the Node list of the
// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) NewNode(NodeNumber uint8) (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node)
	}

	key := NodeNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Node[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Node", key)
	}

	t.Node[key] = &SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node{
		NodeNumber: &NodeNumber,
	}

	return t.Node[key], nil
}

// RenameNode renames an entry in the list Node within
// the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) RenameNode(oldK, newK uint8) error {
	if _, ok := t.Node[newK]; ok {
		return fmt.Errorf("key %v already exists in Node", newK)
	}

	e, ok := t.Node[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Node", oldK)
	}
	e.NodeNumber = &newK

	t.Node[newK] = e
	delete(t.Node, oldK)
	return nil
}

// GetOrCreateNode retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) GetOrCreateNode(NodeNumber uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node {
	key := NodeNumber

	if v, ok := t.Node[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNode(NodeNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNode got unexpected error: %v", err))
	}
	return v
}

// GetNode retrieves the value with the specified key from
// the Node map field of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) GetNode(NodeNumber uint8) *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node {
	if t == nil {
		return nil
	}

	key := NodeNumber

	if lm, ok := t.Node[key]; ok {
		return lm
	}
	return nil
}

// DeleteNode deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) DeleteNode(NodeNumber uint8) {
	key := NodeNumber

	delete(t.Node, key)
}

// AppendNode appends the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node struct to the
// list Node of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) AppendNode(
	v *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node,
) error {
	if v.NodeNumber == nil {
		return fmt.Errorf("invalid nil key received for NodeNumber")
	}

	key := *v.NodeNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node)
	}

	if _, ok := t.Node[key]; ok {
		return fmt.Errorf("duplicate key for list Node %v", key)
	}

	t.Node[key] = v
	return nil
}

// GetLevel retrieves the value of the leaf Level from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Level is set, it can
// safely use t.GetLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Level == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) GetLevel() uint8 {
	if t == nil || t.Level == nil {
		return 0
	}
	return *t.Level
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Node {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Level == nil {
		return nil, fmt.Errorf("nil value for key Level")
	}

	return map[string]interface{}{
		"level": *t.Level,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node represents the /srl_nokia-interfaces/interface/qos/output/scheduler/tier/node YANG schema element.
type SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node struct {
	NodeNumber     *uint8 `path:"node-number" module:"srl_nokia-qos"`
	StrictPriority *bool  `path:"strict-priority" module:"srl_nokia-qos"`
	Weight         *uint8 `path:"weight" module:"srl_nokia-qos"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) IsYANGGoStruct() {}

// GetNodeNumber retrieves the value of the leaf NodeNumber from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NodeNumber is set, it can
// safely use t.GetNodeNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NodeNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) GetNodeNumber() uint8 {
	if t == nil || t.NodeNumber == nil {
		return 0
	}
	return *t.NodeNumber
}

// GetStrictPriority retrieves the value of the leaf StrictPriority from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StrictPriority is set, it can
// safely use t.GetStrictPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StrictPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) GetStrictPriority() bool {
	if t == nil || t.StrictPriority == nil {
		return false
	}
	return *t.StrictPriority
}

// GetWeight retrieves the value of the leaf Weight from the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Weight is set, it can
// safely use t.GetWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Weight == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) GetWeight() uint8 {
	if t == nil || t.Weight == nil {
		return 1
	}
	return *t.Weight
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Weight == nil {
		var v uint8 = 1
		t.Weight = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeNumber == nil {
		return nil, fmt.Errorf("nil value for key NodeNumber")
	}

	return map[string]interface{}{
		"node-number": *t.NodeNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node.
func (*SrlNokiaInterfaces_Interface_Qos_Output_Scheduler_Tier_Node) ΛBelongingModule() string {
	return "srl_nokia-qos"
}

// SrlNokiaInterfaces_Interface_Sflow represents the /srl_nokia-interfaces/interface/sflow YANG schema element.
type SrlNokiaInterfaces_Interface_Sflow struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Sflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Sflow) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Sflow) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Sflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Sflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Sflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Sflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Sflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Sflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Sflow.
func (*SrlNokiaInterfaces_Interface_Sflow) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface represents the /srl_nokia-interfaces/interface/subinterface YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface struct {
	Acl                    *SrlNokiaInterfaces_Interface_Subinterface_Acl                    `path:"acl" module:"srl_nokia-acl"`
	AdminState             E_SrlNokiaCommon_AdminState                                       `path:"admin-state" module:"srl_nokia-interfaces"`
	AnycastGw              *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw              `path:"anycast-gw" module:"srl_nokia-interfaces" yangPresence:"true"`
	BridgeTable            *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable            `path:"bridge-table" module:"srl_nokia-interfaces" yangPresence:"true"`
	Description            *string                                                           `path:"description" module:"srl_nokia-interfaces"`
	Index                  *uint32                                                           `path:"index" module:"srl_nokia-interfaces"`
	IpMtu                  *uint16                                                           `path:"ip-mtu" module:"srl_nokia-interfaces"`
	Ipv4                   *SrlNokiaInterfaces_Interface_Subinterface_Ipv4                   `path:"ipv4" module:"srl_nokia-interfaces" yangPresence:"true"`
	Ipv6                   *SrlNokiaInterfaces_Interface_Subinterface_Ipv6                   `path:"ipv6" module:"srl_nokia-interfaces" yangPresence:"true"`
	L2Mtu                  *uint16                                                           `path:"l2-mtu" module:"srl_nokia-interfaces"`
	LocalMirrorDestination *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination `path:"local-mirror-destination" module:"srl_nokia-interfaces-local-mirror-destination" yangPresence:"true"`
	MplsMtu                *uint16                                                           `path:"mpls-mtu" module:"srl_nokia-interfaces"`
	Qos                    *SrlNokiaInterfaces_Interface_Subinterface_Qos                    `path:"qos" module:"srl_nokia-qos"`
	RaGuard                *SrlNokiaInterfaces_Interface_Subinterface_RaGuard                `path:"ra-guard" module:"srl_nokia-ra_guard" yangPresence:"true"`
	Type                   E_SrlNokiaInterfaces_SiType                                       `path:"type" module:"srl_nokia-interfaces"`
	Uuid                   *string                                                           `path:"uuid" module:"srl_nokia-interfaces-vxdp"`
	Vlan                   *SrlNokiaInterfaces_Interface_Subinterface_Vlan                   `path:"vlan" module:"srl_nokia-interfaces-vlans"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface) IsYANGGoStruct() {}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateAcl() *SrlNokiaInterfaces_Interface_Subinterface_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &SrlNokiaInterfaces_Interface_Subinterface_Acl{}
	return t.Acl
}

// GetOrCreateAnycastGw retrieves the value of the AnycastGw field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateAnycastGw() *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw {
	if t.AnycastGw != nil {
		return t.AnycastGw
	}
	t.AnycastGw = &SrlNokiaInterfaces_Interface_Subinterface_AnycastGw{}
	return t.AnycastGw
}

// GetOrCreateBridgeTable retrieves the value of the BridgeTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateBridgeTable() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable {
	if t.BridgeTable != nil {
		return t.BridgeTable
	}
	t.BridgeTable = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable{}
	return t.BridgeTable
}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateIpv4() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateIpv6() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6{}
	return t.Ipv6
}

// GetOrCreateLocalMirrorDestination retrieves the value of the LocalMirrorDestination field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateLocalMirrorDestination() *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination {
	if t.LocalMirrorDestination != nil {
		return t.LocalMirrorDestination
	}
	t.LocalMirrorDestination = &SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination{}
	return t.LocalMirrorDestination
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateQos() *SrlNokiaInterfaces_Interface_Subinterface_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &SrlNokiaInterfaces_Interface_Subinterface_Qos{}
	return t.Qos
}

// GetOrCreateRaGuard retrieves the value of the RaGuard field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateRaGuard() *SrlNokiaInterfaces_Interface_Subinterface_RaGuard {
	if t.RaGuard != nil {
		return t.RaGuard
	}
	t.RaGuard = &SrlNokiaInterfaces_Interface_Subinterface_RaGuard{}
	return t.RaGuard
}

// GetOrCreateVlan retrieves the value of the Vlan field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetOrCreateVlan() *SrlNokiaInterfaces_Interface_Subinterface_Vlan {
	if t.Vlan != nil {
		return t.Vlan
	}
	t.Vlan = &SrlNokiaInterfaces_Interface_Subinterface_Vlan{}
	return t.Vlan
}

// GetAcl returns the value of the Acl struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetAcl() *SrlNokiaInterfaces_Interface_Subinterface_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetAnycastGw returns the value of the AnycastGw struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field AnycastGw is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetAnycastGw() *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw {
	if t != nil && t.AnycastGw != nil {
		return t.AnycastGw
	}
	return nil
}

// GetBridgeTable returns the value of the BridgeTable struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field BridgeTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetBridgeTable() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable {
	if t != nil && t.BridgeTable != nil {
		return t.BridgeTable
	}
	return nil
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIpv4() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIpv6() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetLocalMirrorDestination returns the value of the LocalMirrorDestination struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field LocalMirrorDestination is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetLocalMirrorDestination() *SrlNokiaInterfaces_Interface_Subinterface_LocalMirrorDestination {
	if t != nil && t.LocalMirrorDestination != nil {
		return t.LocalMirrorDestination
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetQos() *SrlNokiaInterfaces_Interface_Subinterface_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetRaGuard returns the value of the RaGuard struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field RaGuard is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetRaGuard() *SrlNokiaInterfaces_Interface_Subinterface_RaGuard {
	if t != nil && t.RaGuard != nil {
		return t.RaGuard
	}
	return nil
}

// GetVlan returns the value of the Vlan struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface. If the receiver or the field Vlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetVlan() *SrlNokiaInterfaces_Interface_Subinterface_Vlan {
	if t != nil && t.Vlan != nil {
		return t.Vlan
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetIpMtu retrieves the value of the leaf IpMtu from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMtu is set, it can
// safely use t.GetIpMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetIpMtu() uint16 {
	if t == nil || t.IpMtu == nil {
		return 0
	}
	return *t.IpMtu
}

// GetL2Mtu retrieves the value of the leaf L2Mtu from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2Mtu is set, it can
// safely use t.GetL2Mtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2Mtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetL2Mtu() uint16 {
	if t == nil || t.L2Mtu == nil {
		return 0
	}
	return *t.L2Mtu
}

// GetMplsMtu retrieves the value of the leaf MplsMtu from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsMtu is set, it can
// safely use t.GetMplsMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetMplsMtu() uint16 {
	if t == nil || t.MplsMtu == nil {
		return 0
	}
	return *t.MplsMtu
}

// GetType retrieves the value of the leaf Type from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetType() E_SrlNokiaInterfaces_SiType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// GetUuid retrieves the value of the leaf Uuid from the SrlNokiaInterfaces_Interface_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Uuid is set, it can
// safely use t.GetUuid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Uuid == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface) GetUuid() string {
	if t == nil || t.Uuid == nil {
		return ""
	}
	return *t.Uuid
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.Acl.PopulateDefaults()
	t.AnycastGw.PopulateDefaults()
	t.BridgeTable.PopulateDefaults()
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
	t.LocalMirrorDestination.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.RaGuard.PopulateDefaults()
	t.Vlan.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface.
func (*SrlNokiaInterfaces_Interface_Subinterface) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Acl represents the /srl_nokia-interfaces/interface/subinterface/acl YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Acl struct {
	Input  *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input  `path:"input" module:"srl_nokia-acl"`
	Output *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output `path:"output" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl) IsYANGGoStruct() {}

// GetOrCreateInput retrieves the value of the Input field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetOrCreateInput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input {
	if t.Input != nil {
		return t.Input
	}
	t.Input = &SrlNokiaInterfaces_Interface_Subinterface_Acl_Input{}
	return t.Input
}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetOrCreateOutput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &SrlNokiaInterfaces_Interface_Subinterface_Acl_Output{}
	return t.Output
}

// GetInput returns the value of the Input struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Acl. If the receiver or the field Input is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetInput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input {
	if t != nil && t.Input != nil {
		return t.Input
	}
	return nil
}

// GetOutput returns the value of the Output struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Acl. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) GetOutput() *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Acl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Input.PopulateDefaults()
	t.Output.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Acl.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaInterfaces_Interface_Subinterface_Acl_Input represents the /srl_nokia-interfaces/interface/subinterface/acl/input YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Acl_Input struct {
	Ipv4Filter *string `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter *string `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter  *string `path:"mac-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Acl_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) IsYANGGoStruct() {}

// GetIpv4Filter retrieves the value of the leaf Ipv4Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Filter is set, it can
// safely use t.GetIpv4Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) GetIpv4Filter() string {
	if t == nil || t.Ipv4Filter == nil {
		return ""
	}
	return *t.Ipv4Filter
}

// GetIpv6Filter retrieves the value of the leaf Ipv6Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Filter is set, it can
// safely use t.GetIpv6Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) GetIpv6Filter() string {
	if t == nil || t.Ipv6Filter == nil {
		return ""
	}
	return *t.Ipv6Filter
}

// GetMacFilter retrieves the value of the leaf MacFilter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacFilter is set, it can
// safely use t.GetMacFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacFilter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) GetMacFilter() string {
	if t == nil || t.MacFilter == nil {
		return ""
	}
	return *t.MacFilter
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Acl_Input
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Acl_Input.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaInterfaces_Interface_Subinterface_Acl_Output represents the /srl_nokia-interfaces/interface/subinterface/acl/output YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Acl_Output struct {
	Ipv4Filter *string `path:"ipv4-filter" module:"srl_nokia-acl"`
	Ipv6Filter *string `path:"ipv6-filter" module:"srl_nokia-acl"`
	MacFilter  *string `path:"mac-filter" module:"srl_nokia-acl"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Acl_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) IsYANGGoStruct() {}

// GetIpv4Filter retrieves the value of the leaf Ipv4Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Filter is set, it can
// safely use t.GetIpv4Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) GetIpv4Filter() string {
	if t == nil || t.Ipv4Filter == nil {
		return ""
	}
	return *t.Ipv4Filter
}

// GetIpv6Filter retrieves the value of the leaf Ipv6Filter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Filter is set, it can
// safely use t.GetIpv6Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) GetIpv6Filter() string {
	if t == nil || t.Ipv6Filter == nil {
		return ""
	}
	return *t.Ipv6Filter
}

// GetMacFilter retrieves the value of the leaf MacFilter from the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacFilter is set, it can
// safely use t.GetMacFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacFilter == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) GetMacFilter() string {
	if t == nil || t.MacFilter == nil {
		return ""
	}
	return *t.MacFilter
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Acl_Output
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Acl_Output.
func (*SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) ΛBelongingModule() string {
	return "srl_nokia-acl"
}

// SrlNokiaInterfaces_Interface_Subinterface_AnycastGw represents the /srl_nokia-interfaces/interface/subinterface/anycast-gw YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_AnycastGw struct {
	AnycastGwMac    *string `path:"anycast-gw-mac" module:"srl_nokia-interfaces"`
	VirtualRouterId *uint8  `path:"virtual-router-id" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_AnycastGw implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) IsYANGGoStruct() {}

// GetAnycastGwMac retrieves the value of the leaf AnycastGwMac from the SrlNokiaInterfaces_Interface_Subinterface_AnycastGw
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGwMac is set, it can
// safely use t.GetAnycastGwMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGwMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) GetAnycastGwMac() string {
	if t == nil || t.AnycastGwMac == nil {
		return ""
	}
	return *t.AnycastGwMac
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the SrlNokiaInterfaces_Interface_Subinterface_AnycastGw
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 1
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_AnycastGw
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.VirtualRouterId == nil {
		var v uint8 = 1
		t.VirtualRouterId = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_AnycastGw"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_AnycastGw.
func (*SrlNokiaInterfaces_Interface_Subinterface_AnycastGw) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable represents the /srl_nokia-interfaces/interface/subinterface/bridge-table YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable struct {
	DiscardUnknownSrcMac *bool                                                                 `path:"discard-unknown-src-mac" module:"srl_nokia-interfaces"`
	MacDuplication       *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication `path:"mac-duplication" module:"srl_nokia-interfaces"`
	MacLearning          *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning    `path:"mac-learning" module:"srl_nokia-interfaces"`
	MacLimit             *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit       `path:"mac-limit" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) IsYANGGoStruct() {}

// GetOrCreateMacDuplication retrieves the value of the MacDuplication field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetOrCreateMacDuplication() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication {
	if t.MacDuplication != nil {
		return t.MacDuplication
	}
	t.MacDuplication = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication{}
	return t.MacDuplication
}

// GetOrCreateMacLearning retrieves the value of the MacLearning field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetOrCreateMacLearning() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning {
	if t.MacLearning != nil {
		return t.MacLearning
	}
	t.MacLearning = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning{}
	return t.MacLearning
}

// GetOrCreateMacLimit retrieves the value of the MacLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetOrCreateMacLimit() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit {
	if t.MacLimit != nil {
		return t.MacLimit
	}
	t.MacLimit = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit{}
	return t.MacLimit
}

// GetMacDuplication returns the value of the MacDuplication struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable. If the receiver or the field MacDuplication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetMacDuplication() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication {
	if t != nil && t.MacDuplication != nil {
		return t.MacDuplication
	}
	return nil
}

// GetMacLearning returns the value of the MacLearning struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable. If the receiver or the field MacLearning is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetMacLearning() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning {
	if t != nil && t.MacLearning != nil {
		return t.MacLearning
	}
	return nil
}

// GetMacLimit returns the value of the MacLimit struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable. If the receiver or the field MacLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetMacLimit() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit {
	if t != nil && t.MacLimit != nil {
		return t.MacLimit
	}
	return nil
}

// GetDiscardUnknownSrcMac retrieves the value of the leaf DiscardUnknownSrcMac from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DiscardUnknownSrcMac is set, it can
// safely use t.GetDiscardUnknownSrcMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DiscardUnknownSrcMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) GetDiscardUnknownSrcMac() bool {
	if t == nil || t.DiscardUnknownSrcMac == nil {
		return false
	}
	return *t.DiscardUnknownSrcMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DiscardUnknownSrcMac == nil {
		var v bool = false
		t.DiscardUnknownSrcMac = &v
	}
	t.MacDuplication.PopulateDefaults()
	t.MacLearning.PopulateDefaults()
	t.MacLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-duplication YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication struct {
	Action E_SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action `path:"action" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) GetAction() E_SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action {
	if t == nil || t.Action == 0 {
		return SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action_use_net_instance_action
	}
	return t.Action
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication_Action_use_net_instance_action
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacDuplication) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-learning YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning struct {
	AdminState E_SrlNokiaCommon_AdminState                                              `path:"admin-state" module:"srl_nokia-interfaces"`
	Aging      *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging `path:"aging" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) IsYANGGoStruct() {}

// GetOrCreateAging retrieves the value of the Aging field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) GetOrCreateAging() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging {
	if t.Aging != nil {
		return t.Aging
	}
	t.Aging = &SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging{}
	return t.Aging
}

// GetAging returns the value of the Aging struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning. If the receiver or the field Aging is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) GetAging() *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging {
	if t != nil && t.Aging != nil {
		return t.Aging
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.Aging.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-learning/aging YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLearning_Aging) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit represents the /srl_nokia-interfaces/interface/subinterface/bridge-table/mac-limit YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit struct {
	MaximumEntries      *int32 `path:"maximum-entries" module:"srl_nokia-interfaces"`
	WarningThresholdPct *int32 `path:"warning-threshold-pct" module:"srl_nokia-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) IsYANGGoStruct() {}

// GetMaximumEntries retrieves the value of the leaf MaximumEntries from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumEntries is set, it can
// safely use t.GetMaximumEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumEntries == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) GetMaximumEntries() int32 {
	if t == nil || t.MaximumEntries == nil {
		return 250
	}
	return *t.MaximumEntries
}

// GetWarningThresholdPct retrieves the value of the leaf WarningThresholdPct from the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WarningThresholdPct is set, it can
// safely use t.GetWarningThresholdPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WarningThresholdPct == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) GetWarningThresholdPct() int32 {
	if t == nil || t.WarningThresholdPct == nil {
		return 95
	}
	return *t.WarningThresholdPct
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaximumEntries == nil {
		var v int32 = 250
		t.MaximumEntries = &v
	}
	if t.WarningThresholdPct == nil {
		var v int32 = 95
		t.WarningThresholdPct = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit.
func (*SrlNokiaInterfaces_Interface_Subinterface_BridgeTable_MacLimit) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4 represents the /srl_nokia-interfaces/interface/subinterface/ipv4 YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4 struct {
	Address                map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address `path:"address" module:"srl_nokia-interfaces"`
	AllowDirectedBroadcast *bool                                                              `path:"allow-directed-broadcast" module:"srl_nokia-interfaces"`
	Arp                    *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp                `path:"arp" module:"srl_nokia-interfaces-nbr"`
	DhcpClient             *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient         `path:"dhcp-client" module:"srl_nokia-interfaces-ip-dhcp" yangPresence:"true"`
	DhcpRelay              *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay          `path:"dhcp-relay" module:"srl_nokia-interfaces-ip-dhcp-relay" yangPresence:"true"`
	DhcpServer             *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer         `path:"dhcp-server" module:"srl_nokia-interfaces-ip-dhcp-server" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) NewAddress(IpPrefix string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address{
		IpPrefix: &IpPrefix,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.IpPrefix = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address {
	key := IpPrefix

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(IpPrefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address {
	if t == nil {
		return nil
	}

	key := IpPrefix

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) DeleteAddress(IpPrefix string) {
	key := IpPrefix

	delete(t.Address, key)
}

// AppendAddress appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address struct to the
// list Address of SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) AppendAddress(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address,
) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key received for IpPrefix")
	}

	key := *v.IpPrefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// GetOrCreateArp retrieves the value of the Arp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateArp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp {
	if t.Arp != nil {
		return t.Arp
	}
	t.Arp = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp{}
	return t.Arp
}

// GetOrCreateDhcpClient retrieves the value of the DhcpClient field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient {
	if t.DhcpClient != nil {
		return t.DhcpClient
	}
	t.DhcpClient = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient{}
	return t.DhcpClient
}

// GetOrCreateDhcpRelay retrieves the value of the DhcpRelay field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay {
	if t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	t.DhcpRelay = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay{}
	return t.DhcpRelay
}

// GetOrCreateDhcpServer retrieves the value of the DhcpServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetOrCreateDhcpServer() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer {
	if t.DhcpServer != nil {
		return t.DhcpServer
	}
	t.DhcpServer = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer{}
	return t.DhcpServer
}

// GetArp returns the value of the Arp struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field Arp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetArp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp {
	if t != nil && t.Arp != nil {
		return t.Arp
	}
	return nil
}

// GetDhcpClient returns the value of the DhcpClient struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field DhcpClient is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient {
	if t != nil && t.DhcpClient != nil {
		return t.DhcpClient
	}
	return nil
}

// GetDhcpRelay returns the value of the DhcpRelay struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field DhcpRelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay {
	if t != nil && t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	return nil
}

// GetDhcpServer returns the value of the DhcpServer struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4. If the receiver or the field DhcpServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetDhcpServer() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer {
	if t != nil && t.DhcpServer != nil {
		return t.DhcpServer
	}
	return nil
}

// GetAllowDirectedBroadcast retrieves the value of the leaf AllowDirectedBroadcast from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowDirectedBroadcast is set, it can
// safely use t.GetAllowDirectedBroadcast() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowDirectedBroadcast == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) GetAllowDirectedBroadcast() bool {
	if t == nil || t.AllowDirectedBroadcast == nil {
		return false
	}
	return *t.AllowDirectedBroadcast
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllowDirectedBroadcast == nil {
		var v bool = false
		t.AllowDirectedBroadcast = &v
	}
	t.Arp.PopulateDefaults()
	t.DhcpClient.PopulateDefaults()
	t.DhcpRelay.PopulateDefaults()
	t.DhcpServer.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address struct {
	AnycastGw *bool                                                        `path:"anycast-gw" module:"srl_nokia-interfaces"`
	IpPrefix  *string                                                      `path:"ip-prefix" module:"srl_nokia-interfaces"`
	Primary   YANGEmpty                                                    `path:"primary" module:"srl_nokia-interfaces"`
	Vrrp      *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp `path:"vrrp" module:"srl_nokia-interfaces-ip-vrrp" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) IsYANGGoStruct() {}

// GetOrCreateVrrp retrieves the value of the Vrrp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetOrCreateVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp {
	if t.Vrrp != nil {
		return t.Vrrp
	}
	t.Vrrp = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp{}
	return t.Vrrp
}

// GetVrrp returns the value of the Vrrp struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address. If the receiver or the field Vrrp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp {
	if t != nil && t.Vrrp != nil {
		return t.Vrrp
	}
	return nil
}

// GetAnycastGw retrieves the value of the leaf AnycastGw from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGw is set, it can
// safely use t.GetAnycastGw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGw == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetAnycastGw() bool {
	if t == nil || t.AnycastGw == nil {
		return false
	}
	return *t.AnycastGw
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetPrimary retrieves the value of the leaf Primary from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Primary is set, it can
// safely use t.GetPrimary() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Primary == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) GetPrimary() YANGEmpty {
	if t == nil || t.Primary == false {
		return false
	}
	return t.Primary
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Vrrp.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp struct {
	VrrpGroup map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup `path:"vrrp-group" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) NewVrrpGroup(
	VirtualRouterId uint8,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) GetOrCreateVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup {
	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) GetVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup {
	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup struct to the
// list VrrpGroup of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) AppendVrrpGroup(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup,
) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup struct {
	AcceptMode            *bool                                                                                    `path:"accept-mode" module:"srl_nokia-interfaces-ip-vrrp"`
	AdminState            E_SrlNokiaCommon_AdminState                                                              `path:"admin-state" module:"srl_nokia-interfaces-ip-vrrp"`
	AdvertiseInterval     *uint16                                                                                  `path:"advertise-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Authentication        *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication    `path:"authentication" module:"srl_nokia-interfaces-ip-vrrp"`
	InitDelay             *uint16                                                                                  `path:"init-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	InterfaceTracking     *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"srl_nokia-interfaces-ip-vrrp"`
	MasterInheritInterval *bool                                                                                    `path:"master-inherit-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	OperInterval          *uint16                                                                                  `path:"oper-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Preempt               *bool                                                                                    `path:"preempt" module:"srl_nokia-interfaces-ip-vrrp"`
	PreemptDelay          *uint16                                                                                  `path:"preempt-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	Priority              *uint8                                                                                   `path:"priority" module:"srl_nokia-interfaces-ip-vrrp"`
	Statistics            *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics        `path:"statistics" module:"srl_nokia-interfaces-ip-vrrp"`
	Version               *uint8                                                                                   `path:"version" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualAddress        []string                                                                                 `path:"virtual-address" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualRouterId       *uint8                                                                                   `path:"virtual-router-id" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOrCreateAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication{}
	return t.Authentication
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOrCreateInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetOrCreateStatistics retrieves the value of the Statistics field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOrCreateStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics {
	if t.Statistics != nil {
		return t.Statistics
	}
	t.Statistics = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics{}
	return t.Statistics
}

// GetAuthentication returns the value of the Authentication struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetStatistics returns the value of the Statistics struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup. If the receiver or the field Statistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics {
	if t != nil && t.Statistics != nil {
		return t.Statistics
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetAdvertiseInterval retrieves the value of the leaf AdvertiseInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertiseInterval is set, it can
// safely use t.GetAdvertiseInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertiseInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetAdvertiseInterval() uint16 {
	if t == nil || t.AdvertiseInterval == nil {
		return 1000
	}
	return *t.AdvertiseInterval
}

// GetInitDelay retrieves the value of the leaf InitDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InitDelay is set, it can
// safely use t.GetInitDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InitDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetInitDelay() uint16 {
	if t == nil || t.InitDelay == nil {
		return 0
	}
	return *t.InitDelay
}

// GetMasterInheritInterval retrieves the value of the leaf MasterInheritInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MasterInheritInterval is set, it can
// safely use t.GetMasterInheritInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MasterInheritInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetMasterInheritInterval() bool {
	if t == nil || t.MasterInheritInterval == nil {
		return false
	}
	return *t.MasterInheritInterval
}

// GetOperInterval retrieves the value of the leaf OperInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperInterval is set, it can
// safely use t.GetOperInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetOperInterval() uint16 {
	if t == nil || t.OperInterval == nil {
		return 0
	}
	return *t.OperInterval
}

// GetPreempt retrieves the value of the leaf Preempt from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return false
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVersion retrieves the value of the leaf Version from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Version is set, it can
// safely use t.GetVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Version == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetVersion() uint8 {
	if t == nil || t.Version == nil {
		return 2
	}
	return *t.Version
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.AdvertiseInterval == nil {
		var v uint16 = 1000
		t.AdvertiseInterval = &v
	}
	if t.MasterInheritInterval == nil {
		var v bool = false
		t.MasterInheritInterval = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	if t.Version == nil {
		var v uint8 = 2
		t.Version = &v
	}
	t.Authentication.PopulateDefaults()
	t.InterfaceTracking.PopulateDefaults()
	t.Statistics.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/authentication YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication struct {
	Keychain *string `path:"keychain" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) IsYANGGoStruct() {
}

// GetKeychain retrieves the value of the leaf Keychain from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Keychain is set, it can
// safely use t.GetKeychain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Keychain == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) GetKeychain() string {
	if t == nil || t.Keychain == nil {
		return ""
	}
	return *t.Keychain
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Authentication) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking struct {
	TrackInterface map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface `path:"track-interface" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {
}

// NewTrackInterface creates a new entry in the TrackInterface list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) NewTrackInterface(
	Interface string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrackInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrackInterface", key)
	}

	t.TrackInterface[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface{
		Interface: &Interface,
	}

	return t.TrackInterface[key], nil
}

// RenameTrackInterface renames an entry in the list TrackInterface within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) RenameTrackInterface(oldK, newK string) error {
	if _, ok := t.TrackInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TrackInterface", newK)
	}

	e, ok := t.TrackInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrackInterface", oldK)
	}
	e.Interface = &newK

	t.TrackInterface[newK] = e
	delete(t.TrackInterface, oldK)
	return nil
}

// GetOrCreateTrackInterface retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) GetOrCreateTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	key := Interface

	if v, ok := t.TrackInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrackInterface(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrackInterface got unexpected error: %v", err))
	}
	return v
}

// GetTrackInterface retrieves the value with the specified key from
// the TrackInterface map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) GetTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.TrackInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteTrackInterface deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) DeleteTrackInterface(Interface string) {
	key := Interface

	delete(t.TrackInterface, key)
}

// AppendTrackInterface appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct to the
// list TrackInterface of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) AppendTrackInterface(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface,
) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	if _, ok := t.TrackInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TrackInterface %v", key)
	}

	t.TrackInterface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.TrackInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/interface-tracking/track-interface YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct {
	Interface         *string `path:"interface" module:"srl_nokia-interfaces-ip-vrrp"`
	PriorityDecrement *uint8  `path:"priority-decrement" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics represents the /srl_nokia-interfaces/interface/subinterface/ipv4/address/vrrp/vrrp-group/statistics YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics struct{}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address_Vrrp_VrrpGroup_Statistics) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp struct {
	Debug                     []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Debug             `path:"debug" module:"srl_nokia-interfaces-nbr"`
	DuplicateAddressDetection *bool                                                                    `path:"duplicate-address-detection" module:"srl_nokia-interfaces-nbr"`
	Evpn                      *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn                 `path:"evpn" module:"srl_nokia-interfaces-nbr-evpn" yangPresence:"true"`
	HostRoute                 *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute            `path:"host-route" module:"srl_nokia-interfaces-nbr"`
	LearnUnsolicited          *bool                                                                    `path:"learn-unsolicited" module:"srl_nokia-interfaces-nbr"`
	Neighbor                  map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor  `path:"neighbor" module:"srl_nokia-interfaces-nbr"`
	ProxyArp                  *bool                                                                    `path:"proxy-arp" module:"srl_nokia-interfaces-nbr"`
	Timeout                   *uint16                                                                  `path:"timeout" module:"srl_nokia-interfaces-nbr"`
	VirtualIpv4Discovery      *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery `path:"virtual-ipv4-discovery" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) NewNeighbor(Ipv4Address string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor)
	}

	key := Ipv4Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor{
		Ipv4Address: &Ipv4Address,
	}

	return t.Neighbor[key], nil
}

// RenameNeighbor renames an entry in the list Neighbor within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) RenameNeighbor(oldK, newK string) error {
	if _, ok := t.Neighbor[newK]; ok {
		return fmt.Errorf("key %v already exists in Neighbor", newK)
	}

	e, ok := t.Neighbor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Neighbor", oldK)
	}
	e.Ipv4Address = &newK

	t.Neighbor[newK] = e
	delete(t.Neighbor, oldK)
	return nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateNeighbor(Ipv4Address string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor {
	key := Ipv4Address

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(Ipv4Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetNeighbor(Ipv4Address string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor {
	if t == nil {
		return nil
	}

	key := Ipv4Address

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) DeleteNeighbor(Ipv4Address string) {
	key := Ipv4Address

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor struct to the
// list Neighbor of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) AppendNeighbor(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor,
) error {
	if v.Ipv4Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv4Address")
	}

	key := *v.Ipv4Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateEvpn() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn{}
	return t.Evpn
}

// GetOrCreateHostRoute retrieves the value of the HostRoute field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateHostRoute() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute {
	if t.HostRoute != nil {
		return t.HostRoute
	}
	t.HostRoute = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute{}
	return t.HostRoute
}

// GetOrCreateVirtualIpv4Discovery retrieves the value of the VirtualIpv4Discovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetOrCreateVirtualIpv4Discovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery {
	if t.VirtualIpv4Discovery != nil {
		return t.VirtualIpv4Discovery
	}
	t.VirtualIpv4Discovery = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery{}
	return t.VirtualIpv4Discovery
}

// GetEvpn returns the value of the Evpn struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetEvpn() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetHostRoute returns the value of the HostRoute struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver or the field HostRoute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetHostRoute() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute {
	if t != nil && t.HostRoute != nil {
		return t.HostRoute
	}
	return nil
}

// GetVirtualIpv4Discovery returns the value of the VirtualIpv4Discovery struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp. If the receiver or the field VirtualIpv4Discovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetVirtualIpv4Discovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery {
	if t != nil && t.VirtualIpv4Discovery != nil {
		return t.VirtualIpv4Discovery
	}
	return nil
}

// GetDebug retrieves the value of the leaf Debug from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Debug is set, it can
// safely use t.GetDebug() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Debug == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetDebug() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Debug {
	if t == nil || t.Debug == nil {
		return nil
	}
	return t.Debug
}

// GetDuplicateAddressDetection retrieves the value of the leaf DuplicateAddressDetection from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DuplicateAddressDetection is set, it can
// safely use t.GetDuplicateAddressDetection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DuplicateAddressDetection == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetDuplicateAddressDetection() bool {
	if t == nil || t.DuplicateAddressDetection == nil {
		return true
	}
	return *t.DuplicateAddressDetection
}

// GetLearnUnsolicited retrieves the value of the leaf LearnUnsolicited from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LearnUnsolicited is set, it can
// safely use t.GetLearnUnsolicited() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LearnUnsolicited == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetLearnUnsolicited() bool {
	if t == nil || t.LearnUnsolicited == nil {
		return false
	}
	return *t.LearnUnsolicited
}

// GetProxyArp retrieves the value of the leaf ProxyArp from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProxyArp is set, it can
// safely use t.GetProxyArp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProxyArp == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetProxyArp() bool {
	if t == nil || t.ProxyArp == nil {
		return false
	}
	return *t.ProxyArp
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 14400
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DuplicateAddressDetection == nil {
		var v bool = true
		t.DuplicateAddressDetection = &v
	}
	if t.LearnUnsolicited == nil {
		var v bool = false
		t.LearnUnsolicited = &v
	}
	if t.ProxyArp == nil {
		var v bool = false
		t.ProxyArp = &v
	}
	if t.Timeout == nil {
		var v uint16 = 14400
		t.Timeout = &v
	}
	t.Evpn.PopulateDefaults()
	t.HostRoute.PopulateDefaults()
	t.VirtualIpv4Discovery.PopulateDefaults()
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/evpn YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn struct {
	Advertise map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise `path:"advertise" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) IsYANGGoStruct() {}

// NewAdvertise creates a new entry in the Advertise list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) NewAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Advertise == nil {
		t.Advertise = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise)
	}

	key := RouteType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Advertise[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Advertise", key)
	}

	t.Advertise[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise{
		RouteType: RouteType,
	}

	return t.Advertise[key], nil
}

// RenameAdvertise renames an entry in the list Advertise within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) RenameAdvertise(
	oldK, newK E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) error {
	if _, ok := t.Advertise[newK]; ok {
		return fmt.Errorf("key %v already exists in Advertise", newK)
	}

	e, ok := t.Advertise[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Advertise", oldK)
	}
	e.RouteType = newK

	t.Advertise[newK] = e
	delete(t.Advertise, oldK)
	return nil
}

// GetOrCreateAdvertise retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) GetOrCreateAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise {
	key := RouteType

	if v, ok := t.Advertise[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdvertise(RouteType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdvertise got unexpected error: %v", err))
	}
	return v
}

// GetAdvertise retrieves the value with the specified key from
// the Advertise map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) GetAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise {
	if t == nil {
		return nil
	}

	key := RouteType

	if lm, ok := t.Advertise[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdvertise deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) DeleteAdvertise(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType,
) {
	key := RouteType

	delete(t.Advertise, key)
}

// AppendAdvertise appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise struct to the
// list Advertise of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) AppendAdvertise(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise,
) error {
	key := v.RouteType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Advertise == nil {
		t.Advertise = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise)
	}

	if _, ok := t.Advertise[key]; ok {
		return fmt.Errorf("duplicate key for list Advertise %v", key)
	}

	t.Advertise[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Advertise {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/evpn/advertise YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise struct {
	AdminTag  *uint32                                                                       `path:"admin-tag" module:"srl_nokia-interfaces-nbr-evpn"`
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType `path:"route-type" module:"srl_nokia-interfaces-nbr-evpn"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) IsYANGGoStruct() {}

// GetAdminTag retrieves the value of the leaf AdminTag from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminTag is set, it can
// safely use t.GetAdminTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminTag == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) GetAdminTag() uint32 {
	if t == nil || t.AdminTag == nil {
		return 0
	}
	return *t.AdminTag
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) GetRouteType() E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise_RouteType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminTag == nil {
		var v uint32 = 0
		t.AdminTag = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"route-type": t.RouteType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Evpn_Advertise) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-evpn"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/host-route YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute struct {
	Populate map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate `path:"populate" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) IsYANGGoStruct() {}

// NewPopulate creates a new entry in the Populate list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) NewPopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Populate == nil {
		t.Populate = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate)
	}

	key := RouteType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Populate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Populate", key)
	}

	t.Populate[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate{
		RouteType: RouteType,
	}

	return t.Populate[key], nil
}

// RenamePopulate renames an entry in the list Populate within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) RenamePopulate(
	oldK, newK E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) error {
	if _, ok := t.Populate[newK]; ok {
		return fmt.Errorf("key %v already exists in Populate", newK)
	}

	e, ok := t.Populate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Populate", oldK)
	}
	e.RouteType = newK

	t.Populate[newK] = e
	delete(t.Populate, oldK)
	return nil
}

// GetOrCreatePopulate retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) GetOrCreatePopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate {
	key := RouteType

	if v, ok := t.Populate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPopulate(RouteType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePopulate got unexpected error: %v", err))
	}
	return v
}

// GetPopulate retrieves the value with the specified key from
// the Populate map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) GetPopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate {
	if t == nil {
		return nil
	}

	key := RouteType

	if lm, ok := t.Populate[key]; ok {
		return lm
	}
	return nil
}

// DeletePopulate deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) DeletePopulate(
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType,
) {
	key := RouteType

	delete(t.Populate, key)
}

// AppendPopulate appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate struct to the
// list Populate of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) AppendPopulate(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate,
) error {
	key := v.RouteType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Populate == nil {
		t.Populate = make(map[E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate)
	}

	if _, ok := t.Populate[key]; ok {
		return fmt.Errorf("duplicate key for list Populate %v", key)
	}

	t.Populate[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Populate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/host-route/populate YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate struct {
	AdminTag  *uint32                                                                           `path:"admin-tag" module:"srl_nokia-interfaces-nbr"`
	RouteType E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType `path:"route-type" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) IsYANGGoStruct() {}

// GetAdminTag retrieves the value of the leaf AdminTag from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminTag is set, it can
// safely use t.GetAdminTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminTag == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) GetAdminTag() uint32 {
	if t == nil || t.AdminTag == nil {
		return 0
	}
	return *t.AdminTag
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) GetRouteType() E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate_RouteType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"route-type": t.RouteType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_HostRoute_Populate) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/neighbor YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor struct {
	Ipv4Address      *string `path:"ipv4-address" module:"srl_nokia-interfaces-nbr"`
	LinkLayerAddress *string `path:"link-layer-address" module:"srl_nokia-interfaces-nbr"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) IsYANGGoStruct() {}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv4Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Address")
	}

	return map[string]interface{}{
		"ipv4-address": *t.Ipv4Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/virtual-ipv4-discovery YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery struct {
	Address map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address `path:"address" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) NewAddress(
	Ipv4Address string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address)
	}

	key := Ipv4Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address{
		Ipv4Address: &Ipv4Address,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.Ipv4Address = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) GetOrCreateAddress(
	Ipv4Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address {
	key := Ipv4Address

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(Ipv4Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) GetAddress(
	Ipv4Address string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address {
	if t == nil {
		return nil
	}

	key := Ipv4Address

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) DeleteAddress(Ipv4Address string) {
	key := Ipv4Address

	delete(t.Address, key)
}

// AppendAddress appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address struct to the
// list Address of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) AppendAddress(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address,
) error {
	if v.Ipv4Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv4Address")
	}

	key := *v.Ipv4Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-virtual-ip-discovery"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address represents the /srl_nokia-interfaces/interface/subinterface/ipv4/arp/virtual-ipv4-discovery/address YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address struct {
	AllowedMacs               []string `path:"allowed-macs" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	Ipv4Address               *string  `path:"ipv4-address" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	ProbeBridgedSubinterfaces []string `path:"probe-bridged-subinterfaces" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
	ProbeInterval             *uint32  `path:"probe-interval" module:"srl_nokia-interfaces-nbr-virtual-ip-discovery"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) IsYANGGoStruct() {
}

// GetAllowedMacs retrieves the value of the leaf AllowedMacs from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowedMacs is set, it can
// safely use t.GetAllowedMacs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowedMacs == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetAllowedMacs() []string {
	if t == nil || t.AllowedMacs == nil {
		return nil
	}
	return t.AllowedMacs
}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetProbeBridgedSubinterfaces retrieves the value of the leaf ProbeBridgedSubinterfaces from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProbeBridgedSubinterfaces is set, it can
// safely use t.GetProbeBridgedSubinterfaces() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProbeBridgedSubinterfaces == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetProbeBridgedSubinterfaces() []string {
	if t == nil || t.ProbeBridgedSubinterfaces == nil {
		return nil
	}
	return t.ProbeBridgedSubinterfaces
}

// GetProbeInterval retrieves the value of the leaf ProbeInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProbeInterval is set, it can
// safely use t.GetProbeInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProbeInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) GetProbeInterval() uint32 {
	if t == nil || t.ProbeInterval == nil {
		return 0
	}
	return *t.ProbeInterval
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ProbeInterval == nil {
		var v uint32 = 0
		t.ProbeInterval = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv4Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Address")
	}

	return map[string]interface{}{
		"ipv4-address": *t.Ipv4Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_VirtualIpv4Discovery_Address) ΛBelongingModule() string {
	return "srl_nokia-interfaces-nbr-virtual-ip-discovery"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-client YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient struct {
	TraceOptions *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions `path:"trace-options" module:"srl_nokia-interfaces-ip-dhcp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) IsYANGGoStruct() {}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) GetOrCreateTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions{}
	return t.TraceOptions
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) GetTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-client/trace-options YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions struct {
	Trace []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions_Trace `path:"trace" module:"srl_nokia-interfaces-ip-dhcp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) GetTrace() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-relay YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay struct {
	AdminState           E_SrlNokiaCommon_AdminState                                            `path:"admin-state" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	GiAddress            *string                                                                `path:"gi-address" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	NetworkInstance      *string                                                                `path:"network-instance" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	Option               []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_Option    `path:"option" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	Server               []string                                                               `path:"server" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	TraceOptions         *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions `path:"trace-options" module:"srl_nokia-interfaces-ip-dhcp-relay"`
	UseGiAddrAsSrcIpAddr *bool                                                                  `path:"use-gi-addr-as-src-ip-addr" module:"srl_nokia-interfaces-ip-dhcp-relay"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) IsYANGGoStruct() {}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetOrCreateTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions{}
	return t.TraceOptions
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetGiAddress retrieves the value of the leaf GiAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GiAddress is set, it can
// safely use t.GetGiAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GiAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetGiAddress() string {
	if t == nil || t.GiAddress == nil {
		return ""
	}
	return *t.GiAddress
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetOption retrieves the value of the leaf Option from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Option is set, it can
// safely use t.GetOption() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Option == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetOption() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_Option {
	if t == nil || t.Option == nil {
		return nil
	}
	return t.Option
}

// GetServer retrieves the value of the leaf Server from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Server is set, it can
// safely use t.GetServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Server == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetServer() []string {
	if t == nil || t.Server == nil {
		return nil
	}
	return t.Server
}

// GetUseGiAddrAsSrcIpAddr retrieves the value of the leaf UseGiAddrAsSrcIpAddr from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseGiAddrAsSrcIpAddr is set, it can
// safely use t.GetUseGiAddrAsSrcIpAddr() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseGiAddrAsSrcIpAddr == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) GetUseGiAddrAsSrcIpAddr() bool {
	if t == nil || t.UseGiAddrAsSrcIpAddr == nil {
		return false
	}
	return *t.UseGiAddrAsSrcIpAddr
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.UseGiAddrAsSrcIpAddr == nil {
		var v bool = false
		t.UseGiAddrAsSrcIpAddr = &v
	}
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-relay"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-relay/trace-options YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions struct {
	Trace []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions_Trace `path:"trace" module:"srl_nokia-interfaces-ip-dhcp-relay"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) GetTrace() []E_SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpRelay_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-relay"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer represents the /srl_nokia-interfaces/interface/subinterface/ipv4/dhcp-server YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-interfaces-ip-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpServer) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp-server"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6 represents the /srl_nokia-interfaces/interface/subinterface/ipv6 YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6 struct {
	Address             map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address  `path:"address" module:"srl_nokia-interfaces"`
	DhcpClient          *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient          `path:"dhcp-client" module:"srl_nokia-interfaces-ip-dhcp" yangPresence:"true"`
	DhcpRelay           *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay           `path:"dhcp-relay" module:"srl_nokia-interfaces-ip-dhcp-relay" yangPresence:"true"`
	Dhcpv6Server        *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server        `path:"dhcpv6-server" module:"srl_nokia-interfaces-ip-dhcp-server" yangPresence:"true"`
	NeighborDiscovery   *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery   `path:"neighbor-discovery" module:"srl_nokia-interfaces-nbr"`
	RouterAdvertisement *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement `path:"router-advertisement" module:"srl_nokia-interfaces-router-adv"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6) IsYANGGoStruct() {}

// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) NewAddress(IpPrefix string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address{
		IpPrefix: &IpPrefix,
	}

	return t.Address[key], nil
}

// RenameAddress renames an entry in the list Address within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6 struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) RenameAddress(oldK, newK string) error {
	if _, ok := t.Address[newK]; ok {
		return fmt.Errorf("key %v already exists in Address", newK)
	}

	e, ok := t.Address[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Address", oldK)
	}
	e.IpPrefix = &newK

	t.Address[newK] = e
	delete(t.Address, oldK)
	return nil
}

// GetOrCreateAddress retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address {
	key := IpPrefix

	if v, ok := t.Address[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAddress(IpPrefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAddress got unexpected error: %v", err))
	}
	return v
}

// GetAddress retrieves the value with the specified key from
// the Address map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetAddress(IpPrefix string) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address {
	if t == nil {
		return nil
	}

	key := IpPrefix

	if lm, ok := t.Address[key]; ok {
		return lm
	}
	return nil
}

// DeleteAddress deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) DeleteAddress(IpPrefix string) {
	key := IpPrefix

	delete(t.Address, key)
}

// AppendAddress appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address struct to the
// list Address of SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) AppendAddress(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address,
) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key received for IpPrefix")
	}

	key := *v.IpPrefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address)
	}

	if _, ok := t.Address[key]; ok {
		return fmt.Errorf("duplicate key for list Address %v", key)
	}

	t.Address[key] = v
	return nil
}

// GetOrCreateDhcpClient retrieves the value of the DhcpClient field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient {
	if t.DhcpClient != nil {
		return t.DhcpClient
	}
	t.DhcpClient = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient{}
	return t.DhcpClient
}

// GetOrCreateDhcpRelay retrieves the value of the DhcpRelay field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay {
	if t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	t.DhcpRelay = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay{}
	return t.DhcpRelay
}

// GetOrCreateDhcpv6Server retrieves the value of the Dhcpv6Server field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateDhcpv6Server() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server {
	if t.Dhcpv6Server != nil {
		return t.Dhcpv6Server
	}
	t.Dhcpv6Server = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server{}
	return t.Dhcpv6Server
}

// GetOrCreateNeighborDiscovery retrieves the value of the NeighborDiscovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateNeighborDiscovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery {
	if t.NeighborDiscovery != nil {
		return t.NeighborDiscovery
	}
	t.NeighborDiscovery = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery{}
	return t.NeighborDiscovery
}

// GetOrCreateRouterAdvertisement retrieves the value of the RouterAdvertisement field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetOrCreateRouterAdvertisement() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	t.RouterAdvertisement = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement{}
	return t.RouterAdvertisement
}

// GetDhcpClient returns the value of the DhcpClient struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field DhcpClient is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetDhcpClient() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient {
	if t != nil && t.DhcpClient != nil {
		return t.DhcpClient
	}
	return nil
}

// GetDhcpRelay returns the value of the DhcpRelay struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field DhcpRelay is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetDhcpRelay() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpRelay {
	if t != nil && t.DhcpRelay != nil {
		return t.DhcpRelay
	}
	return nil
}

// GetDhcpv6Server returns the value of the Dhcpv6Server struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field Dhcpv6Server is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetDhcpv6Server() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Dhcpv6Server {
	if t != nil && t.Dhcpv6Server != nil {
		return t.Dhcpv6Server
	}
	return nil
}

// GetNeighborDiscovery returns the value of the NeighborDiscovery struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field NeighborDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetNeighborDiscovery() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery {
	if t != nil && t.NeighborDiscovery != nil {
		return t.NeighborDiscovery
	}
	return nil
}

// GetRouterAdvertisement returns the value of the RouterAdvertisement struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6. If the receiver or the field RouterAdvertisement is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) GetRouterAdvertisement() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_RouterAdvertisement {
	if t != nil && t.RouterAdvertisement != nil {
		return t.RouterAdvertisement
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DhcpClient.PopulateDefaults()
	t.DhcpRelay.PopulateDefaults()
	t.Dhcpv6Server.PopulateDefaults()
	t.NeighborDiscovery.PopulateDefaults()
	t.RouterAdvertisement.PopulateDefaults()
	for _, e := range t.Address {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address struct {
	AnycastGw *bool                                                        `path:"anycast-gw" module:"srl_nokia-interfaces"`
	IpPrefix  *string                                                      `path:"ip-prefix" module:"srl_nokia-interfaces"`
	Primary   YANGEmpty                                                    `path:"primary" module:"srl_nokia-interfaces"`
	Vrrp      *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp `path:"vrrp" module:"srl_nokia-interfaces-ip-vrrp" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) IsYANGGoStruct() {}

// GetOrCreateVrrp retrieves the value of the Vrrp field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetOrCreateVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp {
	if t.Vrrp != nil {
		return t.Vrrp
	}
	t.Vrrp = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp{}
	return t.Vrrp
}

// GetVrrp returns the value of the Vrrp struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address. If the receiver or the field Vrrp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetVrrp() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp {
	if t != nil && t.Vrrp != nil {
		return t.Vrrp
	}
	return nil
}

// GetAnycastGw retrieves the value of the leaf AnycastGw from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnycastGw is set, it can
// safely use t.GetAnycastGw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnycastGw == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetAnycastGw() bool {
	if t == nil || t.AnycastGw == nil {
		return false
	}
	return *t.AnycastGw
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetPrimary retrieves the value of the leaf Primary from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Primary is set, it can
// safely use t.GetPrimary() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Primary == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) GetPrimary() YANGEmpty {
	if t == nil || t.Primary == false {
		return false
	}
	return t.Primary
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Vrrp.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛBelongingModule() string {
	return "srl_nokia-interfaces"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp struct {
	VrrpGroup map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup `path:"vrrp-group" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) IsYANGGoStruct() {}

// NewVrrpGroup creates a new entry in the VrrpGroup list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) NewVrrpGroup(
	VirtualRouterId uint8,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup)
	}

	key := VirtualRouterId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrrpGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrrpGroup", key)
	}

	t.VrrpGroup[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup{
		VirtualRouterId: &VirtualRouterId,
	}

	return t.VrrpGroup[key], nil
}

// RenameVrrpGroup renames an entry in the list VrrpGroup within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) RenameVrrpGroup(oldK, newK uint8) error {
	if _, ok := t.VrrpGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VrrpGroup", newK)
	}

	e, ok := t.VrrpGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrrpGroup", oldK)
	}
	e.VirtualRouterId = &newK

	t.VrrpGroup[newK] = e
	delete(t.VrrpGroup, oldK)
	return nil
}

// GetOrCreateVrrpGroup retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) GetOrCreateVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup {
	key := VirtualRouterId

	if v, ok := t.VrrpGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrpGroup(VirtualRouterId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrpGroup got unexpected error: %v", err))
	}
	return v
}

// GetVrrpGroup retrieves the value with the specified key from
// the VrrpGroup map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) GetVrrpGroup(
	VirtualRouterId uint8,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup {
	if t == nil {
		return nil
	}

	key := VirtualRouterId

	if lm, ok := t.VrrpGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrpGroup deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) DeleteVrrpGroup(VirtualRouterId uint8) {
	key := VirtualRouterId

	delete(t.VrrpGroup, key)
}

// AppendVrrpGroup appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup struct to the
// list VrrpGroup of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) AppendVrrpGroup(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup,
) error {
	if v.VirtualRouterId == nil {
		return fmt.Errorf("invalid nil key received for VirtualRouterId")
	}

	key := *v.VirtualRouterId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrrpGroup == nil {
		t.VrrpGroup = make(map[uint8]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup)
	}

	if _, ok := t.VrrpGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VrrpGroup %v", key)
	}

	t.VrrpGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VrrpGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup struct {
	AcceptMode            *bool                                                                                    `path:"accept-mode" module:"srl_nokia-interfaces-ip-vrrp"`
	AdminState            E_SrlNokiaCommon_AdminState                                                              `path:"admin-state" module:"srl_nokia-interfaces-ip-vrrp"`
	AdvertiseInterval     *uint16                                                                                  `path:"advertise-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Authentication        *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication    `path:"authentication" module:"srl_nokia-interfaces-ip-vrrp"`
	InitDelay             *uint16                                                                                  `path:"init-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	InterfaceTracking     *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking `path:"interface-tracking" module:"srl_nokia-interfaces-ip-vrrp"`
	MasterInheritInterval *bool                                                                                    `path:"master-inherit-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	OperInterval          *uint16                                                                                  `path:"oper-interval" module:"srl_nokia-interfaces-ip-vrrp"`
	Preempt               *bool                                                                                    `path:"preempt" module:"srl_nokia-interfaces-ip-vrrp"`
	PreemptDelay          *uint16                                                                                  `path:"preempt-delay" module:"srl_nokia-interfaces-ip-vrrp"`
	Priority              *uint8                                                                                   `path:"priority" module:"srl_nokia-interfaces-ip-vrrp"`
	Statistics            *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics        `path:"statistics" module:"srl_nokia-interfaces-ip-vrrp"`
	Version               *uint8                                                                                   `path:"version" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualAddress        []string                                                                                 `path:"virtual-address" module:"srl_nokia-interfaces-ip-vrrp"`
	VirtualRouterId       *uint8                                                                                   `path:"virtual-router-id" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOrCreateAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication{}
	return t.Authentication
}

// GetOrCreateInterfaceTracking retrieves the value of the InterfaceTracking field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOrCreateInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	t.InterfaceTracking = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking{}
	return t.InterfaceTracking
}

// GetOrCreateStatistics retrieves the value of the Statistics field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOrCreateStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics {
	if t.Statistics != nil {
		return t.Statistics
	}
	t.Statistics = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics{}
	return t.Statistics
}

// GetAuthentication returns the value of the Authentication struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAuthentication() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetInterfaceTracking returns the value of the InterfaceTracking struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup. If the receiver or the field InterfaceTracking is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetInterfaceTracking() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking {
	if t != nil && t.InterfaceTracking != nil {
		return t.InterfaceTracking
	}
	return nil
}

// GetStatistics returns the value of the Statistics struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup. If the receiver or the field Statistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetStatistics() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics {
	if t != nil && t.Statistics != nil {
		return t.Statistics
	}
	return nil
}

// GetAcceptMode retrieves the value of the leaf AcceptMode from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcceptMode is set, it can
// safely use t.GetAcceptMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcceptMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAcceptMode() bool {
	if t == nil || t.AcceptMode == nil {
		return false
	}
	return *t.AcceptMode
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetAdvertiseInterval retrieves the value of the leaf AdvertiseInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertiseInterval is set, it can
// safely use t.GetAdvertiseInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertiseInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetAdvertiseInterval() uint16 {
	if t == nil || t.AdvertiseInterval == nil {
		return 1000
	}
	return *t.AdvertiseInterval
}

// GetInitDelay retrieves the value of the leaf InitDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InitDelay is set, it can
// safely use t.GetInitDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InitDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetInitDelay() uint16 {
	if t == nil || t.InitDelay == nil {
		return 0
	}
	return *t.InitDelay
}

// GetMasterInheritInterval retrieves the value of the leaf MasterInheritInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MasterInheritInterval is set, it can
// safely use t.GetMasterInheritInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MasterInheritInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetMasterInheritInterval() bool {
	if t == nil || t.MasterInheritInterval == nil {
		return false
	}
	return *t.MasterInheritInterval
}

// GetOperInterval retrieves the value of the leaf OperInterval from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperInterval is set, it can
// safely use t.GetOperInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetOperInterval() uint16 {
	if t == nil || t.OperInterval == nil {
		return 0
	}
	return *t.OperInterval
}

// GetPreempt retrieves the value of the leaf Preempt from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preempt is set, it can
// safely use t.GetPreempt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preempt == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetPreempt() bool {
	if t == nil || t.Preempt == nil {
		return false
	}
	return *t.Preempt
}

// GetPreemptDelay retrieves the value of the leaf PreemptDelay from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreemptDelay is set, it can
// safely use t.GetPreemptDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreemptDelay == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetPreemptDelay() uint16 {
	if t == nil || t.PreemptDelay == nil {
		return 0
	}
	return *t.PreemptDelay
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// GetVersion retrieves the value of the leaf Version from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Version is set, it can
// safely use t.GetVersion() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Version == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetVersion() uint8 {
	if t == nil || t.Version == nil {
		return 3
	}
	return *t.Version
}

// GetVirtualAddress retrieves the value of the leaf VirtualAddress from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualAddress is set, it can
// safely use t.GetVirtualAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetVirtualAddress() []string {
	if t == nil || t.VirtualAddress == nil {
		return nil
	}
	return t.VirtualAddress
}

// GetVirtualRouterId retrieves the value of the leaf VirtualRouterId from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VirtualRouterId is set, it can
// safely use t.GetVirtualRouterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VirtualRouterId == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) GetVirtualRouterId() uint8 {
	if t == nil || t.VirtualRouterId == nil {
		return 0
	}
	return *t.VirtualRouterId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.AdvertiseInterval == nil {
		var v uint16 = 1000
		t.AdvertiseInterval = &v
	}
	if t.MasterInheritInterval == nil {
		var v bool = false
		t.MasterInheritInterval = &v
	}
	if t.Priority == nil {
		var v uint8 = 100
		t.Priority = &v
	}
	if t.Version == nil {
		var v uint8 = 3
		t.Version = &v
	}
	t.Authentication.PopulateDefaults()
	t.InterfaceTracking.PopulateDefaults()
	t.Statistics.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VirtualRouterId == nil {
		return nil, fmt.Errorf("nil value for key VirtualRouterId")
	}

	return map[string]interface{}{
		"virtual-router-id": *t.VirtualRouterId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/authentication YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication struct {
	Keychain *string `path:"keychain" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) IsYANGGoStruct() {
}

// GetKeychain retrieves the value of the leaf Keychain from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Keychain is set, it can
// safely use t.GetKeychain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Keychain == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) GetKeychain() string {
	if t == nil || t.Keychain == nil {
		return ""
	}
	return *t.Keychain
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Authentication) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/interface-tracking YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking struct {
	TrackInterface map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface `path:"track-interface" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) IsYANGGoStruct() {
}

// NewTrackInterface creates a new entry in the TrackInterface list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) NewTrackInterface(
	Interface string,
) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	key := Interface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrackInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrackInterface", key)
	}

	t.TrackInterface[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface{
		Interface: &Interface,
	}

	return t.TrackInterface[key], nil
}

// RenameTrackInterface renames an entry in the list TrackInterface within
// the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) RenameTrackInterface(oldK, newK string) error {
	if _, ok := t.TrackInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TrackInterface", newK)
	}

	e, ok := t.TrackInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrackInterface", oldK)
	}
	e.Interface = &newK

	t.TrackInterface[newK] = e
	delete(t.TrackInterface, oldK)
	return nil
}

// GetOrCreateTrackInterface retrieves the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) GetOrCreateTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	key := Interface

	if v, ok := t.TrackInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrackInterface(Interface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrackInterface got unexpected error: %v", err))
	}
	return v
}

// GetTrackInterface retrieves the value with the specified key from
// the TrackInterface map field of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) GetTrackInterface(
	Interface string,
) *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface {
	if t == nil {
		return nil
	}

	key := Interface

	if lm, ok := t.TrackInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteTrackInterface deletes the value with the specified keys from
// the receiver SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) DeleteTrackInterface(Interface string) {
	key := Interface

	delete(t.TrackInterface, key)
}

// AppendTrackInterface appends the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct to the
// list TrackInterface of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking. If the key value(s) specified in
// the supplied SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) AppendTrackInterface(
	v *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface,
) error {
	if v.Interface == nil {
		return fmt.Errorf("invalid nil key received for Interface")
	}

	key := *v.Interface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrackInterface == nil {
		t.TrackInterface = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface)
	}

	if _, ok := t.TrackInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TrackInterface %v", key)
	}

	t.TrackInterface[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.TrackInterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/interface-tracking/track-interface YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct {
	Interface         *string `path:"interface" module:"srl_nokia-interfaces-ip-vrrp"`
	PriorityDecrement *uint8  `path:"priority-decrement" module:"srl_nokia-interfaces-ip-vrrp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) IsYANGGoStruct() {
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetInterface() string {
	if t == nil || t.Interface == nil {
		return ""
	}
	return *t.Interface
}

// GetPriorityDecrement retrieves the value of the leaf PriorityDecrement from the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PriorityDecrement is set, it can
// safely use t.GetPriorityDecrement() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PriorityDecrement == nil' before retrieving the leaf's value.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) GetPriorityDecrement() uint8 {
	if t == nil || t.PriorityDecrement == nil {
		return 0
	}
	return *t.PriorityDecrement
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Interface == nil {
		return nil, fmt.Errorf("nil value for key Interface")
	}

	return map[string]interface{}{
		"interface": *t.Interface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_InterfaceTracking_TrackInterface) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics represents the /srl_nokia-interfaces/interface/subinterface/ipv6/address/vrrp/vrrp-group/statistics YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics struct{}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address_Vrrp_VrrpGroup_Statistics) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-vrrp"
}

// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient represents the /srl_nokia-interfaces/interface/subinterface/ipv6/dhcp-client YANG schema element.
type SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient struct {
	TraceOptions *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions `path:"trace-options" module:"srl_nokia-interfaces-ip-dhcp"`
}

// IsYANGGoStruct ensures that SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) IsYANGGoStruct() {}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) GetOrCreateTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions{}
	return t.TraceOptions
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) GetTraceOptions() *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient.
func (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) ΛBelongingModule() string {
	return "srl_nokia-interfaces-ip-dhcp"
}
