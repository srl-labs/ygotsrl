/*
Package ygotsrl is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /root/go/pkg/mod/github.com/openconfig/ygot@v0.24.4/genutil/names.go
using the following YANG input files:
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/acl/srl_nokia-packet-match-types.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/bfd/srl_nokia-micro-bfd.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-common.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-extensions.yang
	- work/srlinux-yang-models/srl_nokia/models/common/srl_nokia-features.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-pm.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm-types.yang
	- work/srlinux-yang-models/srl_nokia/models/ethcfm/srl_nokia-ethcfm.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-ip.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-if-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ethernet-segment-association.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-relay.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-dhcp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-ip-vrrp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-l2cp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-lag.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-local-mirror-destination.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr-virtual-ip-discovery.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-nbr.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-router-adv.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vlans.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/interfaces/srl_nokia-lacp.yang
	- work/srlinux-yang-models/srl_nokia/models/macsec/srl_nokia-macsec.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-aggregate-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-statistics.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn-bgp-instance-mpls-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-evpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-duplication.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning-entries.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-learning.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-limit.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-mac-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-proxy-arp-nd.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-reserved-macs.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table-static-mac.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-icmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-igmp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ip-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-isis.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ldp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-linux.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld-snooping.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mld.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls-route-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-mpls.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-next-hop-groups.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-lsdb.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf-types.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospf.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-ospfv3-lsas.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-pim.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-policy-forwarding.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-rib-bgp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-segment-routing.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-sr-policies.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-static-routes.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tcp-udp.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-traffic-engineering.yang
	- work/srlinux-yang-models/srl_nokia/models/network-instance/srl_nokia-tunnel-tables.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-oam.yang
	- work/srlinux-yang-models/srl_nokia/models/oam/srl_nokia-twamp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-acl.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cgroup.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-chassis.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-control.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-cpu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-datapath-resources.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-disk.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fabric.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-fan.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-lc.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-memory.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-p4rt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-pipeline-counters.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-psu.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-redundancy.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-resource-monitoring.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-tcam.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform-vxdp.yang
	- work/srlinux-yang-models/srl_nokia/models/platform/srl_nokia-platform.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos-policers.yang
	- work/srlinux-yang-models/srl_nokia/models/qos/srl_nokia-qos.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-policy-types.yang
	- work/srlinux-yang-models/srl_nokia/models/routing-policy/srl_nokia-routing-policy.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-freq.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-ptp.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync-types.yang
	- work/srlinux-yang-models/srl_nokia/models/sync/srl_nokia-sync.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-password.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-tacacs.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-aaa.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-app-mgmt.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-boot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration-role.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-configuration.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dhcp-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-dns.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-event-handler.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ftp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gnmi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-gribi-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-json-rpc.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-keychains.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-license.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp-types.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-lldp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-load-balancing.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-logging.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-maintenance-mode.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mirroring.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mpls-services-evpn-label-management.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-mtu.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ntp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-openconfig.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-p4rt-server.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ra_guard.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-sflow.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp-trace.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-snmp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-ssh.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-banner.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table-proxy-arp.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-info.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-name.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-evpn-ethernet-segments.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance-bgp-vpn.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-network-instance.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system-reboot.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-system.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-timezone.yang
	- work/srlinux-yang-models/srl_nokia/models/system/srl_nokia-tls.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-multicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-destinations.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table-unicast-es-destination-vteps.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces-vxlan-interface-bridge-table.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel-interfaces.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-tunnel.yang
	- work/srlinux-yang-models/srl_nokia/models/tunnel/srl_nokia-vxlan-tunnel-vtep.yang
Imported modules were sourced from:
	- work/srlinux-yang-models/...
*/
package ygotsrl

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action/bgp/local-preference YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference struct {
	Set *uint32 `path:"set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference) IsYANGGoStruct() {
}

// GetSet retrieves the value of the leaf Set from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Set is set, it can
// safely use t.GetSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Set == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference) GetSet() uint32 {
	if t == nil || t.Set == nil {
		return 0
	}
	return *t.Set
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_LocalPreference) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action/bgp/med YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med struct {
	Set SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med_Set_Union `path:"set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med) IsYANGGoStruct() {}

// GetSet retrieves the value of the leaf Set from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Set is set, it can
// safely use t.GetSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Set == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med) GetSet() SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med_Set_Union {
	if t == nil || t.Set == nil {
		return nil
	}
	return t.Set
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Med) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin represents the /srl_nokia-routing-policy/routing-policy/policy/statement/action/bgp/origin YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin struct {
	Set E_SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin_Set `path:"set" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin) IsYANGGoStruct() {}

// GetSet retrieves the value of the leaf Set from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Set is set, it can
// safely use t.GetSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Set == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin) GetSet() E_SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Bgp_Origin_Set {
	if t == nil || t.Set == 0 {
		return 0
	}
	return t.Set
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Bgp_Origin) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match represents the /srl_nokia-routing-policy/routing-policy/policy/statement/match YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match struct {
	Bgp       *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp  `path:"bgp" module:"srl_nokia-routing-policy"`
	Family    []E_SrlNokiaPolicyTypes_BgpFamilyType                            `path:"family" module:"srl_nokia-routing-policy"`
	Isis      *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis `path:"isis" module:"srl_nokia-routing-policy"`
	Ospf      *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf `path:"ospf" module:"srl_nokia-routing-policy"`
	PrefixSet *string                                                          `path:"prefix-set" module:"srl_nokia-routing-policy"`
	Protocol  E_SrlNokiaCommon_IpRouteType                                     `path:"protocol" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) IsYANGGoStruct() {}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetOrCreateBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp{}
	return t.Bgp
}

// GetOrCreateIsis retrieves the value of the Isis field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetOrCreateIsis() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis {
	if t.Isis != nil {
		return t.Isis
	}
	t.Isis = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis{}
	return t.Isis
}

// GetOrCreateOspf retrieves the value of the Ospf field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetOrCreateOspf() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf {
	if t.Ospf != nil {
		return t.Ospf
	}
	t.Ospf = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf{}
	return t.Ospf
}

// GetBgp returns the value of the Bgp struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetBgp() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetIsis returns the value of the Isis struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match. If the receiver or the field Isis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetIsis() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis {
	if t != nil && t.Isis != nil {
		return t.Isis
	}
	return nil
}

// GetOspf returns the value of the Ospf struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match. If the receiver or the field Ospf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetOspf() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf {
	if t != nil && t.Ospf != nil {
		return t.Ospf
	}
	return nil
}

// GetFamily retrieves the value of the leaf Family from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Family is set, it can
// safely use t.GetFamily() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Family == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetFamily() []E_SrlNokiaPolicyTypes_BgpFamilyType {
	if t == nil || t.Family == nil {
		return nil
	}
	return t.Family
}

// GetPrefixSet retrieves the value of the leaf PrefixSet from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixSet is set, it can
// safely use t.GetPrefixSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetPrefixSet() string {
	if t == nil || t.PrefixSet == nil {
		return ""
	}
	return *t.PrefixSet
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) GetProtocol() E_SrlNokiaCommon_IpRouteType {
	if t == nil || t.Protocol == 0 {
		return 0
	}
	return t.Protocol
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
	t.Isis.PopulateDefaults()
	t.Ospf.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp represents the /srl_nokia-routing-policy/routing-policy/policy/statement/match/bgp YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp struct {
	AsPathLength *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength `path:"as-path-length" module:"srl_nokia-routing-policy"`
	AsPathSet    *string                                                                      `path:"as-path-set" module:"srl_nokia-routing-policy"`
	CommunitySet *string                                                                      `path:"community-set" module:"srl_nokia-routing-policy"`
	Evpn         *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn         `path:"evpn" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) IsYANGGoStruct() {}

// GetOrCreateAsPathLength retrieves the value of the AsPathLength field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) GetOrCreateAsPathLength() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength {
	if t.AsPathLength != nil {
		return t.AsPathLength
	}
	t.AsPathLength = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength{}
	return t.AsPathLength
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) GetOrCreateEvpn() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn{}
	return t.Evpn
}

// GetAsPathLength returns the value of the AsPathLength struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp. If the receiver or the field AsPathLength is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) GetAsPathLength() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength {
	if t != nil && t.AsPathLength != nil {
		return t.AsPathLength
	}
	return nil
}

// GetEvpn returns the value of the Evpn struct pointer
// from SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) GetEvpn() *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// GetAsPathSet retrieves the value of the leaf AsPathSet from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AsPathSet is set, it can
// safely use t.GetAsPathSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AsPathSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) GetAsPathSet() string {
	if t == nil || t.AsPathSet == nil {
		return ""
	}
	return *t.AsPathSet
}

// GetCommunitySet retrieves the value of the leaf CommunitySet from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommunitySet is set, it can
// safely use t.GetCommunitySet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommunitySet == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) GetCommunitySet() string {
	if t == nil || t.CommunitySet == nil {
		return ""
	}
	return *t.CommunitySet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AsPathLength.PopulateDefaults()
	t.Evpn.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength represents the /srl_nokia-routing-policy/routing-policy/policy/statement/match/bgp/as-path-length YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength struct {
	Operator E_SrlNokiaPolicyTypes_ComparisonOperatorType `path:"operator" module:"srl_nokia-routing-policy"`
	Unique   *bool                                        `path:"unique" module:"srl_nokia-routing-policy"`
	Value    *uint8                                       `path:"value" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) IsYANGGoStruct() {
}

// GetOperator retrieves the value of the leaf Operator from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Operator is set, it can
// safely use t.GetOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Operator == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) GetOperator() E_SrlNokiaPolicyTypes_ComparisonOperatorType {
	if t == nil || t.Operator == 0 {
		return SrlNokiaPolicyTypes_ComparisonOperatorType_eq
	}
	return t.Operator
}

// GetUnique retrieves the value of the leaf Unique from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Unique is set, it can
// safely use t.GetUnique() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Unique == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) GetUnique() bool {
	if t == nil || t.Unique == nil {
		return false
	}
	return *t.Unique
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) GetValue() uint8 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Operator == 0 {
		t.Operator = SrlNokiaPolicyTypes_ComparisonOperatorType_eq
	}
	if t.Unique == nil {
		var v bool = false
		t.Unique = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn represents the /srl_nokia-routing-policy/routing-policy/policy/statement/match/bgp/evpn YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn struct {
	RouteType []uint8 `path:"route-type" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn) IsYANGGoStruct() {}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn) GetRouteType() []uint8 {
	if t == nil || t.RouteType == nil {
		return nil
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_Evpn) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis represents the /srl_nokia-routing-policy/routing-policy/policy/statement/match/isis YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis struct {
	Level     *uint8                                                                      `path:"level" module:"srl_nokia-routing-policy"`
	RouteType E_SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis_RouteType `path:"route-type" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) IsYANGGoStruct() {}

// GetLevel retrieves the value of the leaf Level from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Level is set, it can
// safely use t.GetLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Level == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) GetLevel() uint8 {
	if t == nil || t.Level == nil {
		return 0
	}
	return *t.Level
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) GetRouteType() E_SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis_RouteType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Isis) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf represents the /srl_nokia-routing-policy/routing-policy/policy/statement/match/ospf YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf struct {
	AreaId     *string                               `path:"area-id" module:"srl_nokia-routing-policy"`
	InstanceId *uint32                               `path:"instance-id" module:"srl_nokia-routing-policy"`
	RouteType  E_SrlNokiaPolicyTypes_PolOspfPathType `path:"route-type" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) IsYANGGoStruct() {}

// GetAreaId retrieves the value of the leaf AreaId from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AreaId is set, it can
// safely use t.GetAreaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AreaId == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) GetAreaId() string {
	if t == nil || t.AreaId == nil {
		return ""
	}
	return *t.AreaId
}

// GetInstanceId retrieves the value of the leaf InstanceId from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceId is set, it can
// safely use t.GetInstanceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) GetInstanceId() uint32 {
	if t == nil || t.InstanceId == nil {
		return 0
	}
	return *t.InstanceId
}

// GetRouteType retrieves the value of the leaf RouteType from the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteType is set, it can
// safely use t.GetRouteType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteType == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) GetRouteType() E_SrlNokiaPolicyTypes_PolOspfPathType {
	if t == nil || t.RouteType == 0 {
		return 0
	}
	return t.RouteType
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Ospf) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet represents the /srl_nokia-routing-policy/routing-policy/prefix-set YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct {
	Name   *string                                                                                                            `path:"name" module:"srl_nokia-routing-policy"`
	Prefix map[SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix `path:"prefix" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) IsYANGGoStruct() {}

// SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key represents the key for list Prefix of element /srl_nokia-routing-policy/routing-policy/prefix-set.
type SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key struct {
	IpPrefix        string `path:"ip-prefix"`
	MaskLengthRange string `path:"mask-length-range"`
}

// NewPrefix creates a new entry in the Prefix list of the
// SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) NewPrefix(IpPrefix string,
	MaskLengthRange string,
) (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix)
	}

	key := SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MaskLengthRange: MaskLengthRange,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix{
		IpPrefix:        &IpPrefix,
		MaskLengthRange: &MaskLengthRange,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) RenamePrefix(
	oldK, newK SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key,
) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.IpPrefix = &newK.IpPrefix
	e.MaskLengthRange = &newK.MaskLengthRange

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) GetOrCreatePrefix(IpPrefix string,
	MaskLengthRange string,
) *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix {
	key := SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MaskLengthRange: MaskLengthRange,
	}

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(IpPrefix, MaskLengthRange)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) GetPrefix(IpPrefix string,
	MaskLengthRange string,
) *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix {
	if t == nil {
		return nil
	}

	key := SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MaskLengthRange: MaskLengthRange,
	}

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) DeletePrefix(IpPrefix string, MaskLengthRange string) {
	key := SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key{
		IpPrefix:        IpPrefix,
		MaskLengthRange: MaskLengthRange,
	}

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix struct to the
// list Prefix of SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet. If the key value(s) specified in
// the supplied SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix already exist in the list, an error is
// returned.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) AppendPrefix(
	v *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix,
) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key for IpPrefix")
	}

	if v.MaskLengthRange == nil {
		return fmt.Errorf("invalid nil key for MaskLengthRange")
	}

	key := SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key{
		IpPrefix:        *v.IpPrefix,
		MaskLengthRange: *v.MaskLengthRange,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix represents the /srl_nokia-routing-policy/routing-policy/prefix-set/prefix YANG schema element.
type SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix struct {
	IpPrefix        *string `path:"ip-prefix" module:"srl_nokia-routing-policy"`
	MaskLengthRange *string `path:"mask-length-range" module:"srl_nokia-routing-policy"`
}

// IsYANGGoStruct ensures that SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) IsYANGGoStruct() {}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetMaskLengthRange retrieves the value of the leaf MaskLengthRange from the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaskLengthRange is set, it can
// safely use t.GetMaskLengthRange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaskLengthRange == nil' before retrieving the leaf's value.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) GetMaskLengthRange() string {
	if t == nil || t.MaskLengthRange == nil {
		return ""
	}
	return *t.MaskLengthRange
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.MaskLengthRange == nil {
		return nil, fmt.Errorf("nil value for key MaskLengthRange")
	}

	return map[string]interface{}{
		"ip-prefix":         *t.IpPrefix,
		"mask-length-range": *t.MaskLengthRange,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix.
func (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) ΛBelongingModule() string {
	return "srl_nokia-routing-policy"
}

// SrlNokiaSystem_System represents the /srl_nokia-system/system YANG schema element.
type SrlNokiaSystem_System struct {
	Aaa             *SrlNokiaSystem_System_Aaa                      `path:"aaa" module:"srl_nokia-aaa"`
	Authentication  *SrlNokiaSystem_System_Authentication           `path:"authentication" module:"srl_nokia-keychains"`
	Banner          *SrlNokiaSystem_System_Banner                   `path:"banner" module:"srl_nokia-system-banner"`
	Boot            *SrlNokiaSystem_System_Boot                     `path:"boot" module:"srl_nokia-boot"`
	BridgeTable     *SrlNokiaSystem_System_BridgeTable              `path:"bridge-table" module:"srl_nokia-system-bridge-table"`
	Clock           *SrlNokiaSystem_System_Clock                    `path:"clock" module:"srl_nokia-ntp"`
	Configuration   *SrlNokiaSystem_System_Configuration            `path:"configuration" module:"srl_nokia-configuration"`
	DhcpServer      *SrlNokiaSystem_System_DhcpServer               `path:"dhcp-server" module:"srl_nokia-dhcp-server" yangPresence:"true"`
	Dns             *SrlNokiaSystem_System_Dns                      `path:"dns" module:"srl_nokia-dns" yangPresence:"true"`
	EventHandler    *SrlNokiaSystem_System_EventHandler             `path:"event-handler" module:"srl_nokia-event-handler" yangPresence:"true"`
	FtpServer       *SrlNokiaSystem_System_FtpServer                `path:"ftp-server" module:"srl_nokia-ftp" yangPresence:"true"`
	GnmiServer      *SrlNokiaSystem_System_GnmiServer               `path:"gnmi-server" module:"srl_nokia-gnmi-server" yangPresence:"true"`
	GribiServer     *SrlNokiaSystem_System_GribiServer              `path:"gribi-server" module:"srl_nokia-gribi-server" yangPresence:"true"`
	Information     *SrlNokiaSystem_System_Information              `path:"information" module:"srl_nokia-system-info"`
	JsonRpcServer   *SrlNokiaSystem_System_JsonRpcServer            `path:"json-rpc-server" module:"srl_nokia-json-rpc" yangPresence:"true"`
	Lacp            *SrlNokiaSystem_System_Lacp                     `path:"lacp" module:"srl_nokia-lacp"`
	License         map[string]*SrlNokiaSystem_System_License       `path:"license" module:"srl_nokia-license"`
	Lldp            *SrlNokiaSystem_System_Lldp                     `path:"lldp" module:"srl_nokia-lldp" yangPresence:"true"`
	LoadBalancing   *SrlNokiaSystem_System_LoadBalancing            `path:"load-balancing" module:"srl_nokia-load-balancing"`
	Logging         *SrlNokiaSystem_System_Logging                  `path:"logging" module:"srl_nokia-logging"`
	Maintenance     *SrlNokiaSystem_System_Maintenance              `path:"maintenance" module:"srl_nokia-maintenance-mode" yangPresence:"true"`
	Management      *SrlNokiaSystem_System_Management               `path:"management" module:"srl_nokia-system"`
	Mirroring       *SrlNokiaSystem_System_Mirroring                `path:"mirroring" module:"srl_nokia-mirroring" yangPresence:"true"`
	Mpls            *SrlNokiaSystem_System_Mpls                     `path:"mpls" module:"srl_nokia-mpls-label-management"`
	Mtu             *SrlNokiaSystem_System_Mtu                      `path:"mtu" module:"srl_nokia-mtu"`
	Name            *SrlNokiaSystem_System_Name                     `path:"name" module:"srl_nokia-system-name"`
	NetworkInstance *SrlNokiaSystem_System_NetworkInstance          `path:"network-instance" module:"srl_nokia-system-network-instance" yangPresence:"true"`
	Ntp             *SrlNokiaSystem_System_Ntp                      `path:"ntp" module:"srl_nokia-ntp" yangPresence:"true"`
	P4RtServer      *SrlNokiaSystem_System_P4RtServer               `path:"p4rt-server" module:"srl_nokia-p4rt-server" yangPresence:"true"`
	RaGuardPolicy   map[string]*SrlNokiaSystem_System_RaGuardPolicy `path:"ra-guard-policy" module:"srl_nokia-ra_guard"`
	Sflow           *SrlNokiaSystem_System_Sflow                    `path:"sflow" module:"srl_nokia-sflow" yangPresence:"true"`
	Snmp            *SrlNokiaSystem_System_Snmp                     `path:"snmp" module:"srl_nokia-snmp" yangPresence:"true"`
	SshServer       *SrlNokiaSystem_System_SshServer                `path:"ssh-server" module:"srl_nokia-ssh" yangPresence:"true"`
	Sync            *SrlNokiaSystem_System_Sync                     `path:"sync" module:"srl_nokia-sync"`
	Tls             *SrlNokiaSystem_System_Tls                      `path:"tls" module:"srl_nokia-tls"`
	TraceOptions    []E_SrlNokiaSystem_System_TraceOptions          `path:"trace-options" module:"srl_nokia-system"`
	WarmReboot      *SrlNokiaSystem_System_WarmReboot               `path:"warm-reboot" module:"srl_nokia-system-reboot"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System) IsYANGGoStruct() {}

// NewLicense creates a new entry in the License list of the
// SrlNokiaSystem_System struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System) NewLicense(Id string) (*SrlNokiaSystem_System_License, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.License == nil {
		t.License = make(map[string]*SrlNokiaSystem_System_License)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.License[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list License", key)
	}

	t.License[key] = &SrlNokiaSystem_System_License{
		Id: &Id,
	}

	return t.License[key], nil
}

// RenameLicense renames an entry in the list License within
// the SrlNokiaSystem_System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System) RenameLicense(oldK, newK string) error {
	if _, ok := t.License[newK]; ok {
		return fmt.Errorf("key %v already exists in License", newK)
	}

	e, ok := t.License[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in License", oldK)
	}
	e.Id = &newK

	t.License[newK] = e
	delete(t.License, oldK)
	return nil
}

// GetOrCreateLicense retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System) GetOrCreateLicense(Id string) *SrlNokiaSystem_System_License {
	key := Id

	if v, ok := t.License[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLicense(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLicense got unexpected error: %v", err))
	}
	return v
}

// GetLicense retrieves the value with the specified key from
// the License map field of SrlNokiaSystem_System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System) GetLicense(Id string) *SrlNokiaSystem_System_License {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.License[key]; ok {
		return lm
	}
	return nil
}

// DeleteLicense deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System) DeleteLicense(Id string) {
	key := Id

	delete(t.License, key)
}

// AppendLicense appends the supplied SrlNokiaSystem_System_License struct to the
// list License of SrlNokiaSystem_System. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_License already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System) AppendLicense(v *SrlNokiaSystem_System_License) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.License == nil {
		t.License = make(map[string]*SrlNokiaSystem_System_License)
	}

	if _, ok := t.License[key]; ok {
		return fmt.Errorf("duplicate key for list License %v", key)
	}

	t.License[key] = v
	return nil
}

// NewRaGuardPolicy creates a new entry in the RaGuardPolicy list of the
// SrlNokiaSystem_System struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System) NewRaGuardPolicy(Name string) (*SrlNokiaSystem_System_RaGuardPolicy, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RaGuardPolicy == nil {
		t.RaGuardPolicy = make(map[string]*SrlNokiaSystem_System_RaGuardPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RaGuardPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RaGuardPolicy", key)
	}

	t.RaGuardPolicy[key] = &SrlNokiaSystem_System_RaGuardPolicy{
		Name: &Name,
	}

	return t.RaGuardPolicy[key], nil
}

// RenameRaGuardPolicy renames an entry in the list RaGuardPolicy within
// the SrlNokiaSystem_System struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System) RenameRaGuardPolicy(oldK, newK string) error {
	if _, ok := t.RaGuardPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in RaGuardPolicy", newK)
	}

	e, ok := t.RaGuardPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RaGuardPolicy", oldK)
	}
	e.Name = &newK

	t.RaGuardPolicy[newK] = e
	delete(t.RaGuardPolicy, oldK)
	return nil
}

// GetOrCreateRaGuardPolicy retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System) GetOrCreateRaGuardPolicy(Name string) *SrlNokiaSystem_System_RaGuardPolicy {
	key := Name

	if v, ok := t.RaGuardPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRaGuardPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRaGuardPolicy got unexpected error: %v", err))
	}
	return v
}

// GetRaGuardPolicy retrieves the value with the specified key from
// the RaGuardPolicy map field of SrlNokiaSystem_System. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System) GetRaGuardPolicy(Name string) *SrlNokiaSystem_System_RaGuardPolicy {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.RaGuardPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteRaGuardPolicy deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System) DeleteRaGuardPolicy(Name string) {
	key := Name

	delete(t.RaGuardPolicy, key)
}

// AppendRaGuardPolicy appends the supplied SrlNokiaSystem_System_RaGuardPolicy struct to the
// list RaGuardPolicy of SrlNokiaSystem_System. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_RaGuardPolicy already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System) AppendRaGuardPolicy(v *SrlNokiaSystem_System_RaGuardPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RaGuardPolicy == nil {
		t.RaGuardPolicy = make(map[string]*SrlNokiaSystem_System_RaGuardPolicy)
	}

	if _, ok := t.RaGuardPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list RaGuardPolicy %v", key)
	}

	t.RaGuardPolicy[key] = v
	return nil
}

// GetOrCreateAaa retrieves the value of the Aaa field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateAaa() *SrlNokiaSystem_System_Aaa {
	if t.Aaa != nil {
		return t.Aaa
	}
	t.Aaa = &SrlNokiaSystem_System_Aaa{}
	return t.Aaa
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateAuthentication() *SrlNokiaSystem_System_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &SrlNokiaSystem_System_Authentication{}
	return t.Authentication
}

// GetOrCreateBanner retrieves the value of the Banner field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateBanner() *SrlNokiaSystem_System_Banner {
	if t.Banner != nil {
		return t.Banner
	}
	t.Banner = &SrlNokiaSystem_System_Banner{}
	return t.Banner
}

// GetOrCreateBoot retrieves the value of the Boot field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateBoot() *SrlNokiaSystem_System_Boot {
	if t.Boot != nil {
		return t.Boot
	}
	t.Boot = &SrlNokiaSystem_System_Boot{}
	return t.Boot
}

// GetOrCreateBridgeTable retrieves the value of the BridgeTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateBridgeTable() *SrlNokiaSystem_System_BridgeTable {
	if t.BridgeTable != nil {
		return t.BridgeTable
	}
	t.BridgeTable = &SrlNokiaSystem_System_BridgeTable{}
	return t.BridgeTable
}

// GetOrCreateClock retrieves the value of the Clock field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateClock() *SrlNokiaSystem_System_Clock {
	if t.Clock != nil {
		return t.Clock
	}
	t.Clock = &SrlNokiaSystem_System_Clock{}
	return t.Clock
}

// GetOrCreateConfiguration retrieves the value of the Configuration field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateConfiguration() *SrlNokiaSystem_System_Configuration {
	if t.Configuration != nil {
		return t.Configuration
	}
	t.Configuration = &SrlNokiaSystem_System_Configuration{}
	return t.Configuration
}

// GetOrCreateDhcpServer retrieves the value of the DhcpServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateDhcpServer() *SrlNokiaSystem_System_DhcpServer {
	if t.DhcpServer != nil {
		return t.DhcpServer
	}
	t.DhcpServer = &SrlNokiaSystem_System_DhcpServer{}
	return t.DhcpServer
}

// GetOrCreateDns retrieves the value of the Dns field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateDns() *SrlNokiaSystem_System_Dns {
	if t.Dns != nil {
		return t.Dns
	}
	t.Dns = &SrlNokiaSystem_System_Dns{}
	return t.Dns
}

// GetOrCreateEventHandler retrieves the value of the EventHandler field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateEventHandler() *SrlNokiaSystem_System_EventHandler {
	if t.EventHandler != nil {
		return t.EventHandler
	}
	t.EventHandler = &SrlNokiaSystem_System_EventHandler{}
	return t.EventHandler
}

// GetOrCreateFtpServer retrieves the value of the FtpServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateFtpServer() *SrlNokiaSystem_System_FtpServer {
	if t.FtpServer != nil {
		return t.FtpServer
	}
	t.FtpServer = &SrlNokiaSystem_System_FtpServer{}
	return t.FtpServer
}

// GetOrCreateGnmiServer retrieves the value of the GnmiServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateGnmiServer() *SrlNokiaSystem_System_GnmiServer {
	if t.GnmiServer != nil {
		return t.GnmiServer
	}
	t.GnmiServer = &SrlNokiaSystem_System_GnmiServer{}
	return t.GnmiServer
}

// GetOrCreateGribiServer retrieves the value of the GribiServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateGribiServer() *SrlNokiaSystem_System_GribiServer {
	if t.GribiServer != nil {
		return t.GribiServer
	}
	t.GribiServer = &SrlNokiaSystem_System_GribiServer{}
	return t.GribiServer
}

// GetOrCreateInformation retrieves the value of the Information field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateInformation() *SrlNokiaSystem_System_Information {
	if t.Information != nil {
		return t.Information
	}
	t.Information = &SrlNokiaSystem_System_Information{}
	return t.Information
}

// GetOrCreateJsonRpcServer retrieves the value of the JsonRpcServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateJsonRpcServer() *SrlNokiaSystem_System_JsonRpcServer {
	if t.JsonRpcServer != nil {
		return t.JsonRpcServer
	}
	t.JsonRpcServer = &SrlNokiaSystem_System_JsonRpcServer{}
	return t.JsonRpcServer
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateLacp() *SrlNokiaSystem_System_Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &SrlNokiaSystem_System_Lacp{}
	return t.Lacp
}

// GetOrCreateLldp retrieves the value of the Lldp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateLldp() *SrlNokiaSystem_System_Lldp {
	if t.Lldp != nil {
		return t.Lldp
	}
	t.Lldp = &SrlNokiaSystem_System_Lldp{}
	return t.Lldp
}

// GetOrCreateLoadBalancing retrieves the value of the LoadBalancing field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateLoadBalancing() *SrlNokiaSystem_System_LoadBalancing {
	if t.LoadBalancing != nil {
		return t.LoadBalancing
	}
	t.LoadBalancing = &SrlNokiaSystem_System_LoadBalancing{}
	return t.LoadBalancing
}

// GetOrCreateLogging retrieves the value of the Logging field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateLogging() *SrlNokiaSystem_System_Logging {
	if t.Logging != nil {
		return t.Logging
	}
	t.Logging = &SrlNokiaSystem_System_Logging{}
	return t.Logging
}

// GetOrCreateMaintenance retrieves the value of the Maintenance field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateMaintenance() *SrlNokiaSystem_System_Maintenance {
	if t.Maintenance != nil {
		return t.Maintenance
	}
	t.Maintenance = &SrlNokiaSystem_System_Maintenance{}
	return t.Maintenance
}

// GetOrCreateManagement retrieves the value of the Management field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateManagement() *SrlNokiaSystem_System_Management {
	if t.Management != nil {
		return t.Management
	}
	t.Management = &SrlNokiaSystem_System_Management{}
	return t.Management
}

// GetOrCreateMirroring retrieves the value of the Mirroring field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateMirroring() *SrlNokiaSystem_System_Mirroring {
	if t.Mirroring != nil {
		return t.Mirroring
	}
	t.Mirroring = &SrlNokiaSystem_System_Mirroring{}
	return t.Mirroring
}

// GetOrCreateMpls retrieves the value of the Mpls field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateMpls() *SrlNokiaSystem_System_Mpls {
	if t.Mpls != nil {
		return t.Mpls
	}
	t.Mpls = &SrlNokiaSystem_System_Mpls{}
	return t.Mpls
}

// GetOrCreateMtu retrieves the value of the Mtu field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateMtu() *SrlNokiaSystem_System_Mtu {
	if t.Mtu != nil {
		return t.Mtu
	}
	t.Mtu = &SrlNokiaSystem_System_Mtu{}
	return t.Mtu
}

// GetOrCreateName retrieves the value of the Name field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateName() *SrlNokiaSystem_System_Name {
	if t.Name != nil {
		return t.Name
	}
	t.Name = &SrlNokiaSystem_System_Name{}
	return t.Name
}

// GetOrCreateNetworkInstance retrieves the value of the NetworkInstance field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateNetworkInstance() *SrlNokiaSystem_System_NetworkInstance {
	if t.NetworkInstance != nil {
		return t.NetworkInstance
	}
	t.NetworkInstance = &SrlNokiaSystem_System_NetworkInstance{}
	return t.NetworkInstance
}

// GetOrCreateNtp retrieves the value of the Ntp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateNtp() *SrlNokiaSystem_System_Ntp {
	if t.Ntp != nil {
		return t.Ntp
	}
	t.Ntp = &SrlNokiaSystem_System_Ntp{}
	return t.Ntp
}

// GetOrCreateP4RtServer retrieves the value of the P4RtServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateP4RtServer() *SrlNokiaSystem_System_P4RtServer {
	if t.P4RtServer != nil {
		return t.P4RtServer
	}
	t.P4RtServer = &SrlNokiaSystem_System_P4RtServer{}
	return t.P4RtServer
}

// GetOrCreateSflow retrieves the value of the Sflow field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateSflow() *SrlNokiaSystem_System_Sflow {
	if t.Sflow != nil {
		return t.Sflow
	}
	t.Sflow = &SrlNokiaSystem_System_Sflow{}
	return t.Sflow
}

// GetOrCreateSnmp retrieves the value of the Snmp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateSnmp() *SrlNokiaSystem_System_Snmp {
	if t.Snmp != nil {
		return t.Snmp
	}
	t.Snmp = &SrlNokiaSystem_System_Snmp{}
	return t.Snmp
}

// GetOrCreateSshServer retrieves the value of the SshServer field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateSshServer() *SrlNokiaSystem_System_SshServer {
	if t.SshServer != nil {
		return t.SshServer
	}
	t.SshServer = &SrlNokiaSystem_System_SshServer{}
	return t.SshServer
}

// GetOrCreateSync retrieves the value of the Sync field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateSync() *SrlNokiaSystem_System_Sync {
	if t.Sync != nil {
		return t.Sync
	}
	t.Sync = &SrlNokiaSystem_System_Sync{}
	return t.Sync
}

// GetOrCreateTls retrieves the value of the Tls field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateTls() *SrlNokiaSystem_System_Tls {
	if t.Tls != nil {
		return t.Tls
	}
	t.Tls = &SrlNokiaSystem_System_Tls{}
	return t.Tls
}

// GetOrCreateWarmReboot retrieves the value of the WarmReboot field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System) GetOrCreateWarmReboot() *SrlNokiaSystem_System_WarmReboot {
	if t.WarmReboot != nil {
		return t.WarmReboot
	}
	t.WarmReboot = &SrlNokiaSystem_System_WarmReboot{}
	return t.WarmReboot
}

// GetAaa returns the value of the Aaa struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Aaa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetAaa() *SrlNokiaSystem_System_Aaa {
	if t != nil && t.Aaa != nil {
		return t.Aaa
	}
	return nil
}

// GetAuthentication returns the value of the Authentication struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetAuthentication() *SrlNokiaSystem_System_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetBanner returns the value of the Banner struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Banner is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetBanner() *SrlNokiaSystem_System_Banner {
	if t != nil && t.Banner != nil {
		return t.Banner
	}
	return nil
}

// GetBoot returns the value of the Boot struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Boot is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetBoot() *SrlNokiaSystem_System_Boot {
	if t != nil && t.Boot != nil {
		return t.Boot
	}
	return nil
}

// GetBridgeTable returns the value of the BridgeTable struct pointer
// from SrlNokiaSystem_System. If the receiver or the field BridgeTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetBridgeTable() *SrlNokiaSystem_System_BridgeTable {
	if t != nil && t.BridgeTable != nil {
		return t.BridgeTable
	}
	return nil
}

// GetClock returns the value of the Clock struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Clock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetClock() *SrlNokiaSystem_System_Clock {
	if t != nil && t.Clock != nil {
		return t.Clock
	}
	return nil
}

// GetConfiguration returns the value of the Configuration struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Configuration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetConfiguration() *SrlNokiaSystem_System_Configuration {
	if t != nil && t.Configuration != nil {
		return t.Configuration
	}
	return nil
}

// GetDhcpServer returns the value of the DhcpServer struct pointer
// from SrlNokiaSystem_System. If the receiver or the field DhcpServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetDhcpServer() *SrlNokiaSystem_System_DhcpServer {
	if t != nil && t.DhcpServer != nil {
		return t.DhcpServer
	}
	return nil
}

// GetDns returns the value of the Dns struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Dns is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetDns() *SrlNokiaSystem_System_Dns {
	if t != nil && t.Dns != nil {
		return t.Dns
	}
	return nil
}

// GetEventHandler returns the value of the EventHandler struct pointer
// from SrlNokiaSystem_System. If the receiver or the field EventHandler is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetEventHandler() *SrlNokiaSystem_System_EventHandler {
	if t != nil && t.EventHandler != nil {
		return t.EventHandler
	}
	return nil
}

// GetFtpServer returns the value of the FtpServer struct pointer
// from SrlNokiaSystem_System. If the receiver or the field FtpServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetFtpServer() *SrlNokiaSystem_System_FtpServer {
	if t != nil && t.FtpServer != nil {
		return t.FtpServer
	}
	return nil
}

// GetGnmiServer returns the value of the GnmiServer struct pointer
// from SrlNokiaSystem_System. If the receiver or the field GnmiServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetGnmiServer() *SrlNokiaSystem_System_GnmiServer {
	if t != nil && t.GnmiServer != nil {
		return t.GnmiServer
	}
	return nil
}

// GetGribiServer returns the value of the GribiServer struct pointer
// from SrlNokiaSystem_System. If the receiver or the field GribiServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetGribiServer() *SrlNokiaSystem_System_GribiServer {
	if t != nil && t.GribiServer != nil {
		return t.GribiServer
	}
	return nil
}

// GetInformation returns the value of the Information struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Information is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetInformation() *SrlNokiaSystem_System_Information {
	if t != nil && t.Information != nil {
		return t.Information
	}
	return nil
}

// GetJsonRpcServer returns the value of the JsonRpcServer struct pointer
// from SrlNokiaSystem_System. If the receiver or the field JsonRpcServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetJsonRpcServer() *SrlNokiaSystem_System_JsonRpcServer {
	if t != nil && t.JsonRpcServer != nil {
		return t.JsonRpcServer
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetLacp() *SrlNokiaSystem_System_Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetLldp returns the value of the Lldp struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Lldp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetLldp() *SrlNokiaSystem_System_Lldp {
	if t != nil && t.Lldp != nil {
		return t.Lldp
	}
	return nil
}

// GetLoadBalancing returns the value of the LoadBalancing struct pointer
// from SrlNokiaSystem_System. If the receiver or the field LoadBalancing is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetLoadBalancing() *SrlNokiaSystem_System_LoadBalancing {
	if t != nil && t.LoadBalancing != nil {
		return t.LoadBalancing
	}
	return nil
}

// GetLogging returns the value of the Logging struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Logging is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetLogging() *SrlNokiaSystem_System_Logging {
	if t != nil && t.Logging != nil {
		return t.Logging
	}
	return nil
}

// GetMaintenance returns the value of the Maintenance struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Maintenance is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetMaintenance() *SrlNokiaSystem_System_Maintenance {
	if t != nil && t.Maintenance != nil {
		return t.Maintenance
	}
	return nil
}

// GetManagement returns the value of the Management struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Management is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetManagement() *SrlNokiaSystem_System_Management {
	if t != nil && t.Management != nil {
		return t.Management
	}
	return nil
}

// GetMirroring returns the value of the Mirroring struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Mirroring is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetMirroring() *SrlNokiaSystem_System_Mirroring {
	if t != nil && t.Mirroring != nil {
		return t.Mirroring
	}
	return nil
}

// GetMpls returns the value of the Mpls struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Mpls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetMpls() *SrlNokiaSystem_System_Mpls {
	if t != nil && t.Mpls != nil {
		return t.Mpls
	}
	return nil
}

// GetMtu returns the value of the Mtu struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Mtu is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetMtu() *SrlNokiaSystem_System_Mtu {
	if t != nil && t.Mtu != nil {
		return t.Mtu
	}
	return nil
}

// GetName returns the value of the Name struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Name is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetName() *SrlNokiaSystem_System_Name {
	if t != nil && t.Name != nil {
		return t.Name
	}
	return nil
}

// GetNetworkInstance returns the value of the NetworkInstance struct pointer
// from SrlNokiaSystem_System. If the receiver or the field NetworkInstance is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetNetworkInstance() *SrlNokiaSystem_System_NetworkInstance {
	if t != nil && t.NetworkInstance != nil {
		return t.NetworkInstance
	}
	return nil
}

// GetNtp returns the value of the Ntp struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Ntp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetNtp() *SrlNokiaSystem_System_Ntp {
	if t != nil && t.Ntp != nil {
		return t.Ntp
	}
	return nil
}

// GetP4RtServer returns the value of the P4RtServer struct pointer
// from SrlNokiaSystem_System. If the receiver or the field P4RtServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetP4RtServer() *SrlNokiaSystem_System_P4RtServer {
	if t != nil && t.P4RtServer != nil {
		return t.P4RtServer
	}
	return nil
}

// GetSflow returns the value of the Sflow struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Sflow is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetSflow() *SrlNokiaSystem_System_Sflow {
	if t != nil && t.Sflow != nil {
		return t.Sflow
	}
	return nil
}

// GetSnmp returns the value of the Snmp struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Snmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetSnmp() *SrlNokiaSystem_System_Snmp {
	if t != nil && t.Snmp != nil {
		return t.Snmp
	}
	return nil
}

// GetSshServer returns the value of the SshServer struct pointer
// from SrlNokiaSystem_System. If the receiver or the field SshServer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetSshServer() *SrlNokiaSystem_System_SshServer {
	if t != nil && t.SshServer != nil {
		return t.SshServer
	}
	return nil
}

// GetSync returns the value of the Sync struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Sync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetSync() *SrlNokiaSystem_System_Sync {
	if t != nil && t.Sync != nil {
		return t.Sync
	}
	return nil
}

// GetTls returns the value of the Tls struct pointer
// from SrlNokiaSystem_System. If the receiver or the field Tls is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetTls() *SrlNokiaSystem_System_Tls {
	if t != nil && t.Tls != nil {
		return t.Tls
	}
	return nil
}

// GetWarmReboot returns the value of the WarmReboot struct pointer
// from SrlNokiaSystem_System. If the receiver or the field WarmReboot is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System) GetWarmReboot() *SrlNokiaSystem_System_WarmReboot {
	if t != nil && t.WarmReboot != nil {
		return t.WarmReboot
	}
	return nil
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System) GetTraceOptions() []E_SrlNokiaSystem_System_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Aaa.PopulateDefaults()
	t.Authentication.PopulateDefaults()
	t.Banner.PopulateDefaults()
	t.Boot.PopulateDefaults()
	t.BridgeTable.PopulateDefaults()
	t.Clock.PopulateDefaults()
	t.Configuration.PopulateDefaults()
	t.DhcpServer.PopulateDefaults()
	t.Dns.PopulateDefaults()
	t.EventHandler.PopulateDefaults()
	t.FtpServer.PopulateDefaults()
	t.GnmiServer.PopulateDefaults()
	t.GribiServer.PopulateDefaults()
	t.Information.PopulateDefaults()
	t.JsonRpcServer.PopulateDefaults()
	t.Lacp.PopulateDefaults()
	t.Lldp.PopulateDefaults()
	t.LoadBalancing.PopulateDefaults()
	t.Logging.PopulateDefaults()
	t.Maintenance.PopulateDefaults()
	t.Management.PopulateDefaults()
	t.Mirroring.PopulateDefaults()
	t.Mpls.PopulateDefaults()
	t.Mtu.PopulateDefaults()
	t.Name.PopulateDefaults()
	t.NetworkInstance.PopulateDefaults()
	t.Ntp.PopulateDefaults()
	t.P4RtServer.PopulateDefaults()
	t.Sflow.PopulateDefaults()
	t.Snmp.PopulateDefaults()
	t.SshServer.PopulateDefaults()
	t.Sync.PopulateDefaults()
	t.Tls.PopulateDefaults()
	t.WarmReboot.PopulateDefaults()
	for _, e := range t.License {
		e.PopulateDefaults()
	}
	for _, e := range t.RaGuardPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System.
func (*SrlNokiaSystem_System) ΛBelongingModule() string {
	return "srl_nokia-system"
}

// SrlNokiaSystem_System_Aaa represents the /srl_nokia-system/system/aaa YANG schema element.
type SrlNokiaSystem_System_Aaa struct {
	Accounting     *SrlNokiaSystem_System_Aaa_Accounting             `path:"accounting" module:"srl_nokia-aaa"`
	Authentication *SrlNokiaSystem_System_Aaa_Authentication         `path:"authentication" module:"srl_nokia-aaa"`
	Authorization  *SrlNokiaSystem_System_Aaa_Authorization          `path:"authorization" module:"srl_nokia-aaa"`
	ServerGroup    map[string]*SrlNokiaSystem_System_Aaa_ServerGroup `path:"server-group" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa) IsYANGGoStruct() {}

// NewServerGroup creates a new entry in the ServerGroup list of the
// SrlNokiaSystem_System_Aaa struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa) NewServerGroup(Name string) (*SrlNokiaSystem_System_Aaa_ServerGroup, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerGroup == nil {
		t.ServerGroup = make(map[string]*SrlNokiaSystem_System_Aaa_ServerGroup)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ServerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ServerGroup", key)
	}

	t.ServerGroup[key] = &SrlNokiaSystem_System_Aaa_ServerGroup{
		Name: &Name,
	}

	return t.ServerGroup[key], nil
}

// RenameServerGroup renames an entry in the list ServerGroup within
// the SrlNokiaSystem_System_Aaa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Aaa) RenameServerGroup(oldK, newK string) error {
	if _, ok := t.ServerGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in ServerGroup", newK)
	}

	e, ok := t.ServerGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ServerGroup", oldK)
	}
	e.Name = &newK

	t.ServerGroup[newK] = e
	delete(t.ServerGroup, oldK)
	return nil
}

// GetOrCreateServerGroup retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Aaa) GetOrCreateServerGroup(Name string) *SrlNokiaSystem_System_Aaa_ServerGroup {
	key := Name

	if v, ok := t.ServerGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServerGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServerGroup got unexpected error: %v", err))
	}
	return v
}

// GetServerGroup retrieves the value with the specified key from
// the ServerGroup map field of SrlNokiaSystem_System_Aaa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Aaa) GetServerGroup(Name string) *SrlNokiaSystem_System_Aaa_ServerGroup {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ServerGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteServerGroup deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Aaa) DeleteServerGroup(Name string) {
	key := Name

	delete(t.ServerGroup, key)
}

// AppendServerGroup appends the supplied SrlNokiaSystem_System_Aaa_ServerGroup struct to the
// list ServerGroup of SrlNokiaSystem_System_Aaa. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Aaa_ServerGroup already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Aaa) AppendServerGroup(v *SrlNokiaSystem_System_Aaa_ServerGroup) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerGroup == nil {
		t.ServerGroup = make(map[string]*SrlNokiaSystem_System_Aaa_ServerGroup)
	}

	if _, ok := t.ServerGroup[key]; ok {
		return fmt.Errorf("duplicate key for list ServerGroup %v", key)
	}

	t.ServerGroup[key] = v
	return nil
}

// GetOrCreateAccounting retrieves the value of the Accounting field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa) GetOrCreateAccounting() *SrlNokiaSystem_System_Aaa_Accounting {
	if t.Accounting != nil {
		return t.Accounting
	}
	t.Accounting = &SrlNokiaSystem_System_Aaa_Accounting{}
	return t.Accounting
}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa) GetOrCreateAuthentication() *SrlNokiaSystem_System_Aaa_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &SrlNokiaSystem_System_Aaa_Authentication{}
	return t.Authentication
}

// GetOrCreateAuthorization retrieves the value of the Authorization field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa) GetOrCreateAuthorization() *SrlNokiaSystem_System_Aaa_Authorization {
	if t.Authorization != nil {
		return t.Authorization
	}
	t.Authorization = &SrlNokiaSystem_System_Aaa_Authorization{}
	return t.Authorization
}

// GetAccounting returns the value of the Accounting struct pointer
// from SrlNokiaSystem_System_Aaa. If the receiver or the field Accounting is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa) GetAccounting() *SrlNokiaSystem_System_Aaa_Accounting {
	if t != nil && t.Accounting != nil {
		return t.Accounting
	}
	return nil
}

// GetAuthentication returns the value of the Authentication struct pointer
// from SrlNokiaSystem_System_Aaa. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa) GetAuthentication() *SrlNokiaSystem_System_Aaa_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetAuthorization returns the value of the Authorization struct pointer
// from SrlNokiaSystem_System_Aaa. If the receiver or the field Authorization is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa) GetAuthorization() *SrlNokiaSystem_System_Aaa_Authorization {
	if t != nil && t.Authorization != nil {
		return t.Authorization
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Accounting.PopulateDefaults()
	t.Authentication.PopulateDefaults()
	t.Authorization.PopulateDefaults()
	for _, e := range t.ServerGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa.
func (*SrlNokiaSystem_System_Aaa) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Accounting represents the /srl_nokia-system/system/aaa/accounting YANG schema element.
type SrlNokiaSystem_System_Aaa_Accounting struct {
	AccountingMethod []string                                                                                  `path:"accounting-method" module:"srl_nokia-aaa"`
	Event            map[E_SrlNokiaAaaTypes_AaaAccountingEventType]*SrlNokiaSystem_System_Aaa_Accounting_Event `path:"event" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Accounting implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Accounting) IsYANGGoStruct() {}

// NewEvent creates a new entry in the Event list of the
// SrlNokiaSystem_System_Aaa_Accounting struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa_Accounting) NewEvent(EventType E_SrlNokiaAaaTypes_AaaAccountingEventType) (*SrlNokiaSystem_System_Aaa_Accounting_Event, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_SrlNokiaAaaTypes_AaaAccountingEventType]*SrlNokiaSystem_System_Aaa_Accounting_Event)
	}

	key := EventType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Event[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Event", key)
	}

	t.Event[key] = &SrlNokiaSystem_System_Aaa_Accounting_Event{
		EventType: EventType,
	}

	return t.Event[key], nil
}

// RenameEvent renames an entry in the list Event within
// the SrlNokiaSystem_System_Aaa_Accounting struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Aaa_Accounting) RenameEvent(oldK, newK E_SrlNokiaAaaTypes_AaaAccountingEventType) error {
	if _, ok := t.Event[newK]; ok {
		return fmt.Errorf("key %v already exists in Event", newK)
	}

	e, ok := t.Event[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Event", oldK)
	}
	e.EventType = newK

	t.Event[newK] = e
	delete(t.Event, oldK)
	return nil
}

// GetOrCreateEvent retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_Accounting. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Aaa_Accounting) GetOrCreateEvent(
	EventType E_SrlNokiaAaaTypes_AaaAccountingEventType,
) *SrlNokiaSystem_System_Aaa_Accounting_Event {
	key := EventType

	if v, ok := t.Event[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvent(EventType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvent got unexpected error: %v", err))
	}
	return v
}

// GetEvent retrieves the value with the specified key from
// the Event map field of SrlNokiaSystem_System_Aaa_Accounting. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Accounting) GetEvent(EventType E_SrlNokiaAaaTypes_AaaAccountingEventType) *SrlNokiaSystem_System_Aaa_Accounting_Event {
	if t == nil {
		return nil
	}

	key := EventType

	if lm, ok := t.Event[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvent deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_Accounting. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Aaa_Accounting) DeleteEvent(EventType E_SrlNokiaAaaTypes_AaaAccountingEventType) {
	key := EventType

	delete(t.Event, key)
}

// AppendEvent appends the supplied SrlNokiaSystem_System_Aaa_Accounting_Event struct to the
// list Event of SrlNokiaSystem_System_Aaa_Accounting. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Aaa_Accounting_Event already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Aaa_Accounting) AppendEvent(v *SrlNokiaSystem_System_Aaa_Accounting_Event) error {
	key := v.EventType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_SrlNokiaAaaTypes_AaaAccountingEventType]*SrlNokiaSystem_System_Aaa_Accounting_Event)
	}

	if _, ok := t.Event[key]; ok {
		return fmt.Errorf("duplicate key for list Event %v", key)
	}

	t.Event[key] = v
	return nil
}

// GetAccountingMethod retrieves the value of the leaf AccountingMethod from the SrlNokiaSystem_System_Aaa_Accounting
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AccountingMethod is set, it can
// safely use t.GetAccountingMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AccountingMethod == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Accounting) GetAccountingMethod() []string {
	if t == nil || t.AccountingMethod == nil {
		return nil
	}
	return t.AccountingMethod
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Accounting
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Accounting) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Event {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Accounting) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Accounting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Accounting) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Accounting) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Accounting.
func (*SrlNokiaSystem_System_Aaa_Accounting) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Accounting_Event represents the /srl_nokia-system/system/aaa/accounting/event YANG schema element.
type SrlNokiaSystem_System_Aaa_Accounting_Event struct {
	EventType E_SrlNokiaAaaTypes_AaaAccountingEventType  `path:"event-type" module:"srl_nokia-aaa"`
	Record    E_SrlNokiaAaaTypes_AaaAccountingRecordType `path:"record" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Accounting_Event implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Accounting_Event) IsYANGGoStruct() {}

// GetEventType retrieves the value of the leaf EventType from the SrlNokiaSystem_System_Aaa_Accounting_Event
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EventType is set, it can
// safely use t.GetEventType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EventType == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) GetEventType() E_SrlNokiaAaaTypes_AaaAccountingEventType {
	if t == nil || t.EventType == 0 {
		return 0
	}
	return t.EventType
}

// GetRecord retrieves the value of the leaf Record from the SrlNokiaSystem_System_Aaa_Accounting_Event
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Record is set, it can
// safely use t.GetRecord() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Record == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) GetRecord() E_SrlNokiaAaaTypes_AaaAccountingRecordType {
	if t == nil || t.Record == 0 {
		return 0
	}
	return t.Record
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Accounting_Event
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_Accounting_Event struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"event-type": t.EventType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Accounting_Event"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Accounting_Event.
func (*SrlNokiaSystem_System_Aaa_Accounting_Event) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authentication represents the /srl_nokia-system/system/aaa/authentication YANG schema element.
type SrlNokiaSystem_System_Aaa_Authentication struct {
	AdminUser            *SrlNokiaSystem_System_Aaa_Authentication_AdminUser       `path:"admin-user" module:"srl_nokia-aaa"`
	AuthenticationMethod []string                                                  `path:"authentication-method" module:"srl_nokia-aaa"`
	ExitOnReject         *bool                                                     `path:"exit-on-reject" module:"srl_nokia-aaa"`
	IdleTimeout          *uint32                                                   `path:"idle-timeout" module:"srl_nokia-aaa"`
	LinuxadminUser       *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser  `path:"linuxadmin-user" module:"srl_nokia-aaa"`
	Password             *SrlNokiaSystem_System_Aaa_Authentication_Password        `path:"password" module:"srl_nokia-aaa"`
	User                 map[string]*SrlNokiaSystem_System_Aaa_Authentication_User `path:"user" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authentication) IsYANGGoStruct() {}

// NewUser creates a new entry in the User list of the
// SrlNokiaSystem_System_Aaa_Authentication struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa_Authentication) NewUser(Username string) (*SrlNokiaSystem_System_Aaa_Authentication_User, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*SrlNokiaSystem_System_Aaa_Authentication_User)
	}

	key := Username

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.User[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list User", key)
	}

	t.User[key] = &SrlNokiaSystem_System_Aaa_Authentication_User{
		Username: &Username,
	}

	return t.User[key], nil
}

// RenameUser renames an entry in the list User within
// the SrlNokiaSystem_System_Aaa_Authentication struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Aaa_Authentication) RenameUser(oldK, newK string) error {
	if _, ok := t.User[newK]; ok {
		return fmt.Errorf("key %v already exists in User", newK)
	}

	e, ok := t.User[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in User", oldK)
	}
	e.Username = &newK

	t.User[newK] = e
	delete(t.User, oldK)
	return nil
}

// GetOrCreateUser retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_Authentication. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetOrCreateUser(Username string) *SrlNokiaSystem_System_Aaa_Authentication_User {
	key := Username

	if v, ok := t.User[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUser(Username)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUser got unexpected error: %v", err))
	}
	return v
}

// GetUser retrieves the value with the specified key from
// the User map field of SrlNokiaSystem_System_Aaa_Authentication. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetUser(Username string) *SrlNokiaSystem_System_Aaa_Authentication_User {
	if t == nil {
		return nil
	}

	key := Username

	if lm, ok := t.User[key]; ok {
		return lm
	}
	return nil
}

// DeleteUser deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_Authentication. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Aaa_Authentication) DeleteUser(Username string) {
	key := Username

	delete(t.User, key)
}

// AppendUser appends the supplied SrlNokiaSystem_System_Aaa_Authentication_User struct to the
// list User of SrlNokiaSystem_System_Aaa_Authentication. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Aaa_Authentication_User already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Aaa_Authentication) AppendUser(v *SrlNokiaSystem_System_Aaa_Authentication_User) error {
	if v.Username == nil {
		return fmt.Errorf("invalid nil key received for Username")
	}

	key := *v.Username

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[string]*SrlNokiaSystem_System_Aaa_Authentication_User)
	}

	if _, ok := t.User[key]; ok {
		return fmt.Errorf("duplicate key for list User %v", key)
	}

	t.User[key] = v
	return nil
}

// GetOrCreateAdminUser retrieves the value of the AdminUser field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetOrCreateAdminUser() *SrlNokiaSystem_System_Aaa_Authentication_AdminUser {
	if t.AdminUser != nil {
		return t.AdminUser
	}
	t.AdminUser = &SrlNokiaSystem_System_Aaa_Authentication_AdminUser{}
	return t.AdminUser
}

// GetOrCreateLinuxadminUser retrieves the value of the LinuxadminUser field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetOrCreateLinuxadminUser() *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser {
	if t.LinuxadminUser != nil {
		return t.LinuxadminUser
	}
	t.LinuxadminUser = &SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser{}
	return t.LinuxadminUser
}

// GetOrCreatePassword retrieves the value of the Password field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetOrCreatePassword() *SrlNokiaSystem_System_Aaa_Authentication_Password {
	if t.Password != nil {
		return t.Password
	}
	t.Password = &SrlNokiaSystem_System_Aaa_Authentication_Password{}
	return t.Password
}

// GetAdminUser returns the value of the AdminUser struct pointer
// from SrlNokiaSystem_System_Aaa_Authentication. If the receiver or the field AdminUser is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetAdminUser() *SrlNokiaSystem_System_Aaa_Authentication_AdminUser {
	if t != nil && t.AdminUser != nil {
		return t.AdminUser
	}
	return nil
}

// GetLinuxadminUser returns the value of the LinuxadminUser struct pointer
// from SrlNokiaSystem_System_Aaa_Authentication. If the receiver or the field LinuxadminUser is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetLinuxadminUser() *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser {
	if t != nil && t.LinuxadminUser != nil {
		return t.LinuxadminUser
	}
	return nil
}

// GetPassword returns the value of the Password struct pointer
// from SrlNokiaSystem_System_Aaa_Authentication. If the receiver or the field Password is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetPassword() *SrlNokiaSystem_System_Aaa_Authentication_Password {
	if t != nil && t.Password != nil {
		return t.Password
	}
	return nil
}

// GetAuthenticationMethod retrieves the value of the leaf AuthenticationMethod from the SrlNokiaSystem_System_Aaa_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationMethod is set, it can
// safely use t.GetAuthenticationMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationMethod == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetAuthenticationMethod() []string {
	if t == nil || t.AuthenticationMethod == nil {
		return nil
	}
	return t.AuthenticationMethod
}

// GetExitOnReject retrieves the value of the leaf ExitOnReject from the SrlNokiaSystem_System_Aaa_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExitOnReject is set, it can
// safely use t.GetExitOnReject() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExitOnReject == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetExitOnReject() bool {
	if t == nil || t.ExitOnReject == nil {
		return false
	}
	return *t.ExitOnReject
}

// GetIdleTimeout retrieves the value of the leaf IdleTimeout from the SrlNokiaSystem_System_Aaa_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IdleTimeout is set, it can
// safely use t.GetIdleTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IdleTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication) GetIdleTimeout() uint32 {
	if t == nil || t.IdleTimeout == nil {
		return 600
	}
	return *t.IdleTimeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ExitOnReject == nil {
		var v bool = false
		t.ExitOnReject = &v
	}
	if t.IdleTimeout == nil {
		var v uint32 = 600
		t.IdleTimeout = &v
	}
	t.AdminUser.PopulateDefaults()
	t.LinuxadminUser.PopulateDefaults()
	t.Password.PopulateDefaults()
	for _, e := range t.User {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authentication.
func (*SrlNokiaSystem_System_Aaa_Authentication) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authentication_AdminUser represents the /srl_nokia-system/system/aaa/authentication/admin-user YANG schema element.
type SrlNokiaSystem_System_Aaa_Authentication_AdminUser struct {
	Password *string `path:"password" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authentication_AdminUser implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authentication_AdminUser) IsYANGGoStruct() {}

// GetPassword retrieves the value of the leaf Password from the SrlNokiaSystem_System_Aaa_Authentication_AdminUser
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Password is set, it can
// safely use t.GetPassword() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Password == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_AdminUser) GetPassword() string {
	if t == nil || t.Password == nil {
		return "$ar2$aOvsuj0ALlU=$r750fMa3ZEA/Di8dIfU2fQ=="
	}
	return *t.Password
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authentication_AdminUser
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authentication_AdminUser) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Password == nil {
		var v string = "$ar2$aOvsuj0ALlU=$r750fMa3ZEA/Di8dIfU2fQ=="
		t.Password = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_AdminUser) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_AdminUser"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_AdminUser) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_AdminUser) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authentication_AdminUser.
func (*SrlNokiaSystem_System_Aaa_Authentication_AdminUser) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser represents the /srl_nokia-system/system/aaa/authentication/linuxadmin-user YANG schema element.
type SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser struct {
	Password *string `path:"password" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser) IsYANGGoStruct() {}

// GetPassword retrieves the value of the leaf Password from the SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Password is set, it can
// safely use t.GetPassword() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Password == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser) GetPassword() string {
	if t == nil || t.Password == nil {
		return "$6$c66a15569d3f5952$kA2WPt9iqR5uMbaCUBNxsjKyXROQFdJtV1HX0CFY9wk7F326/yB3h.dERX9cH7YpeJ1N872hjzTb2tlaZFwwg0"
	}
	return *t.Password
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Password == nil {
		var v string = "$6$c66a15569d3f5952$kA2WPt9iqR5uMbaCUBNxsjKyXROQFdJtV1HX0CFY9wk7F326/yB3h.dERX9cH7YpeJ1N872hjzTb2tlaZFwwg0"
		t.Password = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser.
func (*SrlNokiaSystem_System_Aaa_Authentication_LinuxadminUser) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authentication_Password represents the /srl_nokia-system/system/aaa/authentication/password YANG schema element.
type SrlNokiaSystem_System_Aaa_Authentication_Password struct {
	Aging              *uint16                                                            `path:"aging" module:"srl_nokia-aaa"`
	ChangeOnFirstLogin *bool                                                              `path:"change-on-first-login" module:"srl_nokia-aaa"`
	ComplexityRules    *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules `path:"complexity-rules" module:"srl_nokia-aaa"`
	History            *uint16                                                            `path:"history" module:"srl_nokia-aaa"`
	LockoutPolicy      *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy   `path:"lockout-policy" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authentication_Password implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authentication_Password) IsYANGGoStruct() {}

// GetOrCreateComplexityRules retrieves the value of the ComplexityRules field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) GetOrCreateComplexityRules() *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules {
	if t.ComplexityRules != nil {
		return t.ComplexityRules
	}
	t.ComplexityRules = &SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules{}
	return t.ComplexityRules
}

// GetOrCreateLockoutPolicy retrieves the value of the LockoutPolicy field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) GetOrCreateLockoutPolicy() *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy {
	if t.LockoutPolicy != nil {
		return t.LockoutPolicy
	}
	t.LockoutPolicy = &SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy{}
	return t.LockoutPolicy
}

// GetComplexityRules returns the value of the ComplexityRules struct pointer
// from SrlNokiaSystem_System_Aaa_Authentication_Password. If the receiver or the field ComplexityRules is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) GetComplexityRules() *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules {
	if t != nil && t.ComplexityRules != nil {
		return t.ComplexityRules
	}
	return nil
}

// GetLockoutPolicy returns the value of the LockoutPolicy struct pointer
// from SrlNokiaSystem_System_Aaa_Authentication_Password. If the receiver or the field LockoutPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) GetLockoutPolicy() *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy {
	if t != nil && t.LockoutPolicy != nil {
		return t.LockoutPolicy
	}
	return nil
}

// GetAging retrieves the value of the leaf Aging from the SrlNokiaSystem_System_Aaa_Authentication_Password
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Aging is set, it can
// safely use t.GetAging() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Aging == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) GetAging() uint16 {
	if t == nil || t.Aging == nil {
		return 0
	}
	return *t.Aging
}

// GetChangeOnFirstLogin retrieves the value of the leaf ChangeOnFirstLogin from the SrlNokiaSystem_System_Aaa_Authentication_Password
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChangeOnFirstLogin is set, it can
// safely use t.GetChangeOnFirstLogin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChangeOnFirstLogin == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) GetChangeOnFirstLogin() bool {
	if t == nil || t.ChangeOnFirstLogin == nil {
		return false
	}
	return *t.ChangeOnFirstLogin
}

// GetHistory retrieves the value of the leaf History from the SrlNokiaSystem_System_Aaa_Authentication_Password
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if History is set, it can
// safely use t.GetHistory() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.History == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) GetHistory() uint16 {
	if t == nil || t.History == nil {
		return 0
	}
	return *t.History
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authentication_Password
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Aging == nil {
		var v uint16 = 0
		t.Aging = &v
	}
	if t.ChangeOnFirstLogin == nil {
		var v bool = false
		t.ChangeOnFirstLogin = &v
	}
	if t.History == nil {
		var v uint16 = 0
		t.History = &v
	}
	t.ComplexityRules.PopulateDefaults()
	t.LockoutPolicy.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_Password"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authentication_Password.
func (*SrlNokiaSystem_System_Aaa_Authentication_Password) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules represents the /srl_nokia-system/system/aaa/authentication/password/complexity-rules YANG schema element.
type SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules struct {
	AllowUsername           *bool   `path:"allow-username" module:"srl_nokia-aaa"`
	MaximumLength           *uint16 `path:"maximum-length" module:"srl_nokia-aaa"`
	MinimumLength           *uint16 `path:"minimum-length" module:"srl_nokia-aaa"`
	MinimumLowercase        *uint16 `path:"minimum-lowercase" module:"srl_nokia-aaa"`
	MinimumNumeric          *uint16 `path:"minimum-numeric" module:"srl_nokia-aaa"`
	MinimumSpecialCharacter *uint16 `path:"minimum-special-character" module:"srl_nokia-aaa"`
	MinimumUppercase        *uint16 `path:"minimum-uppercase" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) IsYANGGoStruct() {}

// GetAllowUsername retrieves the value of the leaf AllowUsername from the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowUsername is set, it can
// safely use t.GetAllowUsername() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowUsername == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) GetAllowUsername() bool {
	if t == nil || t.AllowUsername == nil {
		return true
	}
	return *t.AllowUsername
}

// GetMaximumLength retrieves the value of the leaf MaximumLength from the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaximumLength is set, it can
// safely use t.GetMaximumLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaximumLength == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) GetMaximumLength() uint16 {
	if t == nil || t.MaximumLength == nil {
		return 1023
	}
	return *t.MaximumLength
}

// GetMinimumLength retrieves the value of the leaf MinimumLength from the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumLength is set, it can
// safely use t.GetMinimumLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumLength == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) GetMinimumLength() uint16 {
	if t == nil || t.MinimumLength == nil {
		return 1
	}
	return *t.MinimumLength
}

// GetMinimumLowercase retrieves the value of the leaf MinimumLowercase from the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumLowercase is set, it can
// safely use t.GetMinimumLowercase() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumLowercase == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) GetMinimumLowercase() uint16 {
	if t == nil || t.MinimumLowercase == nil {
		return 0
	}
	return *t.MinimumLowercase
}

// GetMinimumNumeric retrieves the value of the leaf MinimumNumeric from the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumNumeric is set, it can
// safely use t.GetMinimumNumeric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumNumeric == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) GetMinimumNumeric() uint16 {
	if t == nil || t.MinimumNumeric == nil {
		return 0
	}
	return *t.MinimumNumeric
}

// GetMinimumSpecialCharacter retrieves the value of the leaf MinimumSpecialCharacter from the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumSpecialCharacter is set, it can
// safely use t.GetMinimumSpecialCharacter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumSpecialCharacter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) GetMinimumSpecialCharacter() uint16 {
	if t == nil || t.MinimumSpecialCharacter == nil {
		return 0
	}
	return *t.MinimumSpecialCharacter
}

// GetMinimumUppercase retrieves the value of the leaf MinimumUppercase from the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumUppercase is set, it can
// safely use t.GetMinimumUppercase() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumUppercase == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) GetMinimumUppercase() uint16 {
	if t == nil || t.MinimumUppercase == nil {
		return 0
	}
	return *t.MinimumUppercase
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllowUsername == nil {
		var v bool = true
		t.AllowUsername = &v
	}
	if t.MaximumLength == nil {
		var v uint16 = 1023
		t.MaximumLength = &v
	}
	if t.MinimumLength == nil {
		var v uint16 = 1
		t.MinimumLength = &v
	}
	if t.MinimumLowercase == nil {
		var v uint16 = 0
		t.MinimumLowercase = &v
	}
	if t.MinimumNumeric == nil {
		var v uint16 = 0
		t.MinimumNumeric = &v
	}
	if t.MinimumSpecialCharacter == nil {
		var v uint16 = 0
		t.MinimumSpecialCharacter = &v
	}
	if t.MinimumUppercase == nil {
		var v uint16 = 0
		t.MinimumUppercase = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules.
func (*SrlNokiaSystem_System_Aaa_Authentication_Password_ComplexityRules) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy represents the /srl_nokia-system/system/aaa/authentication/password/lockout-policy YANG schema element.
type SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy struct {
	Attempts *uint16 `path:"attempts" module:"srl_nokia-aaa"`
	Lockout  *uint16 `path:"lockout" module:"srl_nokia-aaa"`
	Time     *uint16 `path:"time" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) IsYANGGoStruct() {}

// GetAttempts retrieves the value of the leaf Attempts from the SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Attempts is set, it can
// safely use t.GetAttempts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Attempts == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) GetAttempts() uint16 {
	if t == nil || t.Attempts == nil {
		return 0
	}
	return *t.Attempts
}

// GetLockout retrieves the value of the leaf Lockout from the SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lockout is set, it can
// safely use t.GetLockout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lockout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) GetLockout() uint16 {
	if t == nil || t.Lockout == nil {
		return 15
	}
	return *t.Lockout
}

// GetTime retrieves the value of the leaf Time from the SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) GetTime() uint16 {
	if t == nil || t.Time == nil {
		return 1
	}
	return *t.Time
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Attempts == nil {
		var v uint16 = 0
		t.Attempts = &v
	}
	if t.Lockout == nil {
		var v uint16 = 15
		t.Lockout = &v
	}
	if t.Time == nil {
		var v uint16 = 1
		t.Time = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy.
func (*SrlNokiaSystem_System_Aaa_Authentication_Password_LockoutPolicy) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authentication_User represents the /srl_nokia-system/system/aaa/authentication/user YANG schema element.
type SrlNokiaSystem_System_Aaa_Authentication_User struct {
	Password *string  `path:"password" module:"srl_nokia-aaa"`
	Role     []string `path:"role" module:"srl_nokia-aaa"`
	SshKey   []string `path:"ssh-key" module:"srl_nokia-aaa"`
	Username *string  `path:"username" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authentication_User implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authentication_User) IsYANGGoStruct() {}

// GetPassword retrieves the value of the leaf Password from the SrlNokiaSystem_System_Aaa_Authentication_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Password is set, it can
// safely use t.GetPassword() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Password == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) GetPassword() string {
	if t == nil || t.Password == nil {
		return ""
	}
	return *t.Password
}

// GetRole retrieves the value of the leaf Role from the SrlNokiaSystem_System_Aaa_Authentication_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Role is set, it can
// safely use t.GetRole() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Role == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) GetRole() []string {
	if t == nil || t.Role == nil {
		return nil
	}
	return t.Role
}

// GetSshKey retrieves the value of the leaf SshKey from the SrlNokiaSystem_System_Aaa_Authentication_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SshKey is set, it can
// safely use t.GetSshKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SshKey == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) GetSshKey() []string {
	if t == nil || t.SshKey == nil {
		return nil
	}
	return t.SshKey
}

// GetUsername retrieves the value of the leaf Username from the SrlNokiaSystem_System_Aaa_Authentication_User
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Username is set, it can
// safely use t.GetUsername() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Username == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) GetUsername() string {
	if t == nil || t.Username == nil {
		return ""
	}
	return *t.Username
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authentication_User
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_Authentication_User struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Username == nil {
		return nil, fmt.Errorf("nil value for key Username")
	}

	return map[string]interface{}{
		"username": *t.Username,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_User"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_User) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authentication_User.
func (*SrlNokiaSystem_System_Aaa_Authentication_User) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authorization represents the /srl_nokia-system/system/aaa/authorization YANG schema element.
type SrlNokiaSystem_System_Aaa_Authorization struct {
	Role map[string]*SrlNokiaSystem_System_Aaa_Authorization_Role `path:"role" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authorization implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authorization) IsYANGGoStruct() {}

// NewRole creates a new entry in the Role list of the
// SrlNokiaSystem_System_Aaa_Authorization struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa_Authorization) NewRole(Rolename string) (*SrlNokiaSystem_System_Aaa_Authorization_Role, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Role == nil {
		t.Role = make(map[string]*SrlNokiaSystem_System_Aaa_Authorization_Role)
	}

	key := Rolename

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Role[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Role", key)
	}

	t.Role[key] = &SrlNokiaSystem_System_Aaa_Authorization_Role{
		Rolename: &Rolename,
	}

	return t.Role[key], nil
}

// RenameRole renames an entry in the list Role within
// the SrlNokiaSystem_System_Aaa_Authorization struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Aaa_Authorization) RenameRole(oldK, newK string) error {
	if _, ok := t.Role[newK]; ok {
		return fmt.Errorf("key %v already exists in Role", newK)
	}

	e, ok := t.Role[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Role", oldK)
	}
	e.Rolename = &newK

	t.Role[newK] = e
	delete(t.Role, oldK)
	return nil
}

// GetOrCreateRole retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_Authorization. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Aaa_Authorization) GetOrCreateRole(Rolename string) *SrlNokiaSystem_System_Aaa_Authorization_Role {
	key := Rolename

	if v, ok := t.Role[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRole(Rolename)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRole got unexpected error: %v", err))
	}
	return v
}

// GetRole retrieves the value with the specified key from
// the Role map field of SrlNokiaSystem_System_Aaa_Authorization. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authorization) GetRole(Rolename string) *SrlNokiaSystem_System_Aaa_Authorization_Role {
	if t == nil {
		return nil
	}

	key := Rolename

	if lm, ok := t.Role[key]; ok {
		return lm
	}
	return nil
}

// DeleteRole deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_Authorization. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Aaa_Authorization) DeleteRole(Rolename string) {
	key := Rolename

	delete(t.Role, key)
}

// AppendRole appends the supplied SrlNokiaSystem_System_Aaa_Authorization_Role struct to the
// list Role of SrlNokiaSystem_System_Aaa_Authorization. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Aaa_Authorization_Role already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Aaa_Authorization) AppendRole(v *SrlNokiaSystem_System_Aaa_Authorization_Role) error {
	if v.Rolename == nil {
		return fmt.Errorf("invalid nil key received for Rolename")
	}

	key := *v.Rolename

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Role == nil {
		t.Role = make(map[string]*SrlNokiaSystem_System_Aaa_Authorization_Role)
	}

	if _, ok := t.Role[key]; ok {
		return fmt.Errorf("duplicate key for list Role %v", key)
	}

	t.Role[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authorization
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authorization) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Role {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authorization) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authorization"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authorization) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authorization) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authorization.
func (*SrlNokiaSystem_System_Aaa_Authorization) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authorization_Role represents the /srl_nokia-system/system/aaa/authorization/role YANG schema element.
type SrlNokiaSystem_System_Aaa_Authorization_Role struct {
	Rolename *string                                                   `path:"rolename" module:"srl_nokia-aaa"`
	Services []E_SrlNokiaSystem_System_Aaa_Authorization_Role_Services `path:"services" module:"srl_nokia-aaa"`
	Tacacs   *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs      `path:"tacacs" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authorization_Role implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authorization_Role) IsYANGGoStruct() {}

// GetOrCreateTacacs retrieves the value of the Tacacs field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) GetOrCreateTacacs() *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs {
	if t.Tacacs != nil {
		return t.Tacacs
	}
	t.Tacacs = &SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs{}
	return t.Tacacs
}

// GetTacacs returns the value of the Tacacs struct pointer
// from SrlNokiaSystem_System_Aaa_Authorization_Role. If the receiver or the field Tacacs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) GetTacacs() *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs {
	if t != nil && t.Tacacs != nil {
		return t.Tacacs
	}
	return nil
}

// GetRolename retrieves the value of the leaf Rolename from the SrlNokiaSystem_System_Aaa_Authorization_Role
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rolename is set, it can
// safely use t.GetRolename() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rolename == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) GetRolename() string {
	if t == nil || t.Rolename == nil {
		return ""
	}
	return *t.Rolename
}

// GetServices retrieves the value of the leaf Services from the SrlNokiaSystem_System_Aaa_Authorization_Role
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Services is set, it can
// safely use t.GetServices() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Services == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) GetServices() []E_SrlNokiaSystem_System_Aaa_Authorization_Role_Services {
	if t == nil || t.Services == nil {
		return nil
	}
	return t.Services
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authorization_Role
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Tacacs.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_Authorization_Role struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Rolename == nil {
		return nil, fmt.Errorf("nil value for key Rolename")
	}

	return map[string]interface{}{
		"rolename": *t.Rolename,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authorization_Role"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authorization_Role.
func (*SrlNokiaSystem_System_Aaa_Authorization_Role) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs represents the /srl_nokia-system/system/aaa/authorization/role/tacacs YANG schema element.
type SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs struct {
	PrivLvl *uint8 `path:"priv-lvl" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs) IsYANGGoStruct() {}

// GetPrivLvl retrieves the value of the leaf PrivLvl from the SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrivLvl is set, it can
// safely use t.GetPrivLvl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrivLvl == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs) GetPrivLvl() uint8 {
	if t == nil || t.PrivLvl == nil {
		return 0
	}
	return *t.PrivLvl
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs.
func (*SrlNokiaSystem_System_Aaa_Authorization_Role_Tacacs) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_ServerGroup represents the /srl_nokia-system/system/aaa/server-group YANG schema element.
type SrlNokiaSystem_System_Aaa_ServerGroup struct {
	Name                 *string                                                  `path:"name" module:"srl_nokia-aaa"`
	PrivLvlAuthorization *bool                                                    `path:"priv-lvl-authorization" module:"srl_nokia-aaa"`
	Server               map[string]*SrlNokiaSystem_System_Aaa_ServerGroup_Server `path:"server" module:"srl_nokia-aaa"`
	Timeout              *uint16                                                  `path:"timeout" module:"srl_nokia-aaa"`
	Type                 E_SrlNokiaAaaTypes_AaaServerType                         `path:"type" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_ServerGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_ServerGroup) IsYANGGoStruct() {}

// NewServer creates a new entry in the Server list of the
// SrlNokiaSystem_System_Aaa_ServerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) NewServer(Address string) (*SrlNokiaSystem_System_Aaa_ServerGroup_Server, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaSystem_System_Aaa_ServerGroup_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &SrlNokiaSystem_System_Aaa_ServerGroup_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the SrlNokiaSystem_System_Aaa_ServerGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_ServerGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) GetOrCreateServer(Address string) *SrlNokiaSystem_System_Aaa_ServerGroup_Server {
	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of SrlNokiaSystem_System_Aaa_ServerGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) GetServer(Address string) *SrlNokiaSystem_System_Aaa_ServerGroup_Server {
	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// DeleteServer deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Aaa_ServerGroup. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) DeleteServer(Address string) {
	key := Address

	delete(t.Server, key)
}

// AppendServer appends the supplied SrlNokiaSystem_System_Aaa_ServerGroup_Server struct to the
// list Server of SrlNokiaSystem_System_Aaa_ServerGroup. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Aaa_ServerGroup_Server already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) AppendServer(v *SrlNokiaSystem_System_Aaa_ServerGroup_Server) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key received for Address")
	}

	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaSystem_System_Aaa_ServerGroup_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Aaa_ServerGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPrivLvlAuthorization retrieves the value of the leaf PrivLvlAuthorization from the SrlNokiaSystem_System_Aaa_ServerGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrivLvlAuthorization is set, it can
// safely use t.GetPrivLvlAuthorization() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrivLvlAuthorization == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) GetPrivLvlAuthorization() bool {
	if t == nil || t.PrivLvlAuthorization == nil {
		return false
	}
	return *t.PrivLvlAuthorization
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_Aaa_ServerGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 10
	}
	return *t.Timeout
}

// GetType retrieves the value of the leaf Type from the SrlNokiaSystem_System_Aaa_ServerGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) GetType() E_SrlNokiaAaaTypes_AaaServerType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_ServerGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PrivLvlAuthorization == nil {
		var v bool = false
		t.PrivLvlAuthorization = &v
	}
	if t.Timeout == nil {
		var v uint16 = 10
		t.Timeout = &v
	}
	for _, e := range t.Server {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_ServerGroup struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_ServerGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_ServerGroup.
func (*SrlNokiaSystem_System_Aaa_ServerGroup) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_ServerGroup_Server represents the /srl_nokia-system/system/aaa/server-group/server YANG schema element.
type SrlNokiaSystem_System_Aaa_ServerGroup_Server struct {
	Address         *string                                              `path:"address" module:"srl_nokia-aaa"`
	Name            *string                                              `path:"name" module:"srl_nokia-aaa"`
	NetworkInstance *string                                              `path:"network-instance" module:"srl_nokia-aaa"`
	Tacacs          *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs `path:"tacacs" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_ServerGroup_Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_ServerGroup_Server) IsYANGGoStruct() {}

// GetOrCreateTacacs retrieves the value of the Tacacs field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) GetOrCreateTacacs() *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs {
	if t.Tacacs != nil {
		return t.Tacacs
	}
	t.Tacacs = &SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs{}
	return t.Tacacs
}

// GetTacacs returns the value of the Tacacs struct pointer
// from SrlNokiaSystem_System_Aaa_ServerGroup_Server. If the receiver or the field Tacacs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) GetTacacs() *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs {
	if t != nil && t.Tacacs != nil {
		return t.Tacacs
	}
	return nil
}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaSystem_System_Aaa_ServerGroup_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Aaa_ServerGroup_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Aaa_ServerGroup_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_ServerGroup_Server
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Tacacs.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_ServerGroup_Server struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_ServerGroup_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_ServerGroup_Server.
func (*SrlNokiaSystem_System_Aaa_ServerGroup_Server) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs represents the /srl_nokia-system/system/aaa/server-group/server/tacacs YANG schema element.
type SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs struct {
	Port      *uint16 `path:"port" module:"srl_nokia-aaa"`
	SecretKey *string `path:"secret-key" module:"srl_nokia-aaa"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) IsYANGGoStruct() {}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 49
	}
	return *t.Port
}

// GetSecretKey retrieves the value of the leaf SecretKey from the SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecretKey is set, it can
// safely use t.GetSecretKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecretKey == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) GetSecretKey() string {
	if t == nil || t.SecretKey == nil {
		return ""
	}
	return *t.SecretKey
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Port == nil {
		var v uint16 = 49
		t.Port = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs.
func (*SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) ΛBelongingModule() string {
	return "srl_nokia-aaa"
}

// SrlNokiaSystem_System_Authentication represents the /srl_nokia-system/system/authentication YANG schema element.
type SrlNokiaSystem_System_Authentication struct {
	Keychain map[string]*SrlNokiaSystem_System_Authentication_Keychain `path:"keychain" module:"srl_nokia-keychains"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Authentication) IsYANGGoStruct() {}

// NewKeychain creates a new entry in the Keychain list of the
// SrlNokiaSystem_System_Authentication struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Authentication) NewKeychain(Name string) (*SrlNokiaSystem_System_Authentication_Keychain, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Keychain == nil {
		t.Keychain = make(map[string]*SrlNokiaSystem_System_Authentication_Keychain)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Keychain[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Keychain", key)
	}

	t.Keychain[key] = &SrlNokiaSystem_System_Authentication_Keychain{
		Name: &Name,
	}

	return t.Keychain[key], nil
}

// RenameKeychain renames an entry in the list Keychain within
// the SrlNokiaSystem_System_Authentication struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Authentication) RenameKeychain(oldK, newK string) error {
	if _, ok := t.Keychain[newK]; ok {
		return fmt.Errorf("key %v already exists in Keychain", newK)
	}

	e, ok := t.Keychain[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Keychain", oldK)
	}
	e.Name = &newK

	t.Keychain[newK] = e
	delete(t.Keychain, oldK)
	return nil
}

// GetOrCreateKeychain retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Authentication. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Authentication) GetOrCreateKeychain(Name string) *SrlNokiaSystem_System_Authentication_Keychain {
	key := Name

	if v, ok := t.Keychain[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewKeychain(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateKeychain got unexpected error: %v", err))
	}
	return v
}

// GetKeychain retrieves the value with the specified key from
// the Keychain map field of SrlNokiaSystem_System_Authentication. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Authentication) GetKeychain(Name string) *SrlNokiaSystem_System_Authentication_Keychain {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Keychain[key]; ok {
		return lm
	}
	return nil
}

// DeleteKeychain deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Authentication. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Authentication) DeleteKeychain(Name string) {
	key := Name

	delete(t.Keychain, key)
}

// AppendKeychain appends the supplied SrlNokiaSystem_System_Authentication_Keychain struct to the
// list Keychain of SrlNokiaSystem_System_Authentication. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Authentication_Keychain already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Authentication) AppendKeychain(v *SrlNokiaSystem_System_Authentication_Keychain) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Keychain == nil {
		t.Keychain = make(map[string]*SrlNokiaSystem_System_Authentication_Keychain)
	}

	if _, ok := t.Keychain[key]; ok {
		return fmt.Errorf("duplicate key for list Keychain %v", key)
	}

	t.Keychain[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Keychain {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Authentication.
func (*SrlNokiaSystem_System_Authentication) ΛBelongingModule() string {
	return "srl_nokia-keychains"
}

// SrlNokiaSystem_System_Authentication_Keychain represents the /srl_nokia-system/system/authentication/keychain YANG schema element.
type SrlNokiaSystem_System_Authentication_Keychain struct {
	AdminState  E_SrlNokiaCommon_AdminState                                  `path:"admin-state" module:"srl_nokia-keychains"`
	Description *string                                                      `path:"description" module:"srl_nokia-keychains"`
	Key         map[uint8]*SrlNokiaSystem_System_Authentication_Keychain_Key `path:"key" module:"srl_nokia-keychains"`
	Name        *string                                                      `path:"name" module:"srl_nokia-keychains"`
	Tolerance   *uint32                                                      `path:"tolerance" module:"srl_nokia-keychains"`
	Type        E_SrlNokiaKeychains_KeychainType                             `path:"type" module:"srl_nokia-keychains"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Authentication_Keychain implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Authentication_Keychain) IsYANGGoStruct() {}

// NewKey creates a new entry in the Key list of the
// SrlNokiaSystem_System_Authentication_Keychain struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Authentication_Keychain) NewKey(Index uint8) (*SrlNokiaSystem_System_Authentication_Keychain_Key, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[uint8]*SrlNokiaSystem_System_Authentication_Keychain_Key)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Key[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Key", key)
	}

	t.Key[key] = &SrlNokiaSystem_System_Authentication_Keychain_Key{
		Index: &Index,
	}

	return t.Key[key], nil
}

// RenameKey renames an entry in the list Key within
// the SrlNokiaSystem_System_Authentication_Keychain struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Authentication_Keychain) RenameKey(oldK, newK uint8) error {
	if _, ok := t.Key[newK]; ok {
		return fmt.Errorf("key %v already exists in Key", newK)
	}

	e, ok := t.Key[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Key", oldK)
	}
	e.Index = &newK

	t.Key[newK] = e
	delete(t.Key, oldK)
	return nil
}

// GetOrCreateKey retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Authentication_Keychain. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Authentication_Keychain) GetOrCreateKey(Index uint8) *SrlNokiaSystem_System_Authentication_Keychain_Key {
	key := Index

	if v, ok := t.Key[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewKey(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateKey got unexpected error: %v", err))
	}
	return v
}

// GetKey retrieves the value with the specified key from
// the Key map field of SrlNokiaSystem_System_Authentication_Keychain. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Authentication_Keychain) GetKey(Index uint8) *SrlNokiaSystem_System_Authentication_Keychain_Key {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Key[key]; ok {
		return lm
	}
	return nil
}

// DeleteKey deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Authentication_Keychain. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Authentication_Keychain) DeleteKey(Index uint8) {
	key := Index

	delete(t.Key, key)
}

// AppendKey appends the supplied SrlNokiaSystem_System_Authentication_Keychain_Key struct to the
// list Key of SrlNokiaSystem_System_Authentication_Keychain. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Authentication_Keychain_Key already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Authentication_Keychain) AppendKey(
	v *SrlNokiaSystem_System_Authentication_Keychain_Key,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Key == nil {
		t.Key = make(map[uint8]*SrlNokiaSystem_System_Authentication_Keychain_Key)
	}

	if _, ok := t.Key[key]; ok {
		return fmt.Errorf("duplicate key for list Key %v", key)
	}

	t.Key[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Authentication_Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaSystem_System_Authentication_Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Authentication_Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTolerance retrieves the value of the leaf Tolerance from the SrlNokiaSystem_System_Authentication_Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tolerance is set, it can
// safely use t.GetTolerance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tolerance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain) GetTolerance() uint32 {
	if t == nil || t.Tolerance == nil {
		return 0
	}
	return *t.Tolerance
}

// GetType retrieves the value of the leaf Type from the SrlNokiaSystem_System_Authentication_Keychain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain) GetType() E_SrlNokiaKeychains_KeychainType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Authentication_Keychain
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Authentication_Keychain) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Tolerance == nil {
		var v uint32 = 0
		t.Tolerance = &v
	}
	for _, e := range t.Key {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Authentication_Keychain struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Authentication_Keychain) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Authentication_Keychain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Authentication_Keychain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Authentication_Keychain.
func (*SrlNokiaSystem_System_Authentication_Keychain) ΛBelongingModule() string {
	return "srl_nokia-keychains"
}

// SrlNokiaSystem_System_Authentication_Keychain_Key represents the /srl_nokia-system/system/authentication/keychain/key YANG schema element.
type SrlNokiaSystem_System_Authentication_Keychain_Key struct {
	Algorithm         E_SrlNokiaKeychains_AlgorithmType                                  `path:"algorithm" module:"srl_nokia-keychains"`
	AuthenticationKey *string                                                            `path:"authentication-key" module:"srl_nokia-keychains"`
	Index             *uint8                                                             `path:"index" module:"srl_nokia-keychains"`
	ReceiveLifetime   *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime `path:"receive-lifetime" module:"srl_nokia-keychains"`
	SendLifetime      *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime    `path:"send-lifetime" module:"srl_nokia-keychains"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Authentication_Keychain_Key implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Authentication_Keychain_Key) IsYANGGoStruct() {}

// GetOrCreateReceiveLifetime retrieves the value of the ReceiveLifetime field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) GetOrCreateReceiveLifetime() *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime {
	if t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	t.ReceiveLifetime = &SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime{}
	return t.ReceiveLifetime
}

// GetOrCreateSendLifetime retrieves the value of the SendLifetime field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) GetOrCreateSendLifetime() *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime {
	if t.SendLifetime != nil {
		return t.SendLifetime
	}
	t.SendLifetime = &SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime{}
	return t.SendLifetime
}

// GetReceiveLifetime returns the value of the ReceiveLifetime struct pointer
// from SrlNokiaSystem_System_Authentication_Keychain_Key. If the receiver or the field ReceiveLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) GetReceiveLifetime() *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime {
	if t != nil && t.ReceiveLifetime != nil {
		return t.ReceiveLifetime
	}
	return nil
}

// GetSendLifetime returns the value of the SendLifetime struct pointer
// from SrlNokiaSystem_System_Authentication_Keychain_Key. If the receiver or the field SendLifetime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) GetSendLifetime() *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime {
	if t != nil && t.SendLifetime != nil {
		return t.SendLifetime
	}
	return nil
}

// GetAlgorithm retrieves the value of the leaf Algorithm from the SrlNokiaSystem_System_Authentication_Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Algorithm is set, it can
// safely use t.GetAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Algorithm == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) GetAlgorithm() E_SrlNokiaKeychains_AlgorithmType {
	if t == nil || t.Algorithm == 0 {
		return 0
	}
	return t.Algorithm
}

// GetAuthenticationKey retrieves the value of the leaf AuthenticationKey from the SrlNokiaSystem_System_Authentication_Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationKey is set, it can
// safely use t.GetAuthenticationKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationKey == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) GetAuthenticationKey() string {
	if t == nil || t.AuthenticationKey == nil {
		return ""
	}
	return *t.AuthenticationKey
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaSystem_System_Authentication_Keychain_Key
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) GetIndex() uint8 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Authentication_Keychain_Key
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ReceiveLifetime.PopulateDefaults()
	t.SendLifetime.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Authentication_Keychain_Key struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Authentication_Keychain_Key"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Authentication_Keychain_Key.
func (*SrlNokiaSystem_System_Authentication_Keychain_Key) ΛBelongingModule() string {
	return "srl_nokia-keychains"
}

// SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime represents the /srl_nokia-system/system/authentication/keychain/key/receive-lifetime YANG schema element.
type SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime struct {
	EndTime   SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime_EndTime_Union `path:"end-time" module:"srl_nokia-keychains"`
	StartTime *string                                                                         `path:"start-time" module:"srl_nokia-keychains"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) IsYANGGoStruct() {}

// GetEndTime retrieves the value of the leaf EndTime from the SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndTime is set, it can
// safely use t.GetEndTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) GetEndTime() SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime_EndTime_Union {
	if t == nil || t.EndTime == nil {
		return nil
	}
	return t.EndTime
}

// GetStartTime retrieves the value of the leaf StartTime from the SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) GetStartTime() string {
	if t == nil || t.StartTime == nil {
		return ""
	}
	return *t.StartTime
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime.
func (*SrlNokiaSystem_System_Authentication_Keychain_Key_ReceiveLifetime) ΛBelongingModule() string {
	return "srl_nokia-keychains"
}

// SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime represents the /srl_nokia-system/system/authentication/keychain/key/send-lifetime YANG schema element.
type SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime struct {
	SendAndReceive *bool   `path:"send-and-receive" module:"srl_nokia-keychains"`
	StartTime      *string `path:"start-time" module:"srl_nokia-keychains"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) IsYANGGoStruct() {}

// GetSendAndReceive retrieves the value of the leaf SendAndReceive from the SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendAndReceive is set, it can
// safely use t.GetSendAndReceive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendAndReceive == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) GetSendAndReceive() bool {
	if t == nil || t.SendAndReceive == nil {
		return false
	}
	return *t.SendAndReceive
}

// GetStartTime retrieves the value of the leaf StartTime from the SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartTime is set, it can
// safely use t.GetStartTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartTime == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) GetStartTime() string {
	if t == nil || t.StartTime == nil {
		return ""
	}
	return *t.StartTime
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime.
func (*SrlNokiaSystem_System_Authentication_Keychain_Key_SendLifetime) ΛBelongingModule() string {
	return "srl_nokia-keychains"
}

// SrlNokiaSystem_System_Banner represents the /srl_nokia-system/system/banner YANG schema element.
type SrlNokiaSystem_System_Banner struct {
	LoginBanner *string `path:"login-banner" module:"srl_nokia-system-banner"`
	MotdBanner  *string `path:"motd-banner" module:"srl_nokia-system-banner"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Banner implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Banner) IsYANGGoStruct() {}

// GetLoginBanner retrieves the value of the leaf LoginBanner from the SrlNokiaSystem_System_Banner
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LoginBanner is set, it can
// safely use t.GetLoginBanner() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LoginBanner == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Banner) GetLoginBanner() string {
	if t == nil || t.LoginBanner == nil {
		return ""
	}
	return *t.LoginBanner
}

// GetMotdBanner retrieves the value of the leaf MotdBanner from the SrlNokiaSystem_System_Banner
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MotdBanner is set, it can
// safely use t.GetMotdBanner() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MotdBanner == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Banner) GetMotdBanner() string {
	if t == nil || t.MotdBanner == nil {
		return ""
	}
	return *t.MotdBanner
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Banner
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Banner) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Banner) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Banner"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Banner) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Banner) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Banner.
func (*SrlNokiaSystem_System_Banner) ΛBelongingModule() string {
	return "srl_nokia-system-banner"
}

// SrlNokiaSystem_System_Boot represents the /srl_nokia-system/system/boot YANG schema element.
type SrlNokiaSystem_System_Boot struct {
	Autoboot *SrlNokiaSystem_System_Boot_Autoboot `path:"autoboot" module:"srl_nokia-boot"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Boot implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Boot) IsYANGGoStruct() {}

// GetOrCreateAutoboot retrieves the value of the Autoboot field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Boot) GetOrCreateAutoboot() *SrlNokiaSystem_System_Boot_Autoboot {
	if t.Autoboot != nil {
		return t.Autoboot
	}
	t.Autoboot = &SrlNokiaSystem_System_Boot_Autoboot{}
	return t.Autoboot
}

// GetAutoboot returns the value of the Autoboot struct pointer
// from SrlNokiaSystem_System_Boot. If the receiver or the field Autoboot is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Boot) GetAutoboot() *SrlNokiaSystem_System_Boot_Autoboot {
	if t != nil && t.Autoboot != nil {
		return t.Autoboot
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Boot
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Boot) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Autoboot.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Boot) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Boot"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Boot) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Boot) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Boot.
func (*SrlNokiaSystem_System_Boot) ΛBelongingModule() string {
	return "srl_nokia-boot"
}

// SrlNokiaSystem_System_Boot_Autoboot represents the /srl_nokia-system/system/boot/autoboot YANG schema element.
type SrlNokiaSystem_System_Boot_Autoboot struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-boot"`
	Attempts   *uint8                      `path:"attempts" module:"srl_nokia-boot"`
	ClientId   E_SrlNokiaBoot_ClientId     `path:"client-id" module:"srl_nokia-boot"`
	Interface  *string                     `path:"interface" module:"srl_nokia-boot"`
	Mode       []string                    `path:"mode" module:"srl_nokia-boot"`
	Timeout    *uint32                     `path:"timeout" module:"srl_nokia-boot"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Boot_Autoboot implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Boot_Autoboot) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Boot_Autoboot
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Boot_Autoboot) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetAttempts retrieves the value of the leaf Attempts from the SrlNokiaSystem_System_Boot_Autoboot
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Attempts is set, it can
// safely use t.GetAttempts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Attempts == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Boot_Autoboot) GetAttempts() uint8 {
	if t == nil || t.Attempts == nil {
		return 0
	}
	return *t.Attempts
}

// GetClientId retrieves the value of the leaf ClientId from the SrlNokiaSystem_System_Boot_Autoboot
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClientId is set, it can
// safely use t.GetClientId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClientId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Boot_Autoboot) GetClientId() E_SrlNokiaBoot_ClientId {
	if t == nil || t.ClientId == 0 {
		return 0
	}
	return t.ClientId
}

// GetInterface retrieves the value of the leaf Interface from the SrlNokiaSystem_System_Boot_Autoboot
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interface is set, it can
// safely use t.GetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Boot_Autoboot) GetInterface() string {
	if t == nil || t.Interface == nil {
		return "mgmt0"
	}
	return *t.Interface
}

// GetMode retrieves the value of the leaf Mode from the SrlNokiaSystem_System_Boot_Autoboot
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Boot_Autoboot) GetMode() []string {
	if t == nil || t.Mode == nil {
		return nil
	}
	return t.Mode
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_Boot_Autoboot
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Boot_Autoboot) GetTimeout() uint32 {
	if t == nil || t.Timeout == nil {
		return 0
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Boot_Autoboot
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Boot_Autoboot) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interface == nil {
		var v string = "mgmt0"
		t.Interface = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Boot_Autoboot) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Boot_Autoboot"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Boot_Autoboot) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Boot_Autoboot) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Boot_Autoboot.
func (*SrlNokiaSystem_System_Boot_Autoboot) ΛBelongingModule() string {
	return "srl_nokia-boot"
}

// SrlNokiaSystem_System_BridgeTable represents the /srl_nokia-system/system/bridge-table YANG schema element.
type SrlNokiaSystem_System_BridgeTable struct {
	MacLearning *SrlNokiaSystem_System_BridgeTable_MacLearning `path:"mac-learning" module:"srl_nokia-system-bridge-table"`
	MacLimit    *SrlNokiaSystem_System_BridgeTable_MacLimit    `path:"mac-limit" module:"srl_nokia-system-bridge-table"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_BridgeTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_BridgeTable) IsYANGGoStruct() {}

// GetOrCreateMacLearning retrieves the value of the MacLearning field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_BridgeTable) GetOrCreateMacLearning() *SrlNokiaSystem_System_BridgeTable_MacLearning {
	if t.MacLearning != nil {
		return t.MacLearning
	}
	t.MacLearning = &SrlNokiaSystem_System_BridgeTable_MacLearning{}
	return t.MacLearning
}

// GetOrCreateMacLimit retrieves the value of the MacLimit field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_BridgeTable) GetOrCreateMacLimit() *SrlNokiaSystem_System_BridgeTable_MacLimit {
	if t.MacLimit != nil {
		return t.MacLimit
	}
	t.MacLimit = &SrlNokiaSystem_System_BridgeTable_MacLimit{}
	return t.MacLimit
}

// GetMacLearning returns the value of the MacLearning struct pointer
// from SrlNokiaSystem_System_BridgeTable. If the receiver or the field MacLearning is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_BridgeTable) GetMacLearning() *SrlNokiaSystem_System_BridgeTable_MacLearning {
	if t != nil && t.MacLearning != nil {
		return t.MacLearning
	}
	return nil
}

// GetMacLimit returns the value of the MacLimit struct pointer
// from SrlNokiaSystem_System_BridgeTable. If the receiver or the field MacLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_BridgeTable) GetMacLimit() *SrlNokiaSystem_System_BridgeTable_MacLimit {
	if t != nil && t.MacLimit != nil {
		return t.MacLimit
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_BridgeTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_BridgeTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MacLearning.PopulateDefaults()
	t.MacLimit.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_BridgeTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_BridgeTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_BridgeTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_BridgeTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_BridgeTable.
func (*SrlNokiaSystem_System_BridgeTable) ΛBelongingModule() string {
	return "srl_nokia-system-bridge-table"
}

// SrlNokiaSystem_System_BridgeTable_MacLearning represents the /srl_nokia-system/system/bridge-table/mac-learning YANG schema element.
type SrlNokiaSystem_System_BridgeTable_MacLearning struct{}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_BridgeTable_MacLearning implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_BridgeTable_MacLearning) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_BridgeTable_MacLearning
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_BridgeTable_MacLearning) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_BridgeTable_MacLearning) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_BridgeTable_MacLearning"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_BridgeTable_MacLearning) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_BridgeTable_MacLearning) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_BridgeTable_MacLearning.
func (*SrlNokiaSystem_System_BridgeTable_MacLearning) ΛBelongingModule() string {
	return "srl_nokia-system-bridge-table"
}

// SrlNokiaSystem_System_BridgeTable_MacLimit represents the /srl_nokia-system/system/bridge-table/mac-limit YANG schema element.
type SrlNokiaSystem_System_BridgeTable_MacLimit struct{}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_BridgeTable_MacLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_BridgeTable_MacLimit) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_BridgeTable_MacLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_BridgeTable_MacLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_BridgeTable_MacLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_BridgeTable_MacLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_BridgeTable_MacLimit) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_BridgeTable_MacLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_BridgeTable_MacLimit.
func (*SrlNokiaSystem_System_BridgeTable_MacLimit) ΛBelongingModule() string {
	return "srl_nokia-system-bridge-table"
}

// SrlNokiaSystem_System_Clock represents the /srl_nokia-system/system/clock YANG schema element.
type SrlNokiaSystem_System_Clock struct {
	Timezone E_SrlNokiaTimezone_TzdataTimezone `path:"timezone" module:"srl_nokia-ntp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Clock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Clock) IsYANGGoStruct() {}

// GetTimezone retrieves the value of the leaf Timezone from the SrlNokiaSystem_System_Clock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timezone is set, it can
// safely use t.GetTimezone() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timezone == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Clock) GetTimezone() E_SrlNokiaTimezone_TzdataTimezone {
	if t == nil || t.Timezone == 0 {
		return 0
	}
	return t.Timezone
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Clock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Clock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Clock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Clock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Clock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Clock) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Clock.
func (*SrlNokiaSystem_System_Clock) ΛBelongingModule() string {
	return "srl_nokia-ntp"
}

// SrlNokiaSystem_System_Configuration represents the /srl_nokia-system/system/configuration YANG schema element.
type SrlNokiaSystem_System_Configuration struct {
	AutoCheckpoint *bool                                                `path:"auto-checkpoint" module:"srl_nokia-configuration"`
	IdleTimeout    *uint16                                              `path:"idle-timeout" module:"srl_nokia-configuration"`
	MaxCandidates  *uint8                                               `path:"max-candidates" module:"srl_nokia-configuration"`
	MaxCheckpoints *uint8                                               `path:"max-checkpoints" module:"srl_nokia-configuration"`
	Role           map[string]*SrlNokiaSystem_System_Configuration_Role `path:"role" module:"srl_nokia-configuration-role"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Configuration implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Configuration) IsYANGGoStruct() {}

// NewRole creates a new entry in the Role list of the
// SrlNokiaSystem_System_Configuration struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Configuration) NewRole(Name string) (*SrlNokiaSystem_System_Configuration_Role, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Role == nil {
		t.Role = make(map[string]*SrlNokiaSystem_System_Configuration_Role)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Role[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Role", key)
	}

	t.Role[key] = &SrlNokiaSystem_System_Configuration_Role{
		Name: &Name,
	}

	return t.Role[key], nil
}

// RenameRole renames an entry in the list Role within
// the SrlNokiaSystem_System_Configuration struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Configuration) RenameRole(oldK, newK string) error {
	if _, ok := t.Role[newK]; ok {
		return fmt.Errorf("key %v already exists in Role", newK)
	}

	e, ok := t.Role[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Role", oldK)
	}
	e.Name = &newK

	t.Role[newK] = e
	delete(t.Role, oldK)
	return nil
}

// GetOrCreateRole retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Configuration. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Configuration) GetOrCreateRole(Name string) *SrlNokiaSystem_System_Configuration_Role {
	key := Name

	if v, ok := t.Role[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRole(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRole got unexpected error: %v", err))
	}
	return v
}

// GetRole retrieves the value with the specified key from
// the Role map field of SrlNokiaSystem_System_Configuration. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Configuration) GetRole(Name string) *SrlNokiaSystem_System_Configuration_Role {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Role[key]; ok {
		return lm
	}
	return nil
}

// DeleteRole deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Configuration. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Configuration) DeleteRole(Name string) {
	key := Name

	delete(t.Role, key)
}

// AppendRole appends the supplied SrlNokiaSystem_System_Configuration_Role struct to the
// list Role of SrlNokiaSystem_System_Configuration. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Configuration_Role already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Configuration) AppendRole(v *SrlNokiaSystem_System_Configuration_Role) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Role == nil {
		t.Role = make(map[string]*SrlNokiaSystem_System_Configuration_Role)
	}

	if _, ok := t.Role[key]; ok {
		return fmt.Errorf("duplicate key for list Role %v", key)
	}

	t.Role[key] = v
	return nil
}

// GetAutoCheckpoint retrieves the value of the leaf AutoCheckpoint from the SrlNokiaSystem_System_Configuration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoCheckpoint is set, it can
// safely use t.GetAutoCheckpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoCheckpoint == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Configuration) GetAutoCheckpoint() bool {
	if t == nil || t.AutoCheckpoint == nil {
		return false
	}
	return *t.AutoCheckpoint
}

// GetIdleTimeout retrieves the value of the leaf IdleTimeout from the SrlNokiaSystem_System_Configuration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IdleTimeout is set, it can
// safely use t.GetIdleTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IdleTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Configuration) GetIdleTimeout() uint16 {
	if t == nil || t.IdleTimeout == nil {
		return 10080
	}
	return *t.IdleTimeout
}

// GetMaxCandidates retrieves the value of the leaf MaxCandidates from the SrlNokiaSystem_System_Configuration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxCandidates is set, it can
// safely use t.GetMaxCandidates() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxCandidates == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Configuration) GetMaxCandidates() uint8 {
	if t == nil || t.MaxCandidates == nil {
		return 10
	}
	return *t.MaxCandidates
}

// GetMaxCheckpoints retrieves the value of the leaf MaxCheckpoints from the SrlNokiaSystem_System_Configuration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxCheckpoints is set, it can
// safely use t.GetMaxCheckpoints() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxCheckpoints == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Configuration) GetMaxCheckpoints() uint8 {
	if t == nil || t.MaxCheckpoints == nil {
		return 10
	}
	return *t.MaxCheckpoints
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Configuration
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Configuration) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AutoCheckpoint == nil {
		var v bool = false
		t.AutoCheckpoint = &v
	}
	if t.IdleTimeout == nil {
		var v uint16 = 10080
		t.IdleTimeout = &v
	}
	if t.MaxCandidates == nil {
		var v uint8 = 10
		t.MaxCandidates = &v
	}
	if t.MaxCheckpoints == nil {
		var v uint8 = 10
		t.MaxCheckpoints = &v
	}
	for _, e := range t.Role {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Configuration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Configuration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Configuration.
func (*SrlNokiaSystem_System_Configuration) ΛBelongingModule() string {
	return "srl_nokia-configuration"
}

// SrlNokiaSystem_System_Configuration_Role represents the /srl_nokia-system/system/configuration/role YANG schema element.
type SrlNokiaSystem_System_Configuration_Role struct {
	Name *string                                                   `path:"name" module:"srl_nokia-configuration-role"`
	Rule map[string]*SrlNokiaSystem_System_Configuration_Role_Rule `path:"rule" module:"srl_nokia-configuration-role"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Configuration_Role implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Configuration_Role) IsYANGGoStruct() {}

// NewRule creates a new entry in the Rule list of the
// SrlNokiaSystem_System_Configuration_Role struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Configuration_Role) NewRule(PathReference string) (*SrlNokiaSystem_System_Configuration_Role_Rule, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[string]*SrlNokiaSystem_System_Configuration_Role_Rule)
	}

	key := PathReference

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Rule[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Rule", key)
	}

	t.Rule[key] = &SrlNokiaSystem_System_Configuration_Role_Rule{
		PathReference: &PathReference,
	}

	return t.Rule[key], nil
}

// RenameRule renames an entry in the list Rule within
// the SrlNokiaSystem_System_Configuration_Role struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Configuration_Role) RenameRule(oldK, newK string) error {
	if _, ok := t.Rule[newK]; ok {
		return fmt.Errorf("key %v already exists in Rule", newK)
	}

	e, ok := t.Rule[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Rule", oldK)
	}
	e.PathReference = &newK

	t.Rule[newK] = e
	delete(t.Rule, oldK)
	return nil
}

// GetOrCreateRule retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Configuration_Role. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Configuration_Role) GetOrCreateRule(PathReference string) *SrlNokiaSystem_System_Configuration_Role_Rule {
	key := PathReference

	if v, ok := t.Rule[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRule(PathReference)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRule got unexpected error: %v", err))
	}
	return v
}

// GetRule retrieves the value with the specified key from
// the Rule map field of SrlNokiaSystem_System_Configuration_Role. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Configuration_Role) GetRule(PathReference string) *SrlNokiaSystem_System_Configuration_Role_Rule {
	if t == nil {
		return nil
	}

	key := PathReference

	if lm, ok := t.Rule[key]; ok {
		return lm
	}
	return nil
}

// DeleteRule deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Configuration_Role. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Configuration_Role) DeleteRule(PathReference string) {
	key := PathReference

	delete(t.Rule, key)
}

// AppendRule appends the supplied SrlNokiaSystem_System_Configuration_Role_Rule struct to the
// list Rule of SrlNokiaSystem_System_Configuration_Role. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Configuration_Role_Rule already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Configuration_Role) AppendRule(v *SrlNokiaSystem_System_Configuration_Role_Rule) error {
	if v.PathReference == nil {
		return fmt.Errorf("invalid nil key received for PathReference")
	}

	key := *v.PathReference

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rule == nil {
		t.Rule = make(map[string]*SrlNokiaSystem_System_Configuration_Role_Rule)
	}

	if _, ok := t.Rule[key]; ok {
		return fmt.Errorf("duplicate key for list Rule %v", key)
	}

	t.Rule[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Configuration_Role
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Configuration_Role) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Configuration_Role
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Configuration_Role) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Rule {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Configuration_Role struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Configuration_Role) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration_Role) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Configuration_Role"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration_Role) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Configuration_Role) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Configuration_Role.
func (*SrlNokiaSystem_System_Configuration_Role) ΛBelongingModule() string {
	return "srl_nokia-configuration-role"
}

// SrlNokiaSystem_System_Configuration_Role_Rule represents the /srl_nokia-system/system/configuration/role/rule YANG schema element.
type SrlNokiaSystem_System_Configuration_Role_Rule struct {
	Action        E_SrlNokiaConfigurationRole_PathAction `path:"action" module:"srl_nokia-configuration-role"`
	PathReference *string                                `path:"path-reference" module:"srl_nokia-configuration-role"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Configuration_Role_Rule implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Configuration_Role_Rule) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the SrlNokiaSystem_System_Configuration_Role_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Configuration_Role_Rule) GetAction() E_SrlNokiaConfigurationRole_PathAction {
	if t == nil || t.Action == 0 {
		return 0
	}
	return t.Action
}

// GetPathReference retrieves the value of the leaf PathReference from the SrlNokiaSystem_System_Configuration_Role_Rule
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathReference is set, it can
// safely use t.GetPathReference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathReference == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Configuration_Role_Rule) GetPathReference() string {
	if t == nil || t.PathReference == nil {
		return ""
	}
	return *t.PathReference
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Configuration_Role_Rule
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Configuration_Role_Rule) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Configuration_Role_Rule struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Configuration_Role_Rule) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PathReference == nil {
		return nil, fmt.Errorf("nil value for key PathReference")
	}

	return map[string]interface{}{
		"path-reference": *t.PathReference,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration_Role_Rule) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Configuration_Role_Rule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration_Role_Rule) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Configuration_Role_Rule) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Configuration_Role_Rule.
func (*SrlNokiaSystem_System_Configuration_Role_Rule) ΛBelongingModule() string {
	return "srl_nokia-configuration-role"
}

// SrlNokiaSystem_System_DhcpServer represents the /srl_nokia-system/system/dhcp-server YANG schema element.
type SrlNokiaSystem_System_DhcpServer struct {
	AdminState      E_SrlNokiaCommon_AdminState                                  `path:"admin-state" module:"srl_nokia-dhcp-server"`
	NetworkInstance map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance `path:"network-instance" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_DhcpServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_DhcpServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_DhcpServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_DhcpServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_DhcpServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_DhcpServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_DhcpServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_DhcpServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_DhcpServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_DhcpServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_DhcpServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_DhcpServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_DhcpServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_DhcpServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_DhcpServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer.
func (*SrlNokiaSystem_System_DhcpServer) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance represents the /srl_nokia-system/system/dhcp-server/network-instance YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance struct {
	Dhcpv4 *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4 `path:"dhcpv4" module:"srl_nokia-dhcp-server"`
	Dhcpv6 *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 `path:"dhcpv6" module:"srl_nokia-dhcp-server"`
	Name   *string                                                  `path:"name" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance) IsYANGGoStruct() {}

// GetOrCreateDhcpv4 retrieves the value of the Dhcpv4 field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) GetOrCreateDhcpv4() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4 {
	if t.Dhcpv4 != nil {
		return t.Dhcpv4
	}
	t.Dhcpv4 = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4{}
	return t.Dhcpv4
}

// GetOrCreateDhcpv6 retrieves the value of the Dhcpv6 field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) GetOrCreateDhcpv6() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 {
	if t.Dhcpv6 != nil {
		return t.Dhcpv6
	}
	t.Dhcpv6 = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6{}
	return t.Dhcpv6
}

// GetDhcpv4 returns the value of the Dhcpv4 struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance. If the receiver or the field Dhcpv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) GetDhcpv4() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4 {
	if t != nil && t.Dhcpv4 != nil {
		return t.Dhcpv4
	}
	return nil
}

// GetDhcpv6 returns the value of the Dhcpv6 struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance. If the receiver or the field Dhcpv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) GetDhcpv6() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 {
	if t != nil && t.Dhcpv6 != nil {
		return t.Dhcpv6
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_DhcpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Dhcpv4.PopulateDefaults()
	t.Dhcpv6.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_DhcpServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4 represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4 YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4 struct {
	AdminState       E_SrlNokiaCommon_AdminState                                               `path:"admin-state" module:"srl_nokia-dhcp-server"`
	Options          *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options          `path:"options" module:"srl_nokia-dhcp-server"`
	StaticAllocation *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation `path:"static-allocation" module:"srl_nokia-dhcp-server"`
	TraceOptions     *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions     `path:"trace-options" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) IsYANGGoStruct() {}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) GetOrCreateOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options{}
	return t.Options
}

// GetOrCreateStaticAllocation retrieves the value of the StaticAllocation field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) GetOrCreateStaticAllocation() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation {
	if t.StaticAllocation != nil {
		return t.StaticAllocation
	}
	t.StaticAllocation = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation{}
	return t.StaticAllocation
}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) GetOrCreateTraceOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions{}
	return t.TraceOptions
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) GetOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetStaticAllocation returns the value of the StaticAllocation struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4. If the receiver or the field StaticAllocation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) GetStaticAllocation() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation {
	if t != nil && t.StaticAllocation != nil {
		return t.StaticAllocation
	}
	return nil
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) GetTraceOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	t.Options.PopulateDefaults()
	t.StaticAllocation.PopulateDefaults()
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4/options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options struct {
	BootfileName      *string  `path:"bootfile-name" module:"srl_nokia-dhcp-server"`
	DnsServer         []string `path:"dns-server" module:"srl_nokia-dhcp-server"`
	DomainName        *string  `path:"domain-name" module:"srl_nokia-dhcp-server"`
	Hostname          *string  `path:"hostname" module:"srl_nokia-dhcp-server"`
	NtpServer         []string `path:"ntp-server" module:"srl_nokia-dhcp-server"`
	Router            *string  `path:"router" module:"srl_nokia-dhcp-server"`
	ServerId          *string  `path:"server-id" module:"srl_nokia-dhcp-server"`
	TftpServerAddress []string `path:"tftp-server-address" module:"srl_nokia-dhcp-server"`
	TftpServerName    *string  `path:"tftp-server-name" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) IsYANGGoStruct() {}

// GetBootfileName retrieves the value of the leaf BootfileName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BootfileName is set, it can
// safely use t.GetBootfileName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BootfileName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetBootfileName() string {
	if t == nil || t.BootfileName == nil {
		return ""
	}
	return *t.BootfileName
}

// GetDnsServer retrieves the value of the leaf DnsServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DnsServer is set, it can
// safely use t.GetDnsServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DnsServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetDnsServer() []string {
	if t == nil || t.DnsServer == nil {
		return nil
	}
	return t.DnsServer
}

// GetDomainName retrieves the value of the leaf DomainName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DomainName is set, it can
// safely use t.GetDomainName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DomainName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetDomainName() string {
	if t == nil || t.DomainName == nil {
		return ""
	}
	return *t.DomainName
}

// GetHostname retrieves the value of the leaf Hostname from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Hostname is set, it can
// safely use t.GetHostname() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Hostname == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetHostname() string {
	if t == nil || t.Hostname == nil {
		return ""
	}
	return *t.Hostname
}

// GetNtpServer retrieves the value of the leaf NtpServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NtpServer is set, it can
// safely use t.GetNtpServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NtpServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetNtpServer() []string {
	if t == nil || t.NtpServer == nil {
		return nil
	}
	return t.NtpServer
}

// GetRouter retrieves the value of the leaf Router from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Router is set, it can
// safely use t.GetRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Router == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetRouter() string {
	if t == nil || t.Router == nil {
		return ""
	}
	return *t.Router
}

// GetServerId retrieves the value of the leaf ServerId from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerId is set, it can
// safely use t.GetServerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetServerId() string {
	if t == nil || t.ServerId == nil {
		return ""
	}
	return *t.ServerId
}

// GetTftpServerAddress retrieves the value of the leaf TftpServerAddress from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TftpServerAddress is set, it can
// safely use t.GetTftpServerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TftpServerAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetTftpServerAddress() []string {
	if t == nil || t.TftpServerAddress == nil {
		return nil
	}
	return t.TftpServerAddress
}

// GetTftpServerName retrieves the value of the leaf TftpServerName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TftpServerName is set, it can
// safely use t.GetTftpServerName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TftpServerName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) GetTftpServerName() string {
	if t == nil || t.TftpServerName == nil {
		return ""
	}
	return *t.TftpServerName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_Options) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4/static-allocation YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation struct {
	Host map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host `path:"host" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) IsYANGGoStruct() {}

// NewHost creates a new entry in the Host list of the
// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) NewHost(
	Mac string,
) (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Host == nil {
		t.Host = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host)
	}

	key := Mac

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Host[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Host", key)
	}

	t.Host[key] = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host{
		Mac: &Mac,
	}

	return t.Host[key], nil
}

// RenameHost renames an entry in the list Host within
// the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) RenameHost(oldK, newK string) error {
	if _, ok := t.Host[newK]; ok {
		return fmt.Errorf("key %v already exists in Host", newK)
	}

	e, ok := t.Host[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Host", oldK)
	}
	e.Mac = &newK

	t.Host[newK] = e
	delete(t.Host, oldK)
	return nil
}

// GetOrCreateHost retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) GetOrCreateHost(
	Mac string,
) *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host {
	key := Mac

	if v, ok := t.Host[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHost(Mac)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHost got unexpected error: %v", err))
	}
	return v
}

// GetHost retrieves the value with the specified key from
// the Host map field of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) GetHost(
	Mac string,
) *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host {
	if t == nil {
		return nil
	}

	key := Mac

	if lm, ok := t.Host[key]; ok {
		return lm
	}
	return nil
}

// DeleteHost deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) DeleteHost(Mac string) {
	key := Mac

	delete(t.Host, key)
}

// AppendHost appends the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host struct to the
// list Host of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) AppendHost(
	v *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host,
) error {
	if v.Mac == nil {
		return fmt.Errorf("invalid nil key received for Mac")
	}

	key := *v.Mac

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Host == nil {
		t.Host = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host)
	}

	if _, ok := t.Host[key]; ok {
		return fmt.Errorf("duplicate key for list Host %v", key)
	}

	t.Host[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Host {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4/static-allocation/host YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host struct {
	IpAddress *string                                                                                `path:"ip-address" module:"srl_nokia-dhcp-server"`
	Mac       *string                                                                                `path:"mac" module:"srl_nokia-dhcp-server"`
	Options   *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options `path:"options" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) IsYANGGoStruct() {
}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) GetOrCreateOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options{}
	return t.Options
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) GetOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetIpAddress retrieves the value of the leaf IpAddress from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetMac retrieves the value of the leaf Mac from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mac is set, it can
// safely use t.GetMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mac == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) GetMac() string {
	if t == nil || t.Mac == nil {
		return ""
	}
	return *t.Mac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Options.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Mac == nil {
		return nil, fmt.Errorf("nil value for key Mac")
	}

	return map[string]interface{}{
		"mac": *t.Mac,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4/static-allocation/host/options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options struct {
	BootfileName      *string  `path:"bootfile-name" module:"srl_nokia-dhcp-server"`
	DnsServer         []string `path:"dns-server" module:"srl_nokia-dhcp-server"`
	DomainName        *string  `path:"domain-name" module:"srl_nokia-dhcp-server"`
	Hostname          *string  `path:"hostname" module:"srl_nokia-dhcp-server"`
	NtpServer         []string `path:"ntp-server" module:"srl_nokia-dhcp-server"`
	Router            *string  `path:"router" module:"srl_nokia-dhcp-server"`
	ServerId          *string  `path:"server-id" module:"srl_nokia-dhcp-server"`
	TftpServerAddress []string `path:"tftp-server-address" module:"srl_nokia-dhcp-server"`
	TftpServerName    *string  `path:"tftp-server-name" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) IsYANGGoStruct() {
}

// GetBootfileName retrieves the value of the leaf BootfileName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BootfileName is set, it can
// safely use t.GetBootfileName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BootfileName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetBootfileName() string {
	if t == nil || t.BootfileName == nil {
		return ""
	}
	return *t.BootfileName
}

// GetDnsServer retrieves the value of the leaf DnsServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DnsServer is set, it can
// safely use t.GetDnsServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DnsServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetDnsServer() []string {
	if t == nil || t.DnsServer == nil {
		return nil
	}
	return t.DnsServer
}

// GetDomainName retrieves the value of the leaf DomainName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DomainName is set, it can
// safely use t.GetDomainName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DomainName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetDomainName() string {
	if t == nil || t.DomainName == nil {
		return ""
	}
	return *t.DomainName
}

// GetHostname retrieves the value of the leaf Hostname from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Hostname is set, it can
// safely use t.GetHostname() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Hostname == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetHostname() string {
	if t == nil || t.Hostname == nil {
		return ""
	}
	return *t.Hostname
}

// GetNtpServer retrieves the value of the leaf NtpServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NtpServer is set, it can
// safely use t.GetNtpServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NtpServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetNtpServer() []string {
	if t == nil || t.NtpServer == nil {
		return nil
	}
	return t.NtpServer
}

// GetRouter retrieves the value of the leaf Router from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Router is set, it can
// safely use t.GetRouter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Router == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetRouter() string {
	if t == nil || t.Router == nil {
		return ""
	}
	return *t.Router
}

// GetServerId retrieves the value of the leaf ServerId from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerId is set, it can
// safely use t.GetServerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetServerId() string {
	if t == nil || t.ServerId == nil {
		return ""
	}
	return *t.ServerId
}

// GetTftpServerAddress retrieves the value of the leaf TftpServerAddress from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TftpServerAddress is set, it can
// safely use t.GetTftpServerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TftpServerAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetTftpServerAddress() []string {
	if t == nil || t.TftpServerAddress == nil {
		return nil
	}
	return t.TftpServerAddress
}

// GetTftpServerName retrieves the value of the leaf TftpServerName from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TftpServerName is set, it can
// safely use t.GetTftpServerName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TftpServerName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) GetTftpServerName() string {
	if t == nil || t.TftpServerName == nil {
		return ""
	}
	return *t.TftpServerName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_StaticAllocation_Host_Options) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv4/trace-options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions struct {
	Trace []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace `path:"trace" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) GetTrace() []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6 YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 struct {
	AdminState       E_SrlNokiaCommon_AdminState                                               `path:"admin-state" module:"srl_nokia-dhcp-server"`
	Options          *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options          `path:"options" module:"srl_nokia-dhcp-server"`
	StaticAllocation *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation `path:"static-allocation" module:"srl_nokia-dhcp-server"`
	TraceOptions     *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions     `path:"trace-options" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) IsYANGGoStruct() {}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOrCreateOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options{}
	return t.Options
}

// GetOrCreateStaticAllocation retrieves the value of the StaticAllocation field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOrCreateStaticAllocation() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation {
	if t.StaticAllocation != nil {
		return t.StaticAllocation
	}
	t.StaticAllocation = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation{}
	return t.StaticAllocation
}

// GetOrCreateTraceOptions retrieves the value of the TraceOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOrCreateTraceOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions {
	if t.TraceOptions != nil {
		return t.TraceOptions
	}
	t.TraceOptions = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions{}
	return t.TraceOptions
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetStaticAllocation returns the value of the StaticAllocation struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6. If the receiver or the field StaticAllocation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetStaticAllocation() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation {
	if t != nil && t.StaticAllocation != nil {
		return t.StaticAllocation
	}
	return nil
}

// GetTraceOptions returns the value of the TraceOptions struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6. If the receiver or the field TraceOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetTraceOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions {
	if t != nil && t.TraceOptions != nil {
		return t.TraceOptions
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	t.Options.PopulateDefaults()
	t.StaticAllocation.PopulateDefaults()
	t.TraceOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options struct {
	DnsServer []string `path:"dns-server" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) IsYANGGoStruct() {}

// GetDnsServer retrieves the value of the leaf DnsServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DnsServer is set, it can
// safely use t.GetDnsServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DnsServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) GetDnsServer() []string {
	if t == nil || t.DnsServer == nil {
		return nil
	}
	return t.DnsServer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_Options) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/static-allocation YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation struct {
	Host map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host `path:"host" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) IsYANGGoStruct() {}

// NewHost creates a new entry in the Host list of the
// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) NewHost(
	Mac string,
) (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Host == nil {
		t.Host = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host)
	}

	key := Mac

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Host[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Host", key)
	}

	t.Host[key] = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host{
		Mac: &Mac,
	}

	return t.Host[key], nil
}

// RenameHost renames an entry in the list Host within
// the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) RenameHost(oldK, newK string) error {
	if _, ok := t.Host[newK]; ok {
		return fmt.Errorf("key %v already exists in Host", newK)
	}

	e, ok := t.Host[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Host", oldK)
	}
	e.Mac = &newK

	t.Host[newK] = e
	delete(t.Host, oldK)
	return nil
}

// GetOrCreateHost retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) GetOrCreateHost(
	Mac string,
) *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host {
	key := Mac

	if v, ok := t.Host[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHost(Mac)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHost got unexpected error: %v", err))
	}
	return v
}

// GetHost retrieves the value with the specified key from
// the Host map field of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) GetHost(
	Mac string,
) *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host {
	if t == nil {
		return nil
	}

	key := Mac

	if lm, ok := t.Host[key]; ok {
		return lm
	}
	return nil
}

// DeleteHost deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) DeleteHost(Mac string) {
	key := Mac

	delete(t.Host, key)
}

// AppendHost appends the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host struct to the
// list Host of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) AppendHost(
	v *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host,
) error {
	if v.Mac == nil {
		return fmt.Errorf("invalid nil key received for Mac")
	}

	key := *v.Mac

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Host == nil {
		t.Host = make(map[string]*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host)
	}

	if _, ok := t.Host[key]; ok {
		return fmt.Errorf("duplicate key for list Host %v", key)
	}

	t.Host[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Host {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/static-allocation/host YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host struct {
	IpAddress *string                                                                                `path:"ip-address" module:"srl_nokia-dhcp-server"`
	Mac       *string                                                                                `path:"mac" module:"srl_nokia-dhcp-server"`
	Options   *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options `path:"options" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) IsYANGGoStruct() {
}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetOrCreateOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options{}
	return t.Options
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetOptions() *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetIpAddress retrieves the value of the leaf IpAddress from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpAddress is set, it can
// safely use t.GetIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetIpAddress() string {
	if t == nil || t.IpAddress == nil {
		return ""
	}
	return *t.IpAddress
}

// GetMac retrieves the value of the leaf Mac from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mac is set, it can
// safely use t.GetMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mac == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) GetMac() string {
	if t == nil || t.Mac == nil {
		return ""
	}
	return *t.Mac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Options.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Mac == nil {
		return nil, fmt.Errorf("nil value for key Mac")
	}

	return map[string]interface{}{
		"mac": *t.Mac,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/static-allocation/host/options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options struct {
	DnsServer []string `path:"dns-server" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) IsYANGGoStruct() {
}

// GetDnsServer retrieves the value of the leaf DnsServer from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DnsServer is set, it can
// safely use t.GetDnsServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DnsServer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) GetDnsServer() []string {
	if t == nil || t.DnsServer == nil {
		return nil
	}
	return t.DnsServer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_StaticAllocation_Host_Options) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions represents the /srl_nokia-system/system/dhcp-server/network-instance/dhcpv6/trace-options YANG schema element.
type SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions struct {
	Trace []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace `path:"trace" module:"srl_nokia-dhcp-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) IsYANGGoStruct() {}

// GetTrace retrieves the value of the leaf Trace from the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Trace is set, it can
// safely use t.GetTrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Trace == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) GetTrace() []E_SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv4_TraceOptions_Trace {
	if t == nil || t.Trace == nil {
		return nil
	}
	return t.Trace
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions.
func (*SrlNokiaSystem_System_DhcpServer_NetworkInstance_Dhcpv6_TraceOptions) ΛBelongingModule() string {
	return "srl_nokia-dhcp-server"
}

// SrlNokiaSystem_System_Dns represents the /srl_nokia-system/system/dns YANG schema element.
type SrlNokiaSystem_System_Dns struct {
	HostEntry       map[string]*SrlNokiaSystem_System_Dns_HostEntry `path:"host-entry" module:"srl_nokia-dns"`
	NetworkInstance *string                                         `path:"network-instance" module:"srl_nokia-dns"`
	SearchList      []string                                        `path:"search-list" module:"srl_nokia-dns"`
	ServerList      []string                                        `path:"server-list" module:"srl_nokia-dns"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Dns implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Dns) IsYANGGoStruct() {}

// NewHostEntry creates a new entry in the HostEntry list of the
// SrlNokiaSystem_System_Dns struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Dns) NewHostEntry(Name string) (*SrlNokiaSystem_System_Dns_HostEntry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*SrlNokiaSystem_System_Dns_HostEntry)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HostEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HostEntry", key)
	}

	t.HostEntry[key] = &SrlNokiaSystem_System_Dns_HostEntry{
		Name: &Name,
	}

	return t.HostEntry[key], nil
}

// RenameHostEntry renames an entry in the list HostEntry within
// the SrlNokiaSystem_System_Dns struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Dns) RenameHostEntry(oldK, newK string) error {
	if _, ok := t.HostEntry[newK]; ok {
		return fmt.Errorf("key %v already exists in HostEntry", newK)
	}

	e, ok := t.HostEntry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HostEntry", oldK)
	}
	e.Name = &newK

	t.HostEntry[newK] = e
	delete(t.HostEntry, oldK)
	return nil
}

// GetOrCreateHostEntry retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Dns. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Dns) GetOrCreateHostEntry(Name string) *SrlNokiaSystem_System_Dns_HostEntry {
	key := Name

	if v, ok := t.HostEntry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHostEntry(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHostEntry got unexpected error: %v", err))
	}
	return v
}

// GetHostEntry retrieves the value with the specified key from
// the HostEntry map field of SrlNokiaSystem_System_Dns. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Dns) GetHostEntry(Name string) *SrlNokiaSystem_System_Dns_HostEntry {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.HostEntry[key]; ok {
		return lm
	}
	return nil
}

// DeleteHostEntry deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Dns. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Dns) DeleteHostEntry(Name string) {
	key := Name

	delete(t.HostEntry, key)
}

// AppendHostEntry appends the supplied SrlNokiaSystem_System_Dns_HostEntry struct to the
// list HostEntry of SrlNokiaSystem_System_Dns. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Dns_HostEntry already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Dns) AppendHostEntry(v *SrlNokiaSystem_System_Dns_HostEntry) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*SrlNokiaSystem_System_Dns_HostEntry)
	}

	if _, ok := t.HostEntry[key]; ok {
		return fmt.Errorf("duplicate key for list HostEntry %v", key)
	}

	t.HostEntry[key] = v
	return nil
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Dns
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetSearchList retrieves the value of the leaf SearchList from the SrlNokiaSystem_System_Dns
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SearchList is set, it can
// safely use t.GetSearchList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SearchList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns) GetSearchList() []string {
	if t == nil || t.SearchList == nil {
		return nil
	}
	return t.SearchList
}

// GetServerList retrieves the value of the leaf ServerList from the SrlNokiaSystem_System_Dns
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ServerList is set, it can
// safely use t.GetServerList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ServerList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns) GetServerList() []string {
	if t == nil || t.ServerList == nil {
		return nil
	}
	return t.ServerList
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Dns
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Dns) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.HostEntry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Dns"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Dns) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Dns.
func (*SrlNokiaSystem_System_Dns) ΛBelongingModule() string {
	return "srl_nokia-dns"
}

// SrlNokiaSystem_System_Dns_HostEntry represents the /srl_nokia-system/system/dns/host-entry YANG schema element.
type SrlNokiaSystem_System_Dns_HostEntry struct {
	Ipv4Address *string `path:"ipv4-address" module:"srl_nokia-dns"`
	Ipv6Address *string `path:"ipv6-address" module:"srl_nokia-dns"`
	Name        *string `path:"name" module:"srl_nokia-dns"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Dns_HostEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Dns_HostEntry) IsYANGGoStruct() {}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the SrlNokiaSystem_System_Dns_HostEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns_HostEntry) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetIpv6Address retrieves the value of the leaf Ipv6Address from the SrlNokiaSystem_System_Dns_HostEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Address is set, it can
// safely use t.GetIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns_HostEntry) GetIpv6Address() string {
	if t == nil || t.Ipv6Address == nil {
		return ""
	}
	return *t.Ipv6Address
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Dns_HostEntry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Dns_HostEntry) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Dns_HostEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Dns_HostEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Dns_HostEntry struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Dns_HostEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns_HostEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Dns_HostEntry.
func (*SrlNokiaSystem_System_Dns_HostEntry) ΛBelongingModule() string {
	return "srl_nokia-dns"
}

// SrlNokiaSystem_System_EventHandler represents the /srl_nokia-system/system/event-handler YANG schema element.
type SrlNokiaSystem_System_EventHandler struct {
	Instance  map[string]*SrlNokiaSystem_System_EventHandler_Instance `path:"instance" module:"srl_nokia-event-handler"`
	RunAsUser *string                                                 `path:"run-as-user" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler) IsYANGGoStruct() {}

// NewInstance creates a new entry in the Instance list of the
// SrlNokiaSystem_System_EventHandler struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_EventHandler) NewInstance(Name string) (*SrlNokiaSystem_System_EventHandler_Instance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &SrlNokiaSystem_System_EventHandler_Instance{
		Name: &Name,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the SrlNokiaSystem_System_EventHandler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_EventHandler) RenameInstance(oldK, newK string) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.Name = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_EventHandler) GetOrCreateInstance(Name string) *SrlNokiaSystem_System_EventHandler_Instance {
	key := Name

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of SrlNokiaSystem_System_EventHandler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_EventHandler) GetInstance(Name string) *SrlNokiaSystem_System_EventHandler_Instance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_EventHandler) DeleteInstance(Name string) {
	key := Name

	delete(t.Instance, key)
}

// AppendInstance appends the supplied SrlNokiaSystem_System_EventHandler_Instance struct to the
// list Instance of SrlNokiaSystem_System_EventHandler. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_EventHandler_Instance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_EventHandler) AppendInstance(v *SrlNokiaSystem_System_EventHandler_Instance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// GetRunAsUser retrieves the value of the leaf RunAsUser from the SrlNokiaSystem_System_EventHandler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RunAsUser is set, it can
// safely use t.GetRunAsUser() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RunAsUser == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler) GetRunAsUser() string {
	if t == nil || t.RunAsUser == nil {
		return ""
	}
	return *t.RunAsUser
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Instance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler.
func (*SrlNokiaSystem_System_EventHandler) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_EventHandler_Instance represents the /srl_nokia-system/system/event-handler/instance YANG schema element.
type SrlNokiaSystem_System_EventHandler_Instance struct {
	AdminState    E_SrlNokiaCommon_AdminState                          `path:"admin-state" module:"srl_nokia-event-handler"`
	Name          *string                                              `path:"name" module:"srl_nokia-event-handler"`
	Options       *SrlNokiaSystem_System_EventHandler_Instance_Options `path:"options" module:"srl_nokia-event-handler"`
	Paths         []string                                             `path:"paths" module:"srl_nokia-event-handler"`
	UpythonScript *string                                              `path:"upython-script" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler_Instance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler_Instance) IsYANGGoStruct() {}

// GetOrCreateOptions retrieves the value of the Options field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetOrCreateOptions() *SrlNokiaSystem_System_EventHandler_Instance_Options {
	if t.Options != nil {
		return t.Options
	}
	t.Options = &SrlNokiaSystem_System_EventHandler_Instance_Options{}
	return t.Options
}

// GetOptions returns the value of the Options struct pointer
// from SrlNokiaSystem_System_EventHandler_Instance. If the receiver or the field Options is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetOptions() *SrlNokiaSystem_System_EventHandler_Instance_Options {
	if t != nil && t.Options != nil {
		return t.Options
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPaths retrieves the value of the leaf Paths from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Paths is set, it can
// safely use t.GetPaths() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Paths == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetPaths() []string {
	if t == nil || t.Paths == nil {
		return nil
	}
	return t.Paths
}

// GetUpythonScript retrieves the value of the leaf UpythonScript from the SrlNokiaSystem_System_EventHandler_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpythonScript is set, it can
// safely use t.GetUpythonScript() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpythonScript == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance) GetUpythonScript() string {
	if t == nil || t.UpythonScript == nil {
		return ""
	}
	return *t.UpythonScript
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler_Instance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler_Instance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	t.Options.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_EventHandler_Instance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_EventHandler_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler_Instance.
func (*SrlNokiaSystem_System_EventHandler_Instance) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_EventHandler_Instance_Options represents the /srl_nokia-system/system/event-handler/instance/options YANG schema element.
type SrlNokiaSystem_System_EventHandler_Instance_Options struct {
	Object map[string]*SrlNokiaSystem_System_EventHandler_Instance_Options_Object `path:"object" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler_Instance_Options implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options) IsYANGGoStruct() {}

// NewObject creates a new entry in the Object list of the
// SrlNokiaSystem_System_EventHandler_Instance_Options struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) NewObject(Name string) (*SrlNokiaSystem_System_EventHandler_Instance_Options_Object, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Object == nil {
		t.Object = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance_Options_Object)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Object[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Object", key)
	}

	t.Object[key] = &SrlNokiaSystem_System_EventHandler_Instance_Options_Object{
		Name: &Name,
	}

	return t.Object[key], nil
}

// RenameObject renames an entry in the list Object within
// the SrlNokiaSystem_System_EventHandler_Instance_Options struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) RenameObject(oldK, newK string) error {
	if _, ok := t.Object[newK]; ok {
		return fmt.Errorf("key %v already exists in Object", newK)
	}

	e, ok := t.Object[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Object", oldK)
	}
	e.Name = &newK

	t.Object[newK] = e
	delete(t.Object, oldK)
	return nil
}

// GetOrCreateObject retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler_Instance_Options. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) GetOrCreateObject(Name string) *SrlNokiaSystem_System_EventHandler_Instance_Options_Object {
	key := Name

	if v, ok := t.Object[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewObject(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateObject got unexpected error: %v", err))
	}
	return v
}

// GetObject retrieves the value with the specified key from
// the Object map field of SrlNokiaSystem_System_EventHandler_Instance_Options. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) GetObject(Name string) *SrlNokiaSystem_System_EventHandler_Instance_Options_Object {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Object[key]; ok {
		return lm
	}
	return nil
}

// DeleteObject deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_EventHandler_Instance_Options. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) DeleteObject(Name string) {
	key := Name

	delete(t.Object, key)
}

// AppendObject appends the supplied SrlNokiaSystem_System_EventHandler_Instance_Options_Object struct to the
// list Object of SrlNokiaSystem_System_EventHandler_Instance_Options. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_EventHandler_Instance_Options_Object already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) AppendObject(
	v *SrlNokiaSystem_System_EventHandler_Instance_Options_Object,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Object == nil {
		t.Object = make(map[string]*SrlNokiaSystem_System_EventHandler_Instance_Options_Object)
	}

	if _, ok := t.Object[key]; ok {
		return fmt.Errorf("duplicate key for list Object %v", key)
	}

	t.Object[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler_Instance_Options
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Object {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler_Instance_Options"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler_Instance_Options.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_EventHandler_Instance_Options_Object represents the /srl_nokia-system/system/event-handler/instance/options/object YANG schema element.
type SrlNokiaSystem_System_EventHandler_Instance_Options_Object struct {
	Name   *string  `path:"name" module:"srl_nokia-event-handler"`
	Value  *string  `path:"value" module:"srl_nokia-event-handler"`
	Values []string `path:"values" module:"srl_nokia-event-handler"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_EventHandler_Instance_Options_Object implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options_Object) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetValue retrieves the value of the leaf Value from the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) GetValue() string {
	if t == nil || t.Value == nil {
		return ""
	}
	return *t.Value
}

// GetValues retrieves the value of the leaf Values from the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Values is set, it can
// safely use t.GetValues() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Values == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) GetValues() []string {
	if t == nil || t.Values == nil {
		return nil
	}
	return t.Values
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_EventHandler_Instance_Options_Object
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_EventHandler_Instance_Options_Object struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_EventHandler_Instance_Options_Object"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_EventHandler_Instance_Options_Object.
func (*SrlNokiaSystem_System_EventHandler_Instance_Options_Object) ΛBelongingModule() string {
	return "srl_nokia-event-handler"
}

// SrlNokiaSystem_System_FtpServer represents the /srl_nokia-system/system/ftp-server YANG schema element.
type SrlNokiaSystem_System_FtpServer struct {
	NetworkInstance map[string]*SrlNokiaSystem_System_FtpServer_NetworkInstance `path:"network-instance" module:"srl_nokia-ftp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_FtpServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_FtpServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_FtpServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_FtpServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_FtpServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_FtpServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_FtpServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_FtpServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_FtpServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_FtpServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_FtpServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_FtpServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_FtpServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_FtpServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_FtpServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_FtpServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_FtpServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_FtpServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_FtpServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_FtpServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_FtpServer) AppendNetworkInstance(v *SrlNokiaSystem_System_FtpServer_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_FtpServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_FtpServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_FtpServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_FtpServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_FtpServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_FtpServer.
func (*SrlNokiaSystem_System_FtpServer) ΛBelongingModule() string {
	return "srl_nokia-ftp"
}

// SrlNokiaSystem_System_FtpServer_NetworkInstance represents the /srl_nokia-system/system/ftp-server/network-instance YANG schema element.
type SrlNokiaSystem_System_FtpServer_NetworkInstance struct {
	AdminState    E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-ftp"`
	Name          *string                     `path:"name" module:"srl_nokia-ftp"`
	SessionLimit  *uint8                      `path:"session-limit" module:"srl_nokia-ftp"`
	SourceAddress *string                     `path:"source-address" module:"srl_nokia-ftp"`
	Timeout       *uint16                     `path:"timeout" module:"srl_nokia-ftp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_FtpServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_FtpServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetSessionLimit() uint8 {
	if t == nil || t.SessionLimit == nil {
		return 20
	}
	return *t.SessionLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return "::"
	}
	return *t.SourceAddress
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_FtpServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 300
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_FtpServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.SessionLimit == nil {
		var v uint8 = 20
		t.SessionLimit = &v
	}
	if t.SourceAddress == nil {
		var v string = "::"
		t.SourceAddress = &v
	}
	if t.Timeout == nil {
		var v uint16 = 300
		t.Timeout = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_FtpServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_FtpServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_FtpServer_NetworkInstance.
func (*SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-ftp"
}

// SrlNokiaSystem_System_GnmiServer represents the /srl_nokia-system/system/gnmi-server YANG schema element.
type SrlNokiaSystem_System_GnmiServer struct {
	AdminState                           E_SrlNokiaCommon_AdminState                                  `path:"admin-state" module:"srl_nokia-gnmi-server"`
	CommitConfirmedTimeout               *uint32                                                      `path:"commit-confirmed-timeout" module:"srl_nokia-gnmi-server"`
	CommitSave                           *bool                                                        `path:"commit-save" module:"srl_nokia-gnmi-server"`
	IncludeDefaultsInConfigOnlyResponses *bool                                                        `path:"include-defaults-in-config-only-responses" module:"srl_nokia-gnmi-server"`
	NetworkInstance                      map[string]*SrlNokiaSystem_System_GnmiServer_NetworkInstance `path:"network-instance" module:"srl_nokia-gnmi-server"`
	RateLimit                            *uint16                                                      `path:"rate-limit" module:"srl_nokia-gnmi-server"`
	SessionLimit                         *uint16                                                      `path:"session-limit" module:"srl_nokia-gnmi-server"`
	Timeout                              *uint16                                                      `path:"timeout" module:"srl_nokia-gnmi-server"`
	TraceOptions                         []E_SrlNokiaSystem_System_GnmiServer_TraceOptions            `path:"trace-options" module:"srl_nokia-gnmi-server"`
	UnixSocket                           *SrlNokiaSystem_System_GnmiServer_UnixSocket                 `path:"unix-socket" module:"srl_nokia-gnmi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GnmiServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GnmiServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_GnmiServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_GnmiServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_GnmiServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GnmiServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_GnmiServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_GnmiServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_GnmiServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_GnmiServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_GnmiServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_GnmiServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_GnmiServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_GnmiServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_GnmiServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_GnmiServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_GnmiServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_GnmiServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_GnmiServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_GnmiServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_GnmiServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_GnmiServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GnmiServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateUnixSocket retrieves the value of the UnixSocket field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_GnmiServer) GetOrCreateUnixSocket() *SrlNokiaSystem_System_GnmiServer_UnixSocket {
	if t.UnixSocket != nil {
		return t.UnixSocket
	}
	t.UnixSocket = &SrlNokiaSystem_System_GnmiServer_UnixSocket{}
	return t.UnixSocket
}

// GetUnixSocket returns the value of the UnixSocket struct pointer
// from SrlNokiaSystem_System_GnmiServer. If the receiver or the field UnixSocket is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_GnmiServer) GetUnixSocket() *SrlNokiaSystem_System_GnmiServer_UnixSocket {
	if t != nil && t.UnixSocket != nil {
		return t.UnixSocket
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetCommitConfirmedTimeout retrieves the value of the leaf CommitConfirmedTimeout from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommitConfirmedTimeout is set, it can
// safely use t.GetCommitConfirmedTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommitConfirmedTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetCommitConfirmedTimeout() uint32 {
	if t == nil || t.CommitConfirmedTimeout == nil {
		return 0
	}
	return *t.CommitConfirmedTimeout
}

// GetCommitSave retrieves the value of the leaf CommitSave from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommitSave is set, it can
// safely use t.GetCommitSave() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommitSave == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetCommitSave() bool {
	if t == nil || t.CommitSave == nil {
		return false
	}
	return *t.CommitSave
}

// GetIncludeDefaultsInConfigOnlyResponses retrieves the value of the leaf IncludeDefaultsInConfigOnlyResponses from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeDefaultsInConfigOnlyResponses is set, it can
// safely use t.GetIncludeDefaultsInConfigOnlyResponses() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeDefaultsInConfigOnlyResponses == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetIncludeDefaultsInConfigOnlyResponses() bool {
	if t == nil || t.IncludeDefaultsInConfigOnlyResponses == nil {
		return false
	}
	return *t.IncludeDefaultsInConfigOnlyResponses
}

// GetRateLimit retrieves the value of the leaf RateLimit from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimit is set, it can
// safely use t.GetRateLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetRateLimit() uint16 {
	if t == nil || t.RateLimit == nil {
		return 60
	}
	return *t.RateLimit
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 20
	}
	return *t.SessionLimit
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 7200
	}
	return *t.Timeout
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_GnmiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer) GetTraceOptions() []E_SrlNokiaSystem_System_GnmiServer_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GnmiServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GnmiServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.CommitConfirmedTimeout == nil {
		var v uint32 = 0
		t.CommitConfirmedTimeout = &v
	}
	if t.CommitSave == nil {
		var v bool = false
		t.CommitSave = &v
	}
	if t.IncludeDefaultsInConfigOnlyResponses == nil {
		var v bool = false
		t.IncludeDefaultsInConfigOnlyResponses = &v
	}
	if t.RateLimit == nil {
		var v uint16 = 60
		t.RateLimit = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 20
		t.SessionLimit = &v
	}
	if t.Timeout == nil {
		var v uint16 = 7200
		t.Timeout = &v
	}
	t.UnixSocket.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GnmiServer.
func (*SrlNokiaSystem_System_GnmiServer) ΛBelongingModule() string {
	return "srl_nokia-gnmi-server"
}

// SrlNokiaSystem_System_GnmiServer_NetworkInstance represents the /srl_nokia-system/system/gnmi-server/network-instance YANG schema element.
type SrlNokiaSystem_System_GnmiServer_NetworkInstance struct {
	AdminState        E_SrlNokiaCommon_AdminState                                   `path:"admin-state" module:"srl_nokia-gnmi-server"`
	Name              *string                                                       `path:"name" module:"srl_nokia-gnmi-server"`
	Port              *uint16                                                       `path:"port" module:"srl_nokia-gnmi-server"`
	SourceAddress     []string                                                      `path:"source-address" module:"srl_nokia-gnmi-server"`
	TlsProfile        *string                                                       `path:"tls-profile" module:"srl_nokia-gnmi-server"`
	UseAuthentication *bool                                                         `path:"use-authentication" module:"srl_nokia-gnmi-server"`
	YangModels        E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels `path:"yang-models" module:"srl_nokia-gnmi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GnmiServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GnmiServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 57400
	}
	return *t.Port
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// GetYangModels retrieves the value of the leaf YangModels from the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if YangModels is set, it can
// safely use t.GetYangModels() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.YangModels == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) GetYangModels() E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels {
	if t == nil || t.YangModels == 0 {
		return SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
	return t.YangModels
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GnmiServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 57400
		t.Port = &v
	}
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
	if t.YangModels == 0 {
		t.YangModels = SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_GnmiServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GnmiServer_NetworkInstance.
func (*SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-gnmi-server"
}

// SrlNokiaSystem_System_GnmiServer_UnixSocket represents the /srl_nokia-system/system/gnmi-server/unix-socket YANG schema element.
type SrlNokiaSystem_System_GnmiServer_UnixSocket struct {
	AdminState        E_SrlNokiaCommon_AdminState                                   `path:"admin-state" module:"srl_nokia-gnmi-server"`
	TlsProfile        *string                                                       `path:"tls-profile" module:"srl_nokia-gnmi-server"`
	UseAuthentication *bool                                                         `path:"use-authentication" module:"srl_nokia-gnmi-server"`
	YangModels        E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels `path:"yang-models" module:"srl_nokia-gnmi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GnmiServer_UnixSocket implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GnmiServer_UnixSocket) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// GetYangModels retrieves the value of the leaf YangModels from the SrlNokiaSystem_System_GnmiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if YangModels is set, it can
// safely use t.GetYangModels() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.YangModels == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) GetYangModels() E_SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels {
	if t == nil || t.YangModels == 0 {
		return SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
	return t.YangModels
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GnmiServer_UnixSocket
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
	if t.YangModels == 0 {
		t.YangModels = SrlNokiaSystem_System_GnmiServer_NetworkInstance_YangModels_native
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GnmiServer_UnixSocket.
func (*SrlNokiaSystem_System_GnmiServer_UnixSocket) ΛBelongingModule() string {
	return "srl_nokia-gnmi-server"
}

// SrlNokiaSystem_System_GribiServer represents the /srl_nokia-system/system/gribi-server YANG schema element.
type SrlNokiaSystem_System_GribiServer struct {
	AdminState      E_SrlNokiaCommon_AdminState                                   `path:"admin-state" module:"srl_nokia-gribi-server"`
	NetworkInstance map[string]*SrlNokiaSystem_System_GribiServer_NetworkInstance `path:"network-instance" module:"srl_nokia-gribi-server"`
	RateLimit       *uint16                                                       `path:"rate-limit" module:"srl_nokia-gribi-server"`
	SessionLimit    *uint16                                                       `path:"session-limit" module:"srl_nokia-gribi-server"`
	Timeout         *uint16                                                       `path:"timeout" module:"srl_nokia-gribi-server"`
	TraceOptions    []E_SrlNokiaSystem_System_GribiServer_TraceOptions            `path:"trace-options" module:"srl_nokia-gribi-server"`
	UnixSocket      *SrlNokiaSystem_System_GribiServer_UnixSocket                 `path:"unix-socket" module:"srl_nokia-gribi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GribiServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GribiServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_GribiServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_GribiServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_GribiServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GribiServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_GribiServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_GribiServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_GribiServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_GribiServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_GribiServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_GribiServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_GribiServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_GribiServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_GribiServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_GribiServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_GribiServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_GribiServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_GribiServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_GribiServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_GribiServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_GribiServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GribiServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateUnixSocket retrieves the value of the UnixSocket field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_GribiServer) GetOrCreateUnixSocket() *SrlNokiaSystem_System_GribiServer_UnixSocket {
	if t.UnixSocket != nil {
		return t.UnixSocket
	}
	t.UnixSocket = &SrlNokiaSystem_System_GribiServer_UnixSocket{}
	return t.UnixSocket
}

// GetUnixSocket returns the value of the UnixSocket struct pointer
// from SrlNokiaSystem_System_GribiServer. If the receiver or the field UnixSocket is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_GribiServer) GetUnixSocket() *SrlNokiaSystem_System_GribiServer_UnixSocket {
	if t != nil && t.UnixSocket != nil {
		return t.UnixSocket
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetRateLimit retrieves the value of the leaf RateLimit from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimit is set, it can
// safely use t.GetRateLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetRateLimit() uint16 {
	if t == nil || t.RateLimit == nil {
		return 60
	}
	return *t.RateLimit
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 20
	}
	return *t.SessionLimit
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 7200
	}
	return *t.Timeout
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_GribiServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer) GetTraceOptions() []E_SrlNokiaSystem_System_GribiServer_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GribiServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GribiServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.RateLimit == nil {
		var v uint16 = 60
		t.RateLimit = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 20
		t.SessionLimit = &v
	}
	if t.Timeout == nil {
		var v uint16 = 7200
		t.Timeout = &v
	}
	t.UnixSocket.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GribiServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GribiServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GribiServer.
func (*SrlNokiaSystem_System_GribiServer) ΛBelongingModule() string {
	return "srl_nokia-gribi-server"
}

// SrlNokiaSystem_System_GribiServer_NetworkInstance represents the /srl_nokia-system/system/gribi-server/network-instance YANG schema element.
type SrlNokiaSystem_System_GribiServer_NetworkInstance struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-gribi-server"`
	Name              *string                     `path:"name" module:"srl_nokia-gribi-server"`
	Port              *uint16                     `path:"port" module:"srl_nokia-gribi-server"`
	SourceAddress     []string                    `path:"source-address" module:"srl_nokia-gribi-server"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-gribi-server"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-gribi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GribiServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GribiServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 57401
	}
	return *t.Port
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return nil
	}
	return t.SourceAddress
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GribiServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GribiServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 57401
		t.Port = &v
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_GribiServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GribiServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GribiServer_NetworkInstance.
func (*SrlNokiaSystem_System_GribiServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-gribi-server"
}

// SrlNokiaSystem_System_GribiServer_UnixSocket represents the /srl_nokia-system/system/gribi-server/unix-socket YANG schema element.
type SrlNokiaSystem_System_GribiServer_UnixSocket struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-gribi-server"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-gribi-server"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-gribi-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_GribiServer_UnixSocket implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_GribiServer_UnixSocket) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_GribiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_GribiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_GribiServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_GribiServer_UnixSocket
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GribiServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GribiServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_GribiServer_UnixSocket.
func (*SrlNokiaSystem_System_GribiServer_UnixSocket) ΛBelongingModule() string {
	return "srl_nokia-gribi-server"
}

// SrlNokiaSystem_System_Information represents the /srl_nokia-system/system/information YANG schema element.
type SrlNokiaSystem_System_Information struct {
	Contact  *string `path:"contact" module:"srl_nokia-system-info"`
	Location *string `path:"location" module:"srl_nokia-system-info"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Information implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Information) IsYANGGoStruct() {}

// GetContact retrieves the value of the leaf Contact from the SrlNokiaSystem_System_Information
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Contact is set, it can
// safely use t.GetContact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Contact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Information) GetContact() string {
	if t == nil || t.Contact == nil {
		return ""
	}
	return *t.Contact
}

// GetLocation retrieves the value of the leaf Location from the SrlNokiaSystem_System_Information
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Location is set, it can
// safely use t.GetLocation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Location == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Information) GetLocation() string {
	if t == nil || t.Location == nil {
		return ""
	}
	return *t.Location
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Information
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Information) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Information) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Information"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Information) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Information) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Information.
func (*SrlNokiaSystem_System_Information) ΛBelongingModule() string {
	return "srl_nokia-system-info"
}

// SrlNokiaSystem_System_JsonRpcServer represents the /srl_nokia-system/system/json-rpc-server YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer struct {
	AdminState             E_SrlNokiaCommon_AdminState                                     `path:"admin-state" module:"srl_nokia-json-rpc"`
	CommitConfirmedTimeout *uint32                                                         `path:"commit-confirmed-timeout" module:"srl_nokia-json-rpc"`
	NetworkInstance        map[string]*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance `path:"network-instance" module:"srl_nokia-json-rpc"`
	TraceOptions           []E_SrlNokiaSystem_System_JsonRpcServer_TraceOptions            `path:"trace-options" module:"srl_nokia-json-rpc"`
	UnixSocket             *SrlNokiaSystem_System_JsonRpcServer_UnixSocket                 `path:"unix-socket" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_JsonRpcServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_JsonRpcServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_JsonRpcServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_JsonRpcServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_JsonRpcServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_JsonRpcServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_JsonRpcServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_JsonRpcServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_JsonRpcServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_JsonRpcServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_JsonRpcServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_JsonRpcServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_JsonRpcServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateUnixSocket retrieves the value of the UnixSocket field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetOrCreateUnixSocket() *SrlNokiaSystem_System_JsonRpcServer_UnixSocket {
	if t.UnixSocket != nil {
		return t.UnixSocket
	}
	t.UnixSocket = &SrlNokiaSystem_System_JsonRpcServer_UnixSocket{}
	return t.UnixSocket
}

// GetUnixSocket returns the value of the UnixSocket struct pointer
// from SrlNokiaSystem_System_JsonRpcServer. If the receiver or the field UnixSocket is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetUnixSocket() *SrlNokiaSystem_System_JsonRpcServer_UnixSocket {
	if t != nil && t.UnixSocket != nil {
		return t.UnixSocket
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetCommitConfirmedTimeout retrieves the value of the leaf CommitConfirmedTimeout from the SrlNokiaSystem_System_JsonRpcServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommitConfirmedTimeout is set, it can
// safely use t.GetCommitConfirmedTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommitConfirmedTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetCommitConfirmedTimeout() uint32 {
	if t == nil || t.CommitConfirmedTimeout == nil {
		return 0
	}
	return *t.CommitConfirmedTimeout
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_JsonRpcServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer) GetTraceOptions() []E_SrlNokiaSystem_System_JsonRpcServer_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.CommitConfirmedTimeout == nil {
		var v uint32 = 0
		t.CommitConfirmedTimeout = &v
	}
	t.UnixSocket.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer.
func (*SrlNokiaSystem_System_JsonRpcServer) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_NetworkInstance represents the /srl_nokia-system/system/json-rpc-server/network-instance YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_NetworkInstance struct {
	Http  *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http  `path:"http" module:"srl_nokia-json-rpc" yangPresence:"true"`
	Https *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https `path:"https" module:"srl_nokia-json-rpc" yangPresence:"true"`
	Name  *string                                                    `path:"name" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) IsYANGGoStruct() {}

// GetOrCreateHttp retrieves the value of the Http field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetOrCreateHttp() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http {
	if t.Http != nil {
		return t.Http
	}
	t.Http = &SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http{}
	return t.Http
}

// GetOrCreateHttps retrieves the value of the Https field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetOrCreateHttps() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https {
	if t.Https != nil {
		return t.Https
	}
	t.Https = &SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https{}
	return t.Https
}

// GetHttp returns the value of the Http struct pointer
// from SrlNokiaSystem_System_JsonRpcServer_NetworkInstance. If the receiver or the field Http is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetHttp() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http {
	if t != nil && t.Http != nil {
		return t.Http
	}
	return nil
}

// GetHttps returns the value of the Https struct pointer
// from SrlNokiaSystem_System_JsonRpcServer_NetworkInstance. If the receiver or the field Https is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetHttps() *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https {
	if t != nil && t.Https != nil {
		return t.Https
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Http.PopulateDefaults()
	t.Https.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_NetworkInstance.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http represents the /srl_nokia-system/system/json-rpc-server/network-instance/http YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-json-rpc"`
	Port              *uint16                     `path:"port" module:"srl_nokia-json-rpc"`
	SessionLimit      *uint16                     `path:"session-limit" module:"srl_nokia-json-rpc"`
	SourceAddress     []string                    `path:"source-address" module:"srl_nokia-json-rpc"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 80
	}
	return *t.Port
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 10
	}
	return *t.SessionLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 80
		t.Port = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 10
		t.SessionLimit = &v
	}
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https represents the /srl_nokia-system/system/json-rpc-server/network-instance/https YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-json-rpc"`
	Port              *uint16                     `path:"port" module:"srl_nokia-json-rpc"`
	SessionLimit      *uint16                     `path:"session-limit" module:"srl_nokia-json-rpc"`
	SourceAddress     []string                    `path:"source-address" module:"srl_nokia-json-rpc"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-json-rpc"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 443
	}
	return *t.Port
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 10
	}
	return *t.SessionLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 443
		t.Port = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 10
		t.SessionLimit = &v
	}
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https.
func (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_JsonRpcServer_UnixSocket represents the /srl_nokia-system/system/json-rpc-server/unix-socket YANG schema element.
type SrlNokiaSystem_System_JsonRpcServer_UnixSocket struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-json-rpc"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-json-rpc"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-json-rpc"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_JsonRpcServer_UnixSocket implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_JsonRpcServer_UnixSocket) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_JsonRpcServer_UnixSocket
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_JsonRpcServer_UnixSocket.
func (*SrlNokiaSystem_System_JsonRpcServer_UnixSocket) ΛBelongingModule() string {
	return "srl_nokia-json-rpc"
}

// SrlNokiaSystem_System_Lacp represents the /srl_nokia-system/system/lacp YANG schema element.
type SrlNokiaSystem_System_Lacp struct {
	SystemId       *string `path:"system-id" module:"srl_nokia-lacp"`
	SystemPriority *uint16 `path:"system-priority" module:"srl_nokia-lacp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lacp) IsYANGGoStruct() {}

// GetSystemId retrieves the value of the leaf SystemId from the SrlNokiaSystem_System_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lacp) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the SrlNokiaSystem_System_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lacp) GetSystemPriority() uint16 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lacp.
func (*SrlNokiaSystem_System_Lacp) ΛBelongingModule() string {
	return "srl_nokia-lacp"
}

// SrlNokiaSystem_System_License represents the /srl_nokia-system/system/license YANG schema element.
type SrlNokiaSystem_System_License struct {
	AdminState  E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-license"`
	Data        *string                     `path:"data" module:"srl_nokia-license"`
	Description *string                     `path:"description" module:"srl_nokia-license"`
	Id          *string                     `path:"id" module:"srl_nokia-license"`
	Preferred   *bool                       `path:"preferred" module:"srl_nokia-license"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_License implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_License) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetData retrieves the value of the leaf Data from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Data is set, it can
// safely use t.GetData() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Data == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetData() string {
	if t == nil || t.Data == nil {
		return ""
	}
	return *t.Data
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetId() string {
	if t == nil || t.Id == nil {
		return ""
	}
	return *t.Id
}

// GetPreferred retrieves the value of the leaf Preferred from the SrlNokiaSystem_System_License
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preferred is set, it can
// safely use t.GetPreferred() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preferred == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_License) GetPreferred() bool {
	if t == nil || t.Preferred == nil {
		return false
	}
	return *t.Preferred
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_License
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_License) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Preferred == nil {
		var v bool = false
		t.Preferred = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_License struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_License) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_License) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_License"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_License) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_License) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_License.
func (*SrlNokiaSystem_System_License) ΛBelongingModule() string {
	return "srl_nokia-license"
}

// SrlNokiaSystem_System_Lldp represents the /srl_nokia-system/system/lldp YANG schema element.
type SrlNokiaSystem_System_Lldp struct {
	AdminState        E_SrlNokiaCommon_AdminState                              `path:"admin-state" module:"srl_nokia-lldp"`
	BgpAutoDiscovery  *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery             `path:"bgp-auto-discovery" module:"srl_nokia-lldp" yangPresence:"true"`
	HelloTimer        *uint64                                                  `path:"hello-timer" module:"srl_nokia-lldp"`
	HoldMultiplier    *uint8                                                   `path:"hold-multiplier" module:"srl_nokia-lldp"`
	Interface         map[string]*SrlNokiaSystem_System_Lldp_Interface         `path:"interface" module:"srl_nokia-lldp"`
	ManagementAddress map[string]*SrlNokiaSystem_System_Lldp_ManagementAddress `path:"management-address" module:"srl_nokia-lldp"`
	TraceOptions      []E_SrlNokiaSystem_System_Lldp_TraceOptions              `path:"trace-options" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaSystem_System_Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp) NewInterface(Name string) (*SrlNokiaSystem_System_Lldp_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaSystem_System_Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaSystem_System_Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Lldp) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Lldp) GetOrCreateInterface(Name string) *SrlNokiaSystem_System_Lldp_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaSystem_System_Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Lldp) GetInterface(Name string) *SrlNokiaSystem_System_Lldp_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Lldp) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaSystem_System_Lldp_Interface struct to the
// list Interface of SrlNokiaSystem_System_Lldp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Lldp_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Lldp) AppendInterface(v *SrlNokiaSystem_System_Lldp_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_Lldp_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewManagementAddress creates a new entry in the ManagementAddress list of the
// SrlNokiaSystem_System_Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp) NewManagementAddress(Subinterface string) (*SrlNokiaSystem_System_Lldp_ManagementAddress, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ManagementAddress == nil {
		t.ManagementAddress = make(map[string]*SrlNokiaSystem_System_Lldp_ManagementAddress)
	}

	key := Subinterface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ManagementAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ManagementAddress", key)
	}

	t.ManagementAddress[key] = &SrlNokiaSystem_System_Lldp_ManagementAddress{
		Subinterface: &Subinterface,
	}

	return t.ManagementAddress[key], nil
}

// RenameManagementAddress renames an entry in the list ManagementAddress within
// the SrlNokiaSystem_System_Lldp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Lldp) RenameManagementAddress(oldK, newK string) error {
	if _, ok := t.ManagementAddress[newK]; ok {
		return fmt.Errorf("key %v already exists in ManagementAddress", newK)
	}

	e, ok := t.ManagementAddress[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ManagementAddress", oldK)
	}
	e.Subinterface = &newK

	t.ManagementAddress[newK] = e
	delete(t.ManagementAddress, oldK)
	return nil
}

// GetOrCreateManagementAddress retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Lldp) GetOrCreateManagementAddress(Subinterface string) *SrlNokiaSystem_System_Lldp_ManagementAddress {
	key := Subinterface

	if v, ok := t.ManagementAddress[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewManagementAddress(Subinterface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateManagementAddress got unexpected error: %v", err))
	}
	return v
}

// GetManagementAddress retrieves the value with the specified key from
// the ManagementAddress map field of SrlNokiaSystem_System_Lldp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Lldp) GetManagementAddress(Subinterface string) *SrlNokiaSystem_System_Lldp_ManagementAddress {
	if t == nil {
		return nil
	}

	key := Subinterface

	if lm, ok := t.ManagementAddress[key]; ok {
		return lm
	}
	return nil
}

// DeleteManagementAddress deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Lldp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Lldp) DeleteManagementAddress(Subinterface string) {
	key := Subinterface

	delete(t.ManagementAddress, key)
}

// AppendManagementAddress appends the supplied SrlNokiaSystem_System_Lldp_ManagementAddress struct to the
// list ManagementAddress of SrlNokiaSystem_System_Lldp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Lldp_ManagementAddress already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Lldp) AppendManagementAddress(v *SrlNokiaSystem_System_Lldp_ManagementAddress) error {
	if v.Subinterface == nil {
		return fmt.Errorf("invalid nil key received for Subinterface")
	}

	key := *v.Subinterface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ManagementAddress == nil {
		t.ManagementAddress = make(map[string]*SrlNokiaSystem_System_Lldp_ManagementAddress)
	}

	if _, ok := t.ManagementAddress[key]; ok {
		return fmt.Errorf("duplicate key for list ManagementAddress %v", key)
	}

	t.ManagementAddress[key] = v
	return nil
}

// GetOrCreateBgpAutoDiscovery retrieves the value of the BgpAutoDiscovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Lldp) GetOrCreateBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery {
	if t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	t.BgpAutoDiscovery = &SrlNokiaSystem_System_Lldp_BgpAutoDiscovery{}
	return t.BgpAutoDiscovery
}

// GetBgpAutoDiscovery returns the value of the BgpAutoDiscovery struct pointer
// from SrlNokiaSystem_System_Lldp. If the receiver or the field BgpAutoDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Lldp) GetBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery {
	if t != nil && t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetHelloTimer retrieves the value of the leaf HelloTimer from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HelloTimer is set, it can
// safely use t.GetHelloTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HelloTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetHelloTimer() uint64 {
	if t == nil || t.HelloTimer == nil {
		return 30
	}
	return *t.HelloTimer
}

// GetHoldMultiplier retrieves the value of the leaf HoldMultiplier from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldMultiplier is set, it can
// safely use t.GetHoldMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldMultiplier == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetHoldMultiplier() uint8 {
	if t == nil || t.HoldMultiplier == nil {
		return 4
	}
	return *t.HoldMultiplier
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_Lldp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp) GetTraceOptions() []E_SrlNokiaSystem_System_Lldp_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	if t.HelloTimer == nil {
		var v uint64 = 30
		t.HelloTimer = &v
	}
	if t.HoldMultiplier == nil {
		var v uint8 = 4
		t.HoldMultiplier = &v
	}
	t.BgpAutoDiscovery.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.ManagementAddress {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp.
func (*SrlNokiaSystem_System_Lldp) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_BgpAutoDiscovery represents the /srl_nokia-system/system/lldp/bgp-auto-discovery YANG schema element.
type SrlNokiaSystem_System_Lldp_BgpAutoDiscovery struct {
	AdminState      E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-lldp"`
	GroupId         *uint32                     `path:"group-id" module:"srl_nokia-lldp"`
	NetworkInstance []string                    `path:"network-instance" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_BgpAutoDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetGroupId retrieves the value of the leaf GroupId from the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GroupId is set, it can
// safely use t.GetGroupId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GroupId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) GetGroupId() uint32 {
	if t == nil || t.GroupId == nil {
		return 0
	}
	return *t.GroupId
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) GetNetworkInstance() []string {
	if t == nil || t.NetworkInstance == nil {
		return nil
	}
	return t.NetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_BgpAutoDiscovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_BgpAutoDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_BgpAutoDiscovery.
func (*SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_Interface represents the /srl_nokia-system/system/lldp/interface YANG schema element.
type SrlNokiaSystem_System_Lldp_Interface struct {
	AdminState       E_SrlNokiaCommon_AdminState                            `path:"admin-state" module:"srl_nokia-lldp"`
	BgpAutoDiscovery *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery `path:"bgp-auto-discovery" module:"srl_nokia-lldp" yangPresence:"true"`
	Name             *string                                                `path:"name" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_Interface) IsYANGGoStruct() {}

// GetOrCreateBgpAutoDiscovery retrieves the value of the BgpAutoDiscovery field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetOrCreateBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery {
	if t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	t.BgpAutoDiscovery = &SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery{}
	return t.BgpAutoDiscovery
}

// GetBgpAutoDiscovery returns the value of the BgpAutoDiscovery struct pointer
// from SrlNokiaSystem_System_Lldp_Interface. If the receiver or the field BgpAutoDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetBgpAutoDiscovery() *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery {
	if t != nil && t.BgpAutoDiscovery != nil {
		return t.BgpAutoDiscovery
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Lldp_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.BgpAutoDiscovery.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_Interface struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_Interface.
func (*SrlNokiaSystem_System_Lldp_Interface) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery represents the /srl_nokia-system/system/lldp/interface/bgp-auto-discovery YANG schema element.
type SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery struct {
	AdminState     E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-lldp"`
	GroupId        *uint32                     `path:"group-id" module:"srl_nokia-lldp"`
	PeeringAddress []string                    `path:"peering-address" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetGroupId retrieves the value of the leaf GroupId from the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GroupId is set, it can
// safely use t.GetGroupId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GroupId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) GetGroupId() uint32 {
	if t == nil || t.GroupId == nil {
		return 0
	}
	return *t.GroupId
}

// GetPeeringAddress retrieves the value of the leaf PeeringAddress from the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeeringAddress is set, it can
// safely use t.GetPeeringAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeeringAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) GetPeeringAddress() []string {
	if t == nil || t.PeeringAddress == nil {
		return nil
	}
	return t.PeeringAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery.
func (*SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_Lldp_ManagementAddress represents the /srl_nokia-system/system/lldp/management-address YANG schema element.
type SrlNokiaSystem_System_Lldp_ManagementAddress struct {
	Subinterface *string                                     `path:"subinterface" module:"srl_nokia-lldp"`
	Type         []E_SrlNokiaLldpTypes_ManagementAddressType `path:"type" module:"srl_nokia-lldp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Lldp_ManagementAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Lldp_ManagementAddress) IsYANGGoStruct() {}

// GetSubinterface retrieves the value of the leaf Subinterface from the SrlNokiaSystem_System_Lldp_ManagementAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Subinterface is set, it can
// safely use t.GetSubinterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Subinterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) GetSubinterface() string {
	if t == nil || t.Subinterface == nil {
		return ""
	}
	return *t.Subinterface
}

// GetType retrieves the value of the leaf Type from the SrlNokiaSystem_System_Lldp_ManagementAddress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) GetType() []E_SrlNokiaLldpTypes_ManagementAddressType {
	if t == nil || t.Type == nil {
		return nil
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Lldp_ManagementAddress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_ManagementAddress struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Subinterface == nil {
		return nil, fmt.Errorf("nil value for key Subinterface")
	}

	return map[string]interface{}{
		"subinterface": *t.Subinterface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_ManagementAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Lldp_ManagementAddress.
func (*SrlNokiaSystem_System_Lldp_ManagementAddress) ΛBelongingModule() string {
	return "srl_nokia-lldp"
}

// SrlNokiaSystem_System_LoadBalancing represents the /srl_nokia-system/system/load-balancing YANG schema element.
type SrlNokiaSystem_System_LoadBalancing struct {
	HashOptions *SrlNokiaSystem_System_LoadBalancing_HashOptions `path:"hash-options" module:"srl_nokia-load-balancing"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_LoadBalancing implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_LoadBalancing) IsYANGGoStruct() {}

// GetOrCreateHashOptions retrieves the value of the HashOptions field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_LoadBalancing) GetOrCreateHashOptions() *SrlNokiaSystem_System_LoadBalancing_HashOptions {
	if t.HashOptions != nil {
		return t.HashOptions
	}
	t.HashOptions = &SrlNokiaSystem_System_LoadBalancing_HashOptions{}
	return t.HashOptions
}

// GetHashOptions returns the value of the HashOptions struct pointer
// from SrlNokiaSystem_System_LoadBalancing. If the receiver or the field HashOptions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_LoadBalancing) GetHashOptions() *SrlNokiaSystem_System_LoadBalancing_HashOptions {
	if t != nil && t.HashOptions != nil {
		return t.HashOptions
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_LoadBalancing
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_LoadBalancing) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.HashOptions.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_LoadBalancing"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_LoadBalancing) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_LoadBalancing.
func (*SrlNokiaSystem_System_LoadBalancing) ΛBelongingModule() string {
	return "srl_nokia-load-balancing"
}

// SrlNokiaSystem_System_LoadBalancing_HashOptions represents the /srl_nokia-system/system/load-balancing/hash-options YANG schema element.
type SrlNokiaSystem_System_LoadBalancing_HashOptions struct {
	DestinationAddress *bool   `path:"destination-address" module:"srl_nokia-load-balancing"`
	DestinationPort    *bool   `path:"destination-port" module:"srl_nokia-load-balancing"`
	HashSeed           *uint16 `path:"hash-seed" module:"srl_nokia-load-balancing"`
	Ipv6FlowLabel      *bool   `path:"ipv6-flow-label" module:"srl_nokia-load-balancing"`
	MplsLabelStack     *bool   `path:"mpls-label-stack" module:"srl_nokia-load-balancing"`
	Protocol           *bool   `path:"protocol" module:"srl_nokia-load-balancing"`
	SourceAddress      *bool   `path:"source-address" module:"srl_nokia-load-balancing"`
	SourcePort         *bool   `path:"source-port" module:"srl_nokia-load-balancing"`
	Vlan               *bool   `path:"vlan" module:"srl_nokia-load-balancing"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_LoadBalancing_HashOptions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_LoadBalancing_HashOptions) IsYANGGoStruct() {}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetDestinationAddress() bool {
	if t == nil || t.DestinationAddress == nil {
		return true
	}
	return *t.DestinationAddress
}

// GetDestinationPort retrieves the value of the leaf DestinationPort from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationPort is set, it can
// safely use t.GetDestinationPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationPort == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetDestinationPort() bool {
	if t == nil || t.DestinationPort == nil {
		return true
	}
	return *t.DestinationPort
}

// GetHashSeed retrieves the value of the leaf HashSeed from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HashSeed is set, it can
// safely use t.GetHashSeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HashSeed == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetHashSeed() uint16 {
	if t == nil || t.HashSeed == nil {
		return 0
	}
	return *t.HashSeed
}

// GetIpv6FlowLabel retrieves the value of the leaf Ipv6FlowLabel from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6FlowLabel is set, it can
// safely use t.GetIpv6FlowLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6FlowLabel == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetIpv6FlowLabel() bool {
	if t == nil || t.Ipv6FlowLabel == nil {
		return false
	}
	return *t.Ipv6FlowLabel
}

// GetMplsLabelStack retrieves the value of the leaf MplsLabelStack from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MplsLabelStack is set, it can
// safely use t.GetMplsLabelStack() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MplsLabelStack == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetMplsLabelStack() bool {
	if t == nil || t.MplsLabelStack == nil {
		return false
	}
	return *t.MplsLabelStack
}

// GetProtocol retrieves the value of the leaf Protocol from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetProtocol() bool {
	if t == nil || t.Protocol == nil {
		return true
	}
	return *t.Protocol
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetSourceAddress() bool {
	if t == nil || t.SourceAddress == nil {
		return true
	}
	return *t.SourceAddress
}

// GetSourcePort retrieves the value of the leaf SourcePort from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourcePort is set, it can
// safely use t.GetSourcePort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourcePort == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetSourcePort() bool {
	if t == nil || t.SourcePort == nil {
		return true
	}
	return *t.SourcePort
}

// GetVlan retrieves the value of the leaf Vlan from the SrlNokiaSystem_System_LoadBalancing_HashOptions
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) GetVlan() bool {
	if t == nil || t.Vlan == nil {
		return true
	}
	return *t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_LoadBalancing_HashOptions
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DestinationAddress == nil {
		var v bool = true
		t.DestinationAddress = &v
	}
	if t.DestinationPort == nil {
		var v bool = true
		t.DestinationPort = &v
	}
	if t.HashSeed == nil {
		var v uint16 = 0
		t.HashSeed = &v
	}
	if t.Ipv6FlowLabel == nil {
		var v bool = false
		t.Ipv6FlowLabel = &v
	}
	if t.MplsLabelStack == nil {
		var v bool = false
		t.MplsLabelStack = &v
	}
	if t.Protocol == nil {
		var v bool = true
		t.Protocol = &v
	}
	if t.SourceAddress == nil {
		var v bool = true
		t.SourceAddress = &v
	}
	if t.SourcePort == nil {
		var v bool = true
		t.SourcePort = &v
	}
	if t.Vlan == nil {
		var v bool = true
		t.Vlan = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_LoadBalancing_HashOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_LoadBalancing_HashOptions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_LoadBalancing_HashOptions.
func (*SrlNokiaSystem_System_LoadBalancing_HashOptions) ΛBelongingModule() string {
	return "srl_nokia-load-balancing"
}

// SrlNokiaSystem_System_Logging represents the /srl_nokia-system/system/logging YANG schema element.
type SrlNokiaSystem_System_Logging struct {
	Buffer            map[string]*SrlNokiaSystem_System_Logging_Buffer       `path:"buffer" module:"srl_nokia-logging"`
	Console           *SrlNokiaSystem_System_Logging_Console                 `path:"console" module:"srl_nokia-logging"`
	File              map[string]*SrlNokiaSystem_System_Logging_File         `path:"file" module:"srl_nokia-logging"`
	Filter            map[string]*SrlNokiaSystem_System_Logging_Filter       `path:"filter" module:"srl_nokia-logging"`
	NetworkInstance   *string                                                `path:"network-instance" module:"srl_nokia-logging"`
	RemoteServer      map[string]*SrlNokiaSystem_System_Logging_RemoteServer `path:"remote-server" module:"srl_nokia-logging"`
	SubsystemFacility E_SrlNokiaLogging_FacilityNameType                     `path:"subsystem-facility" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging) IsYANGGoStruct() {}

// NewBuffer creates a new entry in the Buffer list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewBuffer(BufferName string) (*SrlNokiaSystem_System_Logging_Buffer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Buffer == nil {
		t.Buffer = make(map[string]*SrlNokiaSystem_System_Logging_Buffer)
	}

	key := BufferName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Buffer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Buffer", key)
	}

	t.Buffer[key] = &SrlNokiaSystem_System_Logging_Buffer{
		BufferName: &BufferName,
	}

	return t.Buffer[key], nil
}

// RenameBuffer renames an entry in the list Buffer within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameBuffer(oldK, newK string) error {
	if _, ok := t.Buffer[newK]; ok {
		return fmt.Errorf("key %v already exists in Buffer", newK)
	}

	e, ok := t.Buffer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Buffer", oldK)
	}
	e.BufferName = &newK

	t.Buffer[newK] = e
	delete(t.Buffer, oldK)
	return nil
}

// GetOrCreateBuffer retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateBuffer(BufferName string) *SrlNokiaSystem_System_Logging_Buffer {
	key := BufferName

	if v, ok := t.Buffer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBuffer(BufferName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBuffer got unexpected error: %v", err))
	}
	return v
}

// GetBuffer retrieves the value with the specified key from
// the Buffer map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetBuffer(BufferName string) *SrlNokiaSystem_System_Logging_Buffer {
	if t == nil {
		return nil
	}

	key := BufferName

	if lm, ok := t.Buffer[key]; ok {
		return lm
	}
	return nil
}

// DeleteBuffer deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteBuffer(BufferName string) {
	key := BufferName

	delete(t.Buffer, key)
}

// AppendBuffer appends the supplied SrlNokiaSystem_System_Logging_Buffer struct to the
// list Buffer of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Buffer already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendBuffer(v *SrlNokiaSystem_System_Logging_Buffer) error {
	if v.BufferName == nil {
		return fmt.Errorf("invalid nil key received for BufferName")
	}

	key := *v.BufferName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Buffer == nil {
		t.Buffer = make(map[string]*SrlNokiaSystem_System_Logging_Buffer)
	}

	if _, ok := t.Buffer[key]; ok {
		return fmt.Errorf("duplicate key for list Buffer %v", key)
	}

	t.Buffer[key] = v
	return nil
}

// NewFile creates a new entry in the File list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewFile(FileName string) (*SrlNokiaSystem_System_Logging_File, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.File == nil {
		t.File = make(map[string]*SrlNokiaSystem_System_Logging_File)
	}

	key := FileName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.File[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list File", key)
	}

	t.File[key] = &SrlNokiaSystem_System_Logging_File{
		FileName: &FileName,
	}

	return t.File[key], nil
}

// RenameFile renames an entry in the list File within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameFile(oldK, newK string) error {
	if _, ok := t.File[newK]; ok {
		return fmt.Errorf("key %v already exists in File", newK)
	}

	e, ok := t.File[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in File", oldK)
	}
	e.FileName = &newK

	t.File[newK] = e
	delete(t.File, oldK)
	return nil
}

// GetOrCreateFile retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateFile(FileName string) *SrlNokiaSystem_System_Logging_File {
	key := FileName

	if v, ok := t.File[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFile(FileName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFile got unexpected error: %v", err))
	}
	return v
}

// GetFile retrieves the value with the specified key from
// the File map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetFile(FileName string) *SrlNokiaSystem_System_Logging_File {
	if t == nil {
		return nil
	}

	key := FileName

	if lm, ok := t.File[key]; ok {
		return lm
	}
	return nil
}

// DeleteFile deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteFile(FileName string) {
	key := FileName

	delete(t.File, key)
}

// AppendFile appends the supplied SrlNokiaSystem_System_Logging_File struct to the
// list File of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_File already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendFile(v *SrlNokiaSystem_System_Logging_File) error {
	if v.FileName == nil {
		return fmt.Errorf("invalid nil key received for FileName")
	}

	key := *v.FileName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.File == nil {
		t.File = make(map[string]*SrlNokiaSystem_System_Logging_File)
	}

	if _, ok := t.File[key]; ok {
		return fmt.Errorf("duplicate key for list File %v", key)
	}

	t.File[key] = v
	return nil
}

// NewFilter creates a new entry in the Filter list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewFilter(FilterName string) (*SrlNokiaSystem_System_Logging_Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[string]*SrlNokiaSystem_System_Logging_Filter)
	}

	key := FilterName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Filter", key)
	}

	t.Filter[key] = &SrlNokiaSystem_System_Logging_Filter{
		FilterName: &FilterName,
	}

	return t.Filter[key], nil
}

// RenameFilter renames an entry in the list Filter within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameFilter(oldK, newK string) error {
	if _, ok := t.Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Filter", newK)
	}

	e, ok := t.Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Filter", oldK)
	}
	e.FilterName = &newK

	t.Filter[newK] = e
	delete(t.Filter, oldK)
	return nil
}

// GetOrCreateFilter retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateFilter(FilterName string) *SrlNokiaSystem_System_Logging_Filter {
	key := FilterName

	if v, ok := t.Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFilter(FilterName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFilter got unexpected error: %v", err))
	}
	return v
}

// GetFilter retrieves the value with the specified key from
// the Filter map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetFilter(FilterName string) *SrlNokiaSystem_System_Logging_Filter {
	if t == nil {
		return nil
	}

	key := FilterName

	if lm, ok := t.Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteFilter deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteFilter(FilterName string) {
	key := FilterName

	delete(t.Filter, key)
}

// AppendFilter appends the supplied SrlNokiaSystem_System_Logging_Filter struct to the
// list Filter of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendFilter(v *SrlNokiaSystem_System_Logging_Filter) error {
	if v.FilterName == nil {
		return fmt.Errorf("invalid nil key received for FilterName")
	}

	key := *v.FilterName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[string]*SrlNokiaSystem_System_Logging_Filter)
	}

	if _, ok := t.Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Filter %v", key)
	}

	t.Filter[key] = v
	return nil
}

// NewRemoteServer creates a new entry in the RemoteServer list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewRemoteServer(Host string) (*SrlNokiaSystem_System_Logging_RemoteServer, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*SrlNokiaSystem_System_Logging_RemoteServer)
	}

	key := Host

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RemoteServer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RemoteServer", key)
	}

	t.RemoteServer[key] = &SrlNokiaSystem_System_Logging_RemoteServer{
		Host: &Host,
	}

	return t.RemoteServer[key], nil
}

// RenameRemoteServer renames an entry in the list RemoteServer within
// the SrlNokiaSystem_System_Logging struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging) RenameRemoteServer(oldK, newK string) error {
	if _, ok := t.RemoteServer[newK]; ok {
		return fmt.Errorf("key %v already exists in RemoteServer", newK)
	}

	e, ok := t.RemoteServer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RemoteServer", oldK)
	}
	e.Host = &newK

	t.RemoteServer[newK] = e
	delete(t.RemoteServer, oldK)
	return nil
}

// GetOrCreateRemoteServer retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateRemoteServer(Host string) *SrlNokiaSystem_System_Logging_RemoteServer {
	key := Host

	if v, ok := t.RemoteServer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRemoteServer(Host)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRemoteServer got unexpected error: %v", err))
	}
	return v
}

// GetRemoteServer retrieves the value with the specified key from
// the RemoteServer map field of SrlNokiaSystem_System_Logging. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetRemoteServer(Host string) *SrlNokiaSystem_System_Logging_RemoteServer {
	if t == nil {
		return nil
	}

	key := Host

	if lm, ok := t.RemoteServer[key]; ok {
		return lm
	}
	return nil
}

// DeleteRemoteServer deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging) DeleteRemoteServer(Host string) {
	key := Host

	delete(t.RemoteServer, key)
}

// AppendRemoteServer appends the supplied SrlNokiaSystem_System_Logging_RemoteServer struct to the
// list RemoteServer of SrlNokiaSystem_System_Logging. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_RemoteServer already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging) AppendRemoteServer(v *SrlNokiaSystem_System_Logging_RemoteServer) error {
	if v.Host == nil {
		return fmt.Errorf("invalid nil key received for Host")
	}

	key := *v.Host

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*SrlNokiaSystem_System_Logging_RemoteServer)
	}

	if _, ok := t.RemoteServer[key]; ok {
		return fmt.Errorf("duplicate key for list RemoteServer %v", key)
	}

	t.RemoteServer[key] = v
	return nil
}

// GetOrCreateConsole retrieves the value of the Console field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging) GetOrCreateConsole() *SrlNokiaSystem_System_Logging_Console {
	if t.Console != nil {
		return t.Console
	}
	t.Console = &SrlNokiaSystem_System_Logging_Console{}
	return t.Console
}

// GetConsole returns the value of the Console struct pointer
// from SrlNokiaSystem_System_Logging. If the receiver or the field Console is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging) GetConsole() *SrlNokiaSystem_System_Logging_Console {
	if t != nil && t.Console != nil {
		return t.Console
	}
	return nil
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Logging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetSubsystemFacility retrieves the value of the leaf SubsystemFacility from the SrlNokiaSystem_System_Logging
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemFacility is set, it can
// safely use t.GetSubsystemFacility() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemFacility == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging) GetSubsystemFacility() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.SubsystemFacility == 0 {
		return SrlNokiaLogging_FacilityNameType_local6
	}
	return t.SubsystemFacility
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SubsystemFacility == 0 {
		t.SubsystemFacility = SrlNokiaLogging_FacilityNameType_local6
	}
	t.Console.PopulateDefaults()
	for _, e := range t.Buffer {
		e.PopulateDefaults()
	}
	for _, e := range t.File {
		e.PopulateDefaults()
	}
	for _, e := range t.Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.RemoteServer {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging.
func (*SrlNokiaSystem_System_Logging) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer represents the /srl_nokia-system/system/logging/buffer YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer struct {
	BufferName *string                                                                                 `path:"buffer-name" module:"srl_nokia-logging"`
	Facility   map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Buffer_Facility   `path:"facility" module:"srl_nokia-logging"`
	Filter     []string                                                                                `path:"filter" module:"srl_nokia-logging"`
	Format     *string                                                                                 `path:"format" module:"srl_nokia-logging"`
	Persist    *uint32                                                                                 `path:"persist" module:"srl_nokia-logging"`
	Rotate     *uint16                                                                                 `path:"rotate" module:"srl_nokia-logging"`
	Size       *string                                                                                 `path:"size" module:"srl_nokia-logging"`
	Subsystem  map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Buffer_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Buffer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Buffer) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_Buffer_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Buffer_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Buffer_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_Buffer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Buffer) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Buffer_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_Buffer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) *SrlNokiaSystem_System_Logging_Buffer_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Buffer) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_Buffer_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_Buffer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Buffer_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Buffer) AppendFacility(v *SrlNokiaSystem_System_Logging_Buffer_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Buffer_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_Buffer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Buffer) NewSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) (*SrlNokiaSystem_System_Logging_Buffer_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Buffer_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_Buffer_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_Buffer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Buffer) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Buffer_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_Buffer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Buffer_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Buffer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Buffer) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_Buffer_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_Buffer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Buffer_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Buffer) AppendSubsystem(v *SrlNokiaSystem_System_Logging_Buffer_Subsystem) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Buffer_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetBufferName retrieves the value of the leaf BufferName from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BufferName is set, it can
// safely use t.GetBufferName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BufferName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetBufferName() string {
	if t == nil || t.BufferName == nil {
		return ""
	}
	return *t.BufferName
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetFormat() string {
	if t == nil || t.Format == nil {
		return "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
	}
	return *t.Format
}

// GetPersist retrieves the value of the leaf Persist from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Persist is set, it can
// safely use t.GetPersist() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Persist == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetPersist() uint32 {
	if t == nil || t.Persist == nil {
		return 0
	}
	return *t.Persist
}

// GetRotate retrieves the value of the leaf Rotate from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rotate is set, it can
// safely use t.GetRotate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rotate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetRotate() uint16 {
	if t == nil || t.Rotate == nil {
		return 4
	}
	return *t.Rotate
}

// GetSize retrieves the value of the leaf Size from the SrlNokiaSystem_System_Logging_Buffer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Size is set, it can
// safely use t.GetSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Size == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer) GetSize() string {
	if t == nil || t.Size == nil {
		return "10M"
	}
	return *t.Size
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Format == nil {
		var v string = "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
		t.Format = &v
	}
	if t.Persist == nil {
		var v uint32 = 0
		t.Persist = &v
	}
	if t.Rotate == nil {
		var v uint16 = 4
		t.Rotate = &v
	}
	if t.Size == nil {
		var v string = "10M"
		t.Size = &v
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BufferName == nil {
		return nil, fmt.Errorf("nil value for key BufferName")
	}

	return map[string]interface{}{
		"buffer-name": *t.BufferName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer.
func (*SrlNokiaSystem_System_Logging_Buffer) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Facility represents the /srl_nokia-system/system/logging/buffer/facility YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                      `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Buffer_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Buffer_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) GetPriority() *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_Buffer_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Facility.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Facility_Priority represents the /srl_nokia-system/system/logging/buffer/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Buffer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Buffer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Subsystem represents the /srl_nokia-system/system/logging/buffer/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                      `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Buffer_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_Buffer_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Subsystem.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority represents the /srl_nokia-system/system/logging/buffer/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console represents the /srl_nokia-system/system/logging/console YANG schema element.
type SrlNokiaSystem_System_Logging_Console struct {
	Facility  map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Console_Facility   `path:"facility" module:"srl_nokia-logging"`
	Filter    []string                                                                                 `path:"filter" module:"srl_nokia-logging"`
	Format    *string                                                                                  `path:"format" module:"srl_nokia-logging"`
	Subsystem map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Console_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Console) NewFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) (*SrlNokiaSystem_System_Logging_Console_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Console_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Console_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_Console struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Console) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Console) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Console_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_Console. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console) GetFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Console_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Console) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_Console_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_Console. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Console_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Console) AppendFacility(v *SrlNokiaSystem_System_Logging_Console_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Console_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Console) NewSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) (*SrlNokiaSystem_System_Logging_Console_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Console_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_Console_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_Console struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Console) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Console) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Console_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_Console. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console) GetSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_Console_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Console. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Console) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_Console_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_Console. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Console_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Console) AppendSubsystem(v *SrlNokiaSystem_System_Logging_Console_Subsystem) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Console_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_Console
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaSystem_System_Logging_Console
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console) GetFormat() string {
	if t == nil || t.Format == nil {
		return "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
	}
	return *t.Format
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Format == nil {
		var v string = "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
		t.Format = &v
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console.
func (*SrlNokiaSystem_System_Logging_Console) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Facility represents the /srl_nokia-system/system/logging/console/facility YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                       `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_Console_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Console_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Console_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Console_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) GetPriority() *SrlNokiaSystem_System_Logging_Console_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_Console_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Console_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Facility.
func (*SrlNokiaSystem_System_Logging_Console_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Facility_Priority represents the /srl_nokia-system/system/logging/console/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Console_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Console_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_Console_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Subsystem represents the /srl_nokia-system/system/logging/console/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                       `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Console_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Console_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_Console_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Console_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Subsystem.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Console_Subsystem_Priority represents the /srl_nokia-system/system/logging/console/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Console_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Console_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Console_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Console_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Console_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Console_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File represents the /srl_nokia-system/system/logging/file YANG schema element.
type SrlNokiaSystem_System_Logging_File struct {
	Directory *string                                                                               `path:"directory" module:"srl_nokia-logging"`
	Facility  map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_File_Facility   `path:"facility" module:"srl_nokia-logging"`
	FileName  *string                                                                               `path:"file-name" module:"srl_nokia-logging"`
	Filter    []string                                                                              `path:"filter" module:"srl_nokia-logging"`
	Format    *string                                                                               `path:"format" module:"srl_nokia-logging"`
	Rotate    *uint16                                                                               `path:"rotate" module:"srl_nokia-logging"`
	Size      *string                                                                               `path:"size" module:"srl_nokia-logging"`
	Subsystem map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_File_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_File struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_File) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_File_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_File_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_File_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_File struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_File) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_File) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_File_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_File. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_File) GetFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) *SrlNokiaSystem_System_Logging_File_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_File) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_File_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_File. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_File_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_File) AppendFacility(v *SrlNokiaSystem_System_Logging_File_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_File_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_File struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_File) NewSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) (*SrlNokiaSystem_System_Logging_File_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_File_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_File_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_File struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_File) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_File) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_File_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_File. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_File) GetSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) *SrlNokiaSystem_System_Logging_File_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_File. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_File) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_File_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_File. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_File_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_File) AppendSubsystem(v *SrlNokiaSystem_System_Logging_File_Subsystem) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_File_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetDirectory retrieves the value of the leaf Directory from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Directory is set, it can
// safely use t.GetDirectory() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Directory == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetDirectory() string {
	if t == nil || t.Directory == nil {
		return "/var/log/srlinux/file"
	}
	return *t.Directory
}

// GetFileName retrieves the value of the leaf FileName from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FileName is set, it can
// safely use t.GetFileName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FileName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetFileName() string {
	if t == nil || t.FileName == nil {
		return ""
	}
	return *t.FileName
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetFormat retrieves the value of the leaf Format from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Format is set, it can
// safely use t.GetFormat() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Format == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetFormat() string {
	if t == nil || t.Format == nil {
		return "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
	}
	return *t.Format
}

// GetRotate retrieves the value of the leaf Rotate from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rotate is set, it can
// safely use t.GetRotate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rotate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetRotate() uint16 {
	if t == nil || t.Rotate == nil {
		return 4
	}
	return *t.Rotate
}

// GetSize retrieves the value of the leaf Size from the SrlNokiaSystem_System_Logging_File
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Size is set, it can
// safely use t.GetSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Size == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File) GetSize() string {
	if t == nil || t.Size == nil {
		return "10M"
	}
	return *t.Size
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Directory == nil {
		var v string = "/var/log/srlinux/file"
		t.Directory = &v
	}
	if t.Format == nil {
		var v string = "%TIMEGENERATED:::date-rfc3339% %HOSTNAME% %SYSLOGTAG%%MSG:::sp-if-no-1st-sp%%MSG:::drop-last-lf%\\n"
		t.Format = &v
	}
	if t.Rotate == nil {
		var v uint16 = 4
		t.Rotate = &v
	}
	if t.Size == nil {
		var v string = "10M"
		t.Size = &v
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FileName == nil {
		return nil, fmt.Errorf("nil value for key FileName")
	}

	return map[string]interface{}{
		"file-name": *t.FileName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File.
func (*SrlNokiaSystem_System_Logging_File) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Facility represents the /srl_nokia-system/system/logging/file/facility YANG schema element.
type SrlNokiaSystem_System_Logging_File_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                    `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_File_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_File_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_File_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_File_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_File_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_File_Facility) GetPriority() *SrlNokiaSystem_System_Logging_File_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_File_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Facility.
func (*SrlNokiaSystem_System_Logging_File_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Facility_Priority represents the /srl_nokia-system/system/logging/file/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_File_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_File_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_File_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_File_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Subsystem represents the /srl_nokia-system/system/logging/file/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_File_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_File_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                    `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_File_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_File_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_File_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_File_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_File_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Subsystem.
func (*SrlNokiaSystem_System_Logging_File_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_File_Subsystem_Priority represents the /srl_nokia-system/system/logging/file/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_File_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_File_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_File_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_File_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_File_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_File_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_File_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_File_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Filter represents the /srl_nokia-system/system/logging/filter YANG schema element.
type SrlNokiaSystem_System_Logging_Filter struct {
	Contains   *string                                                                               `path:"contains" module:"srl_nokia-logging"`
	Facility   map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Filter_Facility `path:"facility" module:"srl_nokia-logging"`
	FilterName *string                                                                               `path:"filter-name" module:"srl_nokia-logging"`
	Prefix     *string                                                                               `path:"prefix" module:"srl_nokia-logging"`
	Regex      *string                                                                               `path:"regex" module:"srl_nokia-logging"`
	Tag        *string                                                                               `path:"tag" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Filter) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Filter) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_Filter_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Filter_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Filter_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_Filter) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_Filter) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_Filter_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_Filter) GetFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) *SrlNokiaSystem_System_Logging_Filter_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_Filter) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_Filter_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_Filter. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_Filter_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_Filter) AppendFacility(v *SrlNokiaSystem_System_Logging_Filter_Facility) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Filter_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// GetContains retrieves the value of the leaf Contains from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Contains is set, it can
// safely use t.GetContains() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Contains == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetContains() string {
	if t == nil || t.Contains == nil {
		return ""
	}
	return *t.Contains
}

// GetFilterName retrieves the value of the leaf FilterName from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FilterName is set, it can
// safely use t.GetFilterName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FilterName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetFilterName() string {
	if t == nil || t.FilterName == nil {
		return ""
	}
	return *t.FilterName
}

// GetPrefix retrieves the value of the leaf Prefix from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetRegex retrieves the value of the leaf Regex from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Regex is set, it can
// safely use t.GetRegex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Regex == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetRegex() string {
	if t == nil || t.Regex == nil {
		return ""
	}
	return *t.Regex
}

// GetTag retrieves the value of the leaf Tag from the SrlNokiaSystem_System_Logging_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag is set, it can
// safely use t.GetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter) GetTag() string {
	if t == nil || t.Tag == nil {
		return ""
	}
	return *t.Tag
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Filter struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FilterName == nil {
		return nil, fmt.Errorf("nil value for key FilterName")
	}

	return map[string]interface{}{
		"filter-name": *t.FilterName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Filter.
func (*SrlNokiaSystem_System_Logging_Filter) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Filter_Facility represents the /srl_nokia-system/system/logging/filter/facility YANG schema element.
type SrlNokiaSystem_System_Logging_Filter_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                      `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_Filter_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Filter_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Filter_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_Filter_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_Filter_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_Filter_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) GetPriority() *SrlNokiaSystem_System_Logging_Filter_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_Filter_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Filter_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Filter_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Filter_Facility.
func (*SrlNokiaSystem_System_Logging_Filter_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_Filter_Facility_Priority represents the /srl_nokia-system/system/logging/filter/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_Filter_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_Filter_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_Filter_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_Filter_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_Filter_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_Filter_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_Filter_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_Filter_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer represents the /srl_nokia-system/system/logging/remote-server YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer struct {
	Facility   map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Facility   `path:"facility" module:"srl_nokia-logging"`
	Filter     []string                                                                                      `path:"filter" module:"srl_nokia-logging"`
	Host       *string                                                                                       `path:"host" module:"srl_nokia-logging"`
	RemotePort *uint32                                                                                       `path:"remote-port" module:"srl_nokia-logging"`
	Subsystem  map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem `path:"subsystem" module:"srl_nokia-logging"`
	Transport  E_SrlNokiaLogging_TransportType                                                               `path:"transport" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer) IsYANGGoStruct() {}

// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) NewFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) (*SrlNokiaSystem_System_Logging_RemoteServer_Facility, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_RemoteServer_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// RenameFacility renames an entry in the list Facility within
// the SrlNokiaSystem_System_Logging_RemoteServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) RenameFacility(oldK, newK E_SrlNokiaLogging_FacilityNameType) error {
	if _, ok := t.Facility[newK]; ok {
		return fmt.Errorf("key %v already exists in Facility", newK)
	}

	e, ok := t.Facility[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Facility", oldK)
	}
	e.FacilityName = newK

	t.Facility[newK] = e
	delete(t.Facility, oldK)
	return nil
}

// GetOrCreateFacility retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetOrCreateFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Facility {
	key := FacilityName

	if v, ok := t.Facility[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFacility(FacilityName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFacility got unexpected error: %v", err))
	}
	return v
}

// GetFacility retrieves the value with the specified key from
// the Facility map field of SrlNokiaSystem_System_Logging_RemoteServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetFacility(
	FacilityName E_SrlNokiaLogging_FacilityNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Facility {
	if t == nil {
		return nil
	}

	key := FacilityName

	if lm, ok := t.Facility[key]; ok {
		return lm
	}
	return nil
}

// DeleteFacility deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) DeleteFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) {
	key := FacilityName

	delete(t.Facility, key)
}

// AppendFacility appends the supplied SrlNokiaSystem_System_Logging_RemoteServer_Facility struct to the
// list Facility of SrlNokiaSystem_System_Logging_RemoteServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_RemoteServer_Facility already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) AppendFacility(
	v *SrlNokiaSystem_System_Logging_RemoteServer_Facility,
) error {
	key := v.FacilityName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Facility)
	}

	if _, ok := t.Facility[key]; ok {
		return fmt.Errorf("duplicate key for list Facility %v", key)
	}

	t.Facility[key] = v
	return nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) NewSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_RemoteServer_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// RenameSubsystem renames an entry in the list Subsystem within
// the SrlNokiaSystem_System_Logging_RemoteServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) RenameSubsystem(oldK, newK E_SrlNokiaLogging_SubsystemNameType) error {
	if _, ok := t.Subsystem[newK]; ok {
		return fmt.Errorf("key %v already exists in Subsystem", newK)
	}

	e, ok := t.Subsystem[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subsystem", oldK)
	}
	e.SubsystemName = newK

	t.Subsystem[newK] = e
	delete(t.Subsystem, oldK)
	return nil
}

// GetOrCreateSubsystem retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetOrCreateSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem {
	key := SubsystemName

	if v, ok := t.Subsystem[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubsystem(SubsystemName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubsystem got unexpected error: %v", err))
	}
	return v
}

// GetSubsystem retrieves the value with the specified key from
// the Subsystem map field of SrlNokiaSystem_System_Logging_RemoteServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetSubsystem(
	SubsystemName E_SrlNokiaLogging_SubsystemNameType,
) *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem {
	if t == nil {
		return nil
	}

	key := SubsystemName

	if lm, ok := t.Subsystem[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubsystem deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Logging_RemoteServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) DeleteSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) {
	key := SubsystemName

	delete(t.Subsystem, key)
}

// AppendSubsystem appends the supplied SrlNokiaSystem_System_Logging_RemoteServer_Subsystem struct to the
// list Subsystem of SrlNokiaSystem_System_Logging_RemoteServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Logging_RemoteServer_Subsystem already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) AppendSubsystem(
	v *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem,
) error {
	key := v.SubsystemName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem)
	}

	if _, ok := t.Subsystem[key]; ok {
		return fmt.Errorf("duplicate key for list Subsystem %v", key)
	}

	t.Subsystem[key] = v
	return nil
}

// GetFilter retrieves the value of the leaf Filter from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetFilter() []string {
	if t == nil || t.Filter == nil {
		return nil
	}
	return t.Filter
}

// GetHost retrieves the value of the leaf Host from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Host is set, it can
// safely use t.GetHost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Host == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetHost() string {
	if t == nil || t.Host == nil {
		return ""
	}
	return *t.Host
}

// GetRemotePort retrieves the value of the leaf RemotePort from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemotePort is set, it can
// safely use t.GetRemotePort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemotePort == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetRemotePort() uint32 {
	if t == nil || t.RemotePort == nil {
		return 514
	}
	return *t.RemotePort
}

// GetTransport retrieves the value of the leaf Transport from the SrlNokiaSystem_System_Logging_RemoteServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Transport is set, it can
// safely use t.GetTransport() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Transport == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) GetTransport() E_SrlNokiaLogging_TransportType {
	if t == nil || t.Transport == 0 {
		return SrlNokiaLogging_TransportType_udp
	}
	return t.Transport
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RemotePort == nil {
		var v uint32 = 514
		t.RemotePort = &v
	}
	if t.Transport == 0 {
		t.Transport = SrlNokiaLogging_TransportType_udp
	}
	for _, e := range t.Facility {
		e.PopulateDefaults()
	}
	for _, e := range t.Subsystem {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Host == nil {
		return nil, fmt.Errorf("nil value for key Host")
	}

	return map[string]interface{}{
		"host": *t.Host,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer.
func (*SrlNokiaSystem_System_Logging_RemoteServer) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Facility represents the /srl_nokia-system/system/logging/remote-server/facility YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Facility struct {
	FacilityName E_SrlNokiaLogging_FacilityNameType                            `path:"facility-name" module:"srl_nokia-logging"`
	Priority     *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority `path:"priority" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Facility implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_RemoteServer_Facility. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) GetPriority() *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetFacilityName retrieves the value of the leaf FacilityName from the SrlNokiaSystem_System_Logging_RemoteServer_Facility
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityName is set, it can
// safely use t.GetFacilityName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) GetFacilityName() E_SrlNokiaLogging_FacilityNameType {
	if t == nil || t.FacilityName == 0 {
		return 0
	}
	return t.FacilityName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Facility
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Facility.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority represents the /srl_nokia-system/system/logging/remote-server/facility/priority YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Subsystem represents the /srl_nokia-system/system/logging/remote-server/subsystem YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Subsystem struct {
	Priority      *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority `path:"priority" module:"srl_nokia-logging"`
	SubsystemName E_SrlNokiaLogging_SubsystemNameType                            `path:"subsystem-name" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Subsystem implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) IsYANGGoStruct() {}

// GetOrCreatePriority retrieves the value of the Priority field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) GetOrCreatePriority() *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority {
	if t.Priority != nil {
		return t.Priority
	}
	t.Priority = &SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority{}
	return t.Priority
}

// GetPriority returns the value of the Priority struct pointer
// from SrlNokiaSystem_System_Logging_RemoteServer_Subsystem. If the receiver or the field Priority is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) GetPriority() *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority {
	if t != nil && t.Priority != nil {
		return t.Priority
	}
	return nil
}

// GetSubsystemName retrieves the value of the leaf SubsystemName from the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubsystemName is set, it can
// safely use t.GetSubsystemName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubsystemName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) GetSubsystemName() E_SrlNokiaLogging_SubsystemNameType {
	if t == nil || t.SubsystemName == 0 {
		return 0
	}
	return t.SubsystemName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Priority.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Subsystem.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority represents the /srl_nokia-system/system/logging/remote-server/subsystem/priority YANG schema element.
type SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority struct {
	MatchAbove E_SrlNokiaLogging_PriorityType   `path:"match-above" module:"srl_nokia-logging"`
	MatchExact []E_SrlNokiaLogging_PriorityType `path:"match-exact" module:"srl_nokia-logging"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) IsYANGGoStruct() {}

// GetMatchAbove retrieves the value of the leaf MatchAbove from the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchAbove is set, it can
// safely use t.GetMatchAbove() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchAbove == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) GetMatchAbove() E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchAbove == 0 {
		return 0
	}
	return t.MatchAbove
}

// GetMatchExact retrieves the value of the leaf MatchExact from the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchExact is set, it can
// safely use t.GetMatchExact() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchExact == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) GetMatchExact() []E_SrlNokiaLogging_PriorityType {
	if t == nil || t.MatchExact == nil {
		return nil
	}
	return t.MatchExact
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority.
func (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) ΛBelongingModule() string {
	return "srl_nokia-logging"
}

// SrlNokiaSystem_System_Maintenance represents the /srl_nokia-system/system/maintenance YANG schema element.
type SrlNokiaSystem_System_Maintenance struct {
	Group   map[string]*SrlNokiaSystem_System_Maintenance_Group   `path:"group" module:"srl_nokia-maintenance-mode"`
	Profile map[string]*SrlNokiaSystem_System_Maintenance_Profile `path:"profile" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance) IsYANGGoStruct() {}

// NewGroup creates a new entry in the Group list of the
// SrlNokiaSystem_System_Maintenance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance) NewGroup(Name string) (*SrlNokiaSystem_System_Maintenance_Group, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaSystem_System_Maintenance_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaSystem_System_Maintenance_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the SrlNokiaSystem_System_Maintenance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Maintenance) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Maintenance) GetOrCreateGroup(Name string) *SrlNokiaSystem_System_Maintenance_Group {
	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of SrlNokiaSystem_System_Maintenance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Maintenance) GetGroup(Name string) *SrlNokiaSystem_System_Maintenance_Group {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Maintenance) DeleteGroup(Name string) {
	key := Name

	delete(t.Group, key)
}

// AppendGroup appends the supplied SrlNokiaSystem_System_Maintenance_Group struct to the
// list Group of SrlNokiaSystem_System_Maintenance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Maintenance_Group already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Maintenance) AppendGroup(v *SrlNokiaSystem_System_Maintenance_Group) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaSystem_System_Maintenance_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaSystem_System_Maintenance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance) NewProfile(Name string) (*SrlNokiaSystem_System_Maintenance_Profile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[string]*SrlNokiaSystem_System_Maintenance_Profile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaSystem_System_Maintenance_Profile{
		Name: &Name,
	}

	return t.Profile[key], nil
}

// RenameProfile renames an entry in the list Profile within
// the SrlNokiaSystem_System_Maintenance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Maintenance) RenameProfile(oldK, newK string) error {
	if _, ok := t.Profile[newK]; ok {
		return fmt.Errorf("key %v already exists in Profile", newK)
	}

	e, ok := t.Profile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Profile", oldK)
	}
	e.Name = &newK

	t.Profile[newK] = e
	delete(t.Profile, oldK)
	return nil
}

// GetOrCreateProfile retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Maintenance) GetOrCreateProfile(Name string) *SrlNokiaSystem_System_Maintenance_Profile {
	key := Name

	if v, ok := t.Profile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProfile got unexpected error: %v", err))
	}
	return v
}

// GetProfile retrieves the value with the specified key from
// the Profile map field of SrlNokiaSystem_System_Maintenance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Maintenance) GetProfile(Name string) *SrlNokiaSystem_System_Maintenance_Profile {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Profile[key]; ok {
		return lm
	}
	return nil
}

// DeleteProfile deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Maintenance) DeleteProfile(Name string) {
	key := Name

	delete(t.Profile, key)
}

// AppendProfile appends the supplied SrlNokiaSystem_System_Maintenance_Profile struct to the
// list Profile of SrlNokiaSystem_System_Maintenance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Maintenance_Profile already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Maintenance) AppendProfile(v *SrlNokiaSystem_System_Maintenance_Profile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[string]*SrlNokiaSystem_System_Maintenance_Profile)
	}

	if _, ok := t.Profile[key]; ok {
		return fmt.Errorf("duplicate key for list Profile %v", key)
	}

	t.Profile[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Group {
		e.PopulateDefaults()
	}
	for _, e := range t.Profile {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance.
func (*SrlNokiaSystem_System_Maintenance) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group represents the /srl_nokia-system/system/maintenance/group YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group struct {
	MaintenanceMode    *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode `path:"maintenance-mode" module:"srl_nokia-maintenance-mode"`
	MaintenanceProfile *string                                                  `path:"maintenance-profile" module:"srl_nokia-maintenance-mode"`
	Members            *SrlNokiaSystem_System_Maintenance_Group_Members         `path:"members" module:"srl_nokia-maintenance-mode"`
	Name               *string                                                  `path:"name" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group) IsYANGGoStruct() {}

// GetOrCreateMaintenanceMode retrieves the value of the MaintenanceMode field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetOrCreateMaintenanceMode() *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode {
	if t.MaintenanceMode != nil {
		return t.MaintenanceMode
	}
	t.MaintenanceMode = &SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode{}
	return t.MaintenanceMode
}

// GetOrCreateMembers retrieves the value of the Members field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetOrCreateMembers() *SrlNokiaSystem_System_Maintenance_Group_Members {
	if t.Members != nil {
		return t.Members
	}
	t.Members = &SrlNokiaSystem_System_Maintenance_Group_Members{}
	return t.Members
}

// GetMaintenanceMode returns the value of the MaintenanceMode struct pointer
// from SrlNokiaSystem_System_Maintenance_Group. If the receiver or the field MaintenanceMode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetMaintenanceMode() *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode {
	if t != nil && t.MaintenanceMode != nil {
		return t.MaintenanceMode
	}
	return nil
}

// GetMembers returns the value of the Members struct pointer
// from SrlNokiaSystem_System_Maintenance_Group. If the receiver or the field Members is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetMembers() *SrlNokiaSystem_System_Maintenance_Group_Members {
	if t != nil && t.Members != nil {
		return t.Members
	}
	return nil
}

// GetMaintenanceProfile retrieves the value of the leaf MaintenanceProfile from the SrlNokiaSystem_System_Maintenance_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaintenanceProfile is set, it can
// safely use t.GetMaintenanceProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaintenanceProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetMaintenanceProfile() string {
	if t == nil || t.MaintenanceProfile == nil {
		return ""
	}
	return *t.MaintenanceProfile
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Maintenance_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.MaintenanceMode.PopulateDefaults()
	t.Members.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Group struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group.
func (*SrlNokiaSystem_System_Maintenance_Group) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode represents the /srl_nokia-system/system/maintenance/group/maintenance-mode YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode.
func (*SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members represents the /srl_nokia-system/system/maintenance/group/members YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members struct {
	Bgp  *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp  `path:"bgp" module:"srl_nokia-maintenance-mode"`
	Isis *SrlNokiaSystem_System_Maintenance_Group_Members_Isis `path:"isis" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members) IsYANGGoStruct() {}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetOrCreateBgp() *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &SrlNokiaSystem_System_Maintenance_Group_Members_Bgp{}
	return t.Bgp
}

// GetOrCreateIsis retrieves the value of the Isis field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetOrCreateIsis() *SrlNokiaSystem_System_Maintenance_Group_Members_Isis {
	if t.Isis != nil {
		return t.Isis
	}
	t.Isis = &SrlNokiaSystem_System_Maintenance_Group_Members_Isis{}
	return t.Isis
}

// GetBgp returns the value of the Bgp struct pointer
// from SrlNokiaSystem_System_Maintenance_Group_Members. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetBgp() *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetIsis returns the value of the Isis struct pointer
// from SrlNokiaSystem_System_Maintenance_Group_Members. If the receiver or the field Isis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) GetIsis() *SrlNokiaSystem_System_Maintenance_Group_Members_Isis {
	if t != nil && t.Isis != nil {
		return t.Isis
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
	t.Isis.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members.
func (*SrlNokiaSystem_System_Maintenance_Group_Members) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members_Bgp represents the /srl_nokia-system/system/maintenance/group/members/bgp YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members_Bgp struct {
	NetworkInstance map[string]*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance `path:"network-instance" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_Maintenance_Group_Members_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) GetOrCreateNetworkInstance(
	Name string,
) *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) GetNetworkInstance(Name string) *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) AppendNetworkInstance(
	v *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance represents the /srl_nokia-system/system/maintenance/group/members/bgp/network-instance YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance struct {
	Name      *string  `path:"name" module:"srl_nokia-maintenance-mode"`
	Neighbor  []string `path:"neighbor" module:"srl_nokia-maintenance-mode"`
	PeerGroup []string `path:"peer-group" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) IsYANGGoStruct() {}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetNeighbor retrieves the value of the leaf Neighbor from the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Neighbor is set, it can
// safely use t.GetNeighbor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Neighbor == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) GetNeighbor() []string {
	if t == nil || t.Neighbor == nil {
		return nil
	}
	return t.Neighbor
}

// GetPeerGroup retrieves the value of the leaf PeerGroup from the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerGroup is set, it can
// safely use t.GetPeerGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerGroup == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) GetPeerGroup() []string {
	if t == nil || t.PeerGroup == nil {
		return nil
	}
	return t.PeerGroup
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Group_Members_Isis represents the /srl_nokia-system/system/maintenance/group/members/isis YANG schema element.
type SrlNokiaSystem_System_Maintenance_Group_Members_Isis struct {
	NetworkInstances []string `path:"network-instances" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Group_Members_Isis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Isis) IsYANGGoStruct() {}

// GetNetworkInstances retrieves the value of the leaf NetworkInstances from the SrlNokiaSystem_System_Maintenance_Group_Members_Isis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstances is set, it can
// safely use t.GetNetworkInstances() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstances == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) GetNetworkInstances() []string {
	if t == nil || t.NetworkInstances == nil {
		return nil
	}
	return t.NetworkInstances
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Group_Members_Isis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Isis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Isis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Group_Members_Isis.
func (*SrlNokiaSystem_System_Maintenance_Group_Members_Isis) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Profile represents the /srl_nokia-system/system/maintenance/profile YANG schema element.
type SrlNokiaSystem_System_Maintenance_Profile struct {
	Bgp  *SrlNokiaSystem_System_Maintenance_Profile_Bgp  `path:"bgp" module:"srl_nokia-maintenance-mode"`
	Isis *SrlNokiaSystem_System_Maintenance_Profile_Isis `path:"isis" module:"srl_nokia-maintenance-mode"`
	Name *string                                         `path:"name" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Profile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Profile) IsYANGGoStruct() {}

// GetOrCreateBgp retrieves the value of the Bgp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Profile) GetOrCreateBgp() *SrlNokiaSystem_System_Maintenance_Profile_Bgp {
	if t.Bgp != nil {
		return t.Bgp
	}
	t.Bgp = &SrlNokiaSystem_System_Maintenance_Profile_Bgp{}
	return t.Bgp
}

// GetOrCreateIsis retrieves the value of the Isis field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Profile) GetOrCreateIsis() *SrlNokiaSystem_System_Maintenance_Profile_Isis {
	if t.Isis != nil {
		return t.Isis
	}
	t.Isis = &SrlNokiaSystem_System_Maintenance_Profile_Isis{}
	return t.Isis
}

// GetBgp returns the value of the Bgp struct pointer
// from SrlNokiaSystem_System_Maintenance_Profile. If the receiver or the field Bgp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Profile) GetBgp() *SrlNokiaSystem_System_Maintenance_Profile_Bgp {
	if t != nil && t.Bgp != nil {
		return t.Bgp
	}
	return nil
}

// GetIsis returns the value of the Isis struct pointer
// from SrlNokiaSystem_System_Maintenance_Profile. If the receiver or the field Isis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Profile) GetIsis() *SrlNokiaSystem_System_Maintenance_Profile_Isis {
	if t != nil && t.Isis != nil {
		return t.Isis
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Maintenance_Profile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Profile) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Profile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Profile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bgp.PopulateDefaults()
	t.Isis.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Profile struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Profile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Profile.
func (*SrlNokiaSystem_System_Maintenance_Profile) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Profile_Bgp represents the /srl_nokia-system/system/maintenance/profile/bgp YANG schema element.
type SrlNokiaSystem_System_Maintenance_Profile_Bgp struct {
	ExportPolicy *string `path:"export-policy" module:"srl_nokia-maintenance-mode"`
	ImportPolicy *string `path:"import-policy" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Profile_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Profile_Bgp) IsYANGGoStruct() {}

// GetExportPolicy retrieves the value of the leaf ExportPolicy from the SrlNokiaSystem_System_Maintenance_Profile_Bgp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExportPolicy is set, it can
// safely use t.GetExportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExportPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) GetExportPolicy() string {
	if t == nil || t.ExportPolicy == nil {
		return ""
	}
	return *t.ExportPolicy
}

// GetImportPolicy retrieves the value of the leaf ImportPolicy from the SrlNokiaSystem_System_Maintenance_Profile_Bgp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ImportPolicy is set, it can
// safely use t.GetImportPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ImportPolicy == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) GetImportPolicy() string {
	if t == nil || t.ImportPolicy == nil {
		return ""
	}
	return *t.ImportPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Profile_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Profile_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Profile_Bgp.
func (*SrlNokiaSystem_System_Maintenance_Profile_Bgp) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Profile_Isis represents the /srl_nokia-system/system/maintenance/profile/isis YANG schema element.
type SrlNokiaSystem_System_Maintenance_Profile_Isis struct {
	Overload *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload `path:"overload" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Profile_Isis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Profile_Isis) IsYANGGoStruct() {}

// GetOrCreateOverload retrieves the value of the Overload field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis) GetOrCreateOverload() *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload {
	if t.Overload != nil {
		return t.Overload
	}
	t.Overload = &SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload{}
	return t.Overload
}

// GetOverload returns the value of the Overload struct pointer
// from SrlNokiaSystem_System_Maintenance_Profile_Isis. If the receiver or the field Overload is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis) GetOverload() *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload {
	if t != nil && t.Overload != nil {
		return t.Overload
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Profile_Isis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Overload.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Profile_Isis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Profile_Isis.
func (*SrlNokiaSystem_System_Maintenance_Profile_Isis) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload represents the /srl_nokia-system/system/maintenance/profile/isis/overload YANG schema element.
type SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload struct {
	MaxMetric *bool `path:"max-metric" module:"srl_nokia-maintenance-mode"`
	SetBit    *bool `path:"set-bit" module:"srl_nokia-maintenance-mode"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) IsYANGGoStruct() {}

// GetMaxMetric retrieves the value of the leaf MaxMetric from the SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxMetric is set, it can
// safely use t.GetMaxMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxMetric == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) GetMaxMetric() bool {
	if t == nil || t.MaxMetric == nil {
		return false
	}
	return *t.MaxMetric
}

// GetSetBit retrieves the value of the leaf SetBit from the SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SetBit is set, it can
// safely use t.GetSetBit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SetBit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) GetSetBit() bool {
	if t == nil || t.SetBit == nil {
		return false
	}
	return *t.SetBit
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaxMetric == nil {
		var v bool = false
		t.MaxMetric = &v
	}
	if t.SetBit == nil {
		var v bool = false
		t.SetBit = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload.
func (*SrlNokiaSystem_System_Maintenance_Profile_Isis_Overload) ΛBelongingModule() string {
	return "srl_nokia-maintenance-mode"
}

// SrlNokiaSystem_System_Management represents the /srl_nokia-system/system/management YANG schema element.
type SrlNokiaSystem_System_Management struct {
	Openconfig *SrlNokiaSystem_System_Management_Openconfig `path:"openconfig" module:"srl_nokia-openconfig" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Management implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Management) IsYANGGoStruct() {}

// GetOrCreateOpenconfig retrieves the value of the Openconfig field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Management) GetOrCreateOpenconfig() *SrlNokiaSystem_System_Management_Openconfig {
	if t.Openconfig != nil {
		return t.Openconfig
	}
	t.Openconfig = &SrlNokiaSystem_System_Management_Openconfig{}
	return t.Openconfig
}

// GetOpenconfig returns the value of the Openconfig struct pointer
// from SrlNokiaSystem_System_Management. If the receiver or the field Openconfig is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Management) GetOpenconfig() *SrlNokiaSystem_System_Management_Openconfig {
	if t != nil && t.Openconfig != nil {
		return t.Openconfig
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Management
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Management) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Openconfig.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Management) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Management"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Management) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Management) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Management.
func (*SrlNokiaSystem_System_Management) ΛBelongingModule() string {
	return "srl_nokia-system"
}

// SrlNokiaSystem_System_Management_Openconfig represents the /srl_nokia-system/system/management/openconfig YANG schema element.
type SrlNokiaSystem_System_Management_Openconfig struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-openconfig"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Management_Openconfig implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Management_Openconfig) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Management_Openconfig
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Management_Openconfig) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Management_Openconfig
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Management_Openconfig) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Management_Openconfig) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Management_Openconfig"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Management_Openconfig) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Management_Openconfig) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Management_Openconfig.
func (*SrlNokiaSystem_System_Management_Openconfig) ΛBelongingModule() string {
	return "srl_nokia-openconfig"
}

// SrlNokiaSystem_System_Mirroring represents the /srl_nokia-system/system/mirroring YANG schema element.
type SrlNokiaSystem_System_Mirroring struct {
	MirroringInstance map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance `path:"mirroring-instance" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring) IsYANGGoStruct() {}

// NewMirroringInstance creates a new entry in the MirroringInstance list of the
// SrlNokiaSystem_System_Mirroring struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mirroring) NewMirroringInstance(Name string) (*SrlNokiaSystem_System_Mirroring_MirroringInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MirroringInstance == nil {
		t.MirroringInstance = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MirroringInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MirroringInstance", key)
	}

	t.MirroringInstance[key] = &SrlNokiaSystem_System_Mirroring_MirroringInstance{
		Name: &Name,
	}

	return t.MirroringInstance[key], nil
}

// RenameMirroringInstance renames an entry in the list MirroringInstance within
// the SrlNokiaSystem_System_Mirroring struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mirroring) RenameMirroringInstance(oldK, newK string) error {
	if _, ok := t.MirroringInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in MirroringInstance", newK)
	}

	e, ok := t.MirroringInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MirroringInstance", oldK)
	}
	e.Name = &newK

	t.MirroringInstance[newK] = e
	delete(t.MirroringInstance, oldK)
	return nil
}

// GetOrCreateMirroringInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mirroring) GetOrCreateMirroringInstance(Name string) *SrlNokiaSystem_System_Mirroring_MirroringInstance {
	key := Name

	if v, ok := t.MirroringInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMirroringInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMirroringInstance got unexpected error: %v", err))
	}
	return v
}

// GetMirroringInstance retrieves the value with the specified key from
// the MirroringInstance map field of SrlNokiaSystem_System_Mirroring. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mirroring) GetMirroringInstance(Name string) *SrlNokiaSystem_System_Mirroring_MirroringInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.MirroringInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteMirroringInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mirroring) DeleteMirroringInstance(Name string) {
	key := Name

	delete(t.MirroringInstance, key)
}

// AppendMirroringInstance appends the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance struct to the
// list MirroringInstance of SrlNokiaSystem_System_Mirroring. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mirroring) AppendMirroringInstance(
	v *SrlNokiaSystem_System_Mirroring_MirroringInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MirroringInstance == nil {
		t.MirroringInstance = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance)
	}

	if _, ok := t.MirroringInstance[key]; ok {
		return fmt.Errorf("duplicate key for list MirroringInstance %v", key)
	}

	t.MirroringInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.MirroringInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring.
func (*SrlNokiaSystem_System_Mirroring) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance represents the /srl_nokia-system/system/mirroring/mirroring-instance YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance struct {
	AdminState        E_SrlNokiaCommon_AdminState                                          `path:"admin-state" module:"srl_nokia-mirroring"`
	Description       *string                                                              `path:"description" module:"srl_nokia-mirroring"`
	MirrorDestination *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination `path:"mirror-destination" module:"srl_nokia-mirroring"`
	MirrorSource      *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource      `path:"mirror-source" module:"srl_nokia-mirroring"`
	Name              *string                                                              `path:"name" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance) IsYANGGoStruct() {}

// GetOrCreateMirrorDestination retrieves the value of the MirrorDestination field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) GetOrCreateMirrorDestination() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination {
	if t.MirrorDestination != nil {
		return t.MirrorDestination
	}
	t.MirrorDestination = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination{}
	return t.MirrorDestination
}

// GetOrCreateMirrorSource retrieves the value of the MirrorSource field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) GetOrCreateMirrorSource() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource {
	if t.MirrorSource != nil {
		return t.MirrorSource
	}
	t.MirrorSource = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource{}
	return t.MirrorSource
}

// GetMirrorDestination returns the value of the MirrorDestination struct pointer
// from SrlNokiaSystem_System_Mirroring_MirroringInstance. If the receiver or the field MirrorDestination is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) GetMirrorDestination() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination {
	if t != nil && t.MirrorDestination != nil {
		return t.MirrorDestination
	}
	return nil
}

// GetMirrorSource returns the value of the MirrorSource struct pointer
// from SrlNokiaSystem_System_Mirroring_MirroringInstance. If the receiver or the field MirrorSource is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) GetMirrorSource() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource {
	if t != nil && t.MirrorSource != nil {
		return t.MirrorSource
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Mirroring_MirroringInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the SrlNokiaSystem_System_Mirroring_MirroringInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Mirroring_MirroringInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.MirrorDestination.PopulateDefaults()
	t.MirrorSource.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mirroring_MirroringInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-destination YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination struct {
	Local  *string                                                                     `path:"local" module:"srl_nokia-mirroring"`
	Remote *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote `path:"remote" module:"srl_nokia-mirroring" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) IsYANGGoStruct() {}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) GetOrCreateRemote() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote {
	if t.Remote != nil {
		return t.Remote
	}
	t.Remote = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote{}
	return t.Remote
}

// GetRemote returns the value of the Remote struct pointer
// from SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) GetRemote() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote {
	if t != nil && t.Remote != nil {
		return t.Remote
	}
	return nil
}

// GetLocal retrieves the value of the leaf Local from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Local is set, it can
// safely use t.GetLocal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Local == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) GetLocal() string {
	if t == nil || t.Local == nil {
		return ""
	}
	return *t.Local
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Remote.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-destination/remote YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote struct {
	Encap           E_SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_Encap          `path:"encap" module:"srl_nokia-mirroring"`
	NetworkInstance *string                                                                                     `path:"network-instance" module:"srl_nokia-mirroring"`
	TunnelEndPoints *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints `path:"tunnel-end-points" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) IsYANGGoStruct() {}

// GetOrCreateTunnelEndPoints retrieves the value of the TunnelEndPoints field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) GetOrCreateTunnelEndPoints() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints {
	if t.TunnelEndPoints != nil {
		return t.TunnelEndPoints
	}
	t.TunnelEndPoints = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints{}
	return t.TunnelEndPoints
}

// GetTunnelEndPoints returns the value of the TunnelEndPoints struct pointer
// from SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote. If the receiver or the field TunnelEndPoints is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) GetTunnelEndPoints() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints {
	if t != nil && t.TunnelEndPoints != nil {
		return t.TunnelEndPoints
	}
	return nil
}

// GetEncap retrieves the value of the leaf Encap from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Encap is set, it can
// safely use t.GetEncap() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Encap == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) GetEncap() E_SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_Encap {
	if t == nil || t.Encap == 0 {
		return 0
	}
	return t.Encap
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.TunnelEndPoints.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-destination/remote/tunnel-end-points YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-mirroring"`
	DstIpv4    *string                     `path:"dst-ipv4" module:"srl_nokia-mirroring"`
	DstIpv6    *string                     `path:"dst-ipv6" module:"srl_nokia-mirroring"`
	SrcIpv4    *string                     `path:"src-ipv4" module:"srl_nokia-mirroring"`
	SrcIpv6    *string                     `path:"src-ipv6" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) IsYANGGoStruct() {
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetDstIpv4 retrieves the value of the leaf DstIpv4 from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIpv4 is set, it can
// safely use t.GetDstIpv4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIpv4 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) GetDstIpv4() string {
	if t == nil || t.DstIpv4 == nil {
		return ""
	}
	return *t.DstIpv4
}

// GetDstIpv6 retrieves the value of the leaf DstIpv6 from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DstIpv6 is set, it can
// safely use t.GetDstIpv6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DstIpv6 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) GetDstIpv6() string {
	if t == nil || t.DstIpv6 == nil {
		return ""
	}
	return *t.DstIpv6
}

// GetSrcIpv4 retrieves the value of the leaf SrcIpv4 from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIpv4 is set, it can
// safely use t.GetSrcIpv4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIpv4 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) GetSrcIpv4() string {
	if t == nil || t.SrcIpv4 == nil {
		return ""
	}
	return *t.SrcIpv4
}

// GetSrcIpv6 retrieves the value of the leaf SrcIpv6 from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SrcIpv6 is set, it can
// safely use t.GetSrcIpv6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SrcIpv6 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) GetSrcIpv6() string {
	if t == nil || t.SrcIpv6 == nil {
		return ""
	}
	return *t.SrcIpv6
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorDestination_Remote_TunnelEndPoints) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource struct {
	Acl          *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl                     `path:"acl" module:"srl_nokia-mirroring"`
	Interface    map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface    `path:"interface" module:"srl_nokia-mirroring"`
	Subinterface map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface `path:"subinterface" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) NewInterface(Name string) (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) GetOrCreateInterface(
	Name string,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface {
	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) GetInterface(Name string) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface struct to the
// list Interface of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) AppendInterface(
	v *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) NewSubinterface(
	Name string,
) (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface{
		Name: &Name,
	}

	return t.Subinterface[key], nil
}

// RenameSubinterface renames an entry in the list Subinterface within
// the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) RenameSubinterface(oldK, newK string) error {
	if _, ok := t.Subinterface[newK]; ok {
		return fmt.Errorf("key %v already exists in Subinterface", newK)
	}

	e, ok := t.Subinterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Subinterface", oldK)
	}
	e.Name = &newK

	t.Subinterface[newK] = e
	delete(t.Subinterface, oldK)
	return nil
}

// GetOrCreateSubinterface retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) GetOrCreateSubinterface(
	Name string,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface {
	key := Name

	if v, ok := t.Subinterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubinterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubinterface got unexpected error: %v", err))
	}
	return v
}

// GetSubinterface retrieves the value with the specified key from
// the Subinterface map field of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) GetSubinterface(
	Name string,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Subinterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteSubinterface deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) DeleteSubinterface(Name string) {
	key := Name

	delete(t.Subinterface, key)
}

// AppendSubinterface appends the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface struct to the
// list Subinterface of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) AppendSubinterface(
	v *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface)
	}

	if _, ok := t.Subinterface[key]; ok {
		return fmt.Errorf("duplicate key for list Subinterface %v", key)
	}

	t.Subinterface[key] = v
	return nil
}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) GetOrCreateAcl() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl{}
	return t.Acl
}

// GetAcl returns the value of the Acl struct pointer
// from SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) GetAcl() *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Acl.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.Subinterface {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source/acl YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl struct {
	Ipv4Filter map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter `path:"ipv4-filter" module:"srl_nokia-mirroring"`
	Ipv6Filter map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter `path:"ipv6-filter" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) IsYANGGoStruct() {}

// NewIpv4Filter creates a new entry in the Ipv4Filter list of the
// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) NewIpv4Filter(
	Name string,
) (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Filter == nil {
		t.Ipv4Filter = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Filter", key)
	}

	t.Ipv4Filter[key] = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter{
		Name: &Name,
	}

	return t.Ipv4Filter[key], nil
}

// RenameIpv4Filter renames an entry in the list Ipv4Filter within
// the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) RenameIpv4Filter(oldK, newK string) error {
	if _, ok := t.Ipv4Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv4Filter", newK)
	}

	e, ok := t.Ipv4Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv4Filter", oldK)
	}
	e.Name = &newK

	t.Ipv4Filter[newK] = e
	delete(t.Ipv4Filter, oldK)
	return nil
}

// GetOrCreateIpv4Filter retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) GetOrCreateIpv4Filter(
	Name string,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter {
	key := Name

	if v, ok := t.Ipv4Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Filter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Filter got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Filter retrieves the value with the specified key from
// the Ipv4Filter map field of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) GetIpv4Filter(
	Name string,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv4Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Filter deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) DeleteIpv4Filter(Name string) {
	key := Name

	delete(t.Ipv4Filter, key)
}

// AppendIpv4Filter appends the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter struct to the
// list Ipv4Filter of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) AppendIpv4Filter(
	v *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Filter == nil {
		t.Ipv4Filter = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter)
	}

	if _, ok := t.Ipv4Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Filter %v", key)
	}

	t.Ipv4Filter[key] = v
	return nil
}

// NewIpv6Filter creates a new entry in the Ipv6Filter list of the
// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) NewIpv6Filter(
	Name string,
) (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Filter == nil {
		t.Ipv6Filter = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Filter", key)
	}

	t.Ipv6Filter[key] = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter{
		Name: &Name,
	}

	return t.Ipv6Filter[key], nil
}

// RenameIpv6Filter renames an entry in the list Ipv6Filter within
// the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) RenameIpv6Filter(oldK, newK string) error {
	if _, ok := t.Ipv6Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6Filter", newK)
	}

	e, ok := t.Ipv6Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6Filter", oldK)
	}
	e.Name = &newK

	t.Ipv6Filter[newK] = e
	delete(t.Ipv6Filter, oldK)
	return nil
}

// GetOrCreateIpv6Filter retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) GetOrCreateIpv6Filter(
	Name string,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter {
	key := Name

	if v, ok := t.Ipv6Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Filter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Filter got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Filter retrieves the value with the specified key from
// the Ipv6Filter map field of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) GetIpv6Filter(
	Name string,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Ipv6Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Filter deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) DeleteIpv6Filter(Name string) {
	key := Name

	delete(t.Ipv6Filter, key)
}

// AppendIpv6Filter appends the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter struct to the
// list Ipv6Filter of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) AppendIpv6Filter(
	v *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Filter == nil {
		t.Ipv6Filter = make(map[string]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter)
	}

	if _, ok := t.Ipv6Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Filter %v", key)
	}

	t.Ipv6Filter[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Ipv4Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Filter {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source/acl/ipv4-filter YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter struct {
	Entry map[uint32]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry `path:"entry" module:"srl_nokia-mirroring"`
	Name  *string                                                                                         `path:"name" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) IsYANGGoStruct() {
}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) NewEntry(
	SequenceId uint32,
) (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) GetOrCreateEntry(
	SequenceId uint32,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) GetEntry(
	SequenceId uint32,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry struct to the
// list Entry of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) AppendEntry(
	v *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source/acl/ipv4-filter/entry YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry struct {
	SequenceId *uint32 `path:"sequence-id" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) IsYANGGoStruct() {
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv4Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source/acl/ipv6-filter YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter struct {
	Entry map[uint32]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry `path:"entry" module:"srl_nokia-mirroring"`
	Name  *string                                                                                         `path:"name" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) IsYANGGoStruct() {
}

// NewEntry creates a new entry in the Entry list of the
// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) NewEntry(
	SequenceId uint32,
) (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) RenameEntry(oldK, newK uint32) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.SequenceId = &newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) GetOrCreateEntry(
	SequenceId uint32,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry {
	key := SequenceId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(SequenceId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) GetEntry(
	SequenceId uint32,
) *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry {
	if t == nil {
		return nil
	}

	key := SequenceId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) DeleteEntry(SequenceId uint32) {
	key := SequenceId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry struct to the
// list Entry of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) AppendEntry(
	v *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry,
) error {
	if v.SequenceId == nil {
		return fmt.Errorf("invalid nil key received for SequenceId")
	}

	key := *v.SequenceId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source/acl/ipv6-filter/entry YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry struct {
	SequenceId *uint32 `path:"sequence-id" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) IsYANGGoStruct() {
}

// GetSequenceId retrieves the value of the leaf SequenceId from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceId is set, it can
// safely use t.GetSequenceId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) GetSequenceId() uint32 {
	if t == nil || t.SequenceId == nil {
		return 0
	}
	return *t.SequenceId
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Acl_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source/interface YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface struct {
	Direction E_SrlNokiaMirroring_Direction `path:"direction" module:"srl_nokia-mirroring"`
	Name      *string                       `path:"name" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) IsYANGGoStruct() {}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) GetDirection() E_SrlNokiaMirroring_Direction {
	if t == nil || t.Direction == 0 {
		return SrlNokiaMirroring_Direction_egress_only
	}
	return t.Direction
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Direction == 0 {
		t.Direction = SrlNokiaMirroring_Direction_egress_only
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Interface) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface represents the /srl_nokia-system/system/mirroring/mirroring-instance/mirror-source/subinterface YANG schema element.
type SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface struct {
	Direction E_SrlNokiaMirroring_Direction `path:"direction" module:"srl_nokia-mirroring"`
	Name      *string                       `path:"name" module:"srl_nokia-mirroring"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) IsYANGGoStruct() {
}

// GetDirection retrieves the value of the leaf Direction from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) GetDirection() E_SrlNokiaMirroring_Direction {
	if t == nil || t.Direction == 0 {
		return SrlNokiaMirroring_Direction_egress_only
	}
	return t.Direction
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Direction == 0 {
		t.Direction = SrlNokiaMirroring_Direction_egress_only
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface.
func (*SrlNokiaSystem_System_Mirroring_MirroringInstance_MirrorSource_Subinterface) ΛBelongingModule() string {
	return "srl_nokia-mirroring"
}

// SrlNokiaSystem_System_Mpls represents the /srl_nokia-system/system/mpls YANG schema element.
type SrlNokiaSystem_System_Mpls struct {
	LabelRanges *SrlNokiaSystem_System_Mpls_LabelRanges `path:"label-ranges" module:"srl_nokia-mpls-label-management"`
	Services    *SrlNokiaSystem_System_Mpls_Services    `path:"services" module:"srl_nokia-mpls-label-management"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mpls) IsYANGGoStruct() {}

// GetOrCreateLabelRanges retrieves the value of the LabelRanges field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mpls) GetOrCreateLabelRanges() *SrlNokiaSystem_System_Mpls_LabelRanges {
	if t.LabelRanges != nil {
		return t.LabelRanges
	}
	t.LabelRanges = &SrlNokiaSystem_System_Mpls_LabelRanges{}
	return t.LabelRanges
}

// GetOrCreateServices retrieves the value of the Services field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mpls) GetOrCreateServices() *SrlNokiaSystem_System_Mpls_Services {
	if t.Services != nil {
		return t.Services
	}
	t.Services = &SrlNokiaSystem_System_Mpls_Services{}
	return t.Services
}

// GetLabelRanges returns the value of the LabelRanges struct pointer
// from SrlNokiaSystem_System_Mpls. If the receiver or the field LabelRanges is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mpls) GetLabelRanges() *SrlNokiaSystem_System_Mpls_LabelRanges {
	if t != nil && t.LabelRanges != nil {
		return t.LabelRanges
	}
	return nil
}

// GetServices returns the value of the Services struct pointer
// from SrlNokiaSystem_System_Mpls. If the receiver or the field Services is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mpls) GetServices() *SrlNokiaSystem_System_Mpls_Services {
	if t != nil && t.Services != nil {
		return t.Services
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.LabelRanges.PopulateDefaults()
	t.Services.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mpls.
func (*SrlNokiaSystem_System_Mpls) ΛBelongingModule() string {
	return "srl_nokia-mpls-label-management"
}

// SrlNokiaSystem_System_Mpls_LabelRanges represents the /srl_nokia-system/system/mpls/label-ranges YANG schema element.
type SrlNokiaSystem_System_Mpls_LabelRanges struct {
	Dynamic map[string]*SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic `path:"dynamic" module:"srl_nokia-mpls-label-management"`
	Static  map[string]*SrlNokiaSystem_System_Mpls_LabelRanges_Static  `path:"static" module:"srl_nokia-mpls-label-management"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mpls_LabelRanges implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mpls_LabelRanges) IsYANGGoStruct() {}

// NewDynamic creates a new entry in the Dynamic list of the
// SrlNokiaSystem_System_Mpls_LabelRanges struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) NewDynamic(Name string) (*SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dynamic == nil {
		t.Dynamic = make(map[string]*SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dynamic[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dynamic", key)
	}

	t.Dynamic[key] = &SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic{
		Name: &Name,
	}

	return t.Dynamic[key], nil
}

// RenameDynamic renames an entry in the list Dynamic within
// the SrlNokiaSystem_System_Mpls_LabelRanges struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) RenameDynamic(oldK, newK string) error {
	if _, ok := t.Dynamic[newK]; ok {
		return fmt.Errorf("key %v already exists in Dynamic", newK)
	}

	e, ok := t.Dynamic[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dynamic", oldK)
	}
	e.Name = &newK

	t.Dynamic[newK] = e
	delete(t.Dynamic, oldK)
	return nil
}

// GetOrCreateDynamic retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mpls_LabelRanges. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) GetOrCreateDynamic(Name string) *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic {
	key := Name

	if v, ok := t.Dynamic[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDynamic(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDynamic got unexpected error: %v", err))
	}
	return v
}

// GetDynamic retrieves the value with the specified key from
// the Dynamic map field of SrlNokiaSystem_System_Mpls_LabelRanges. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) GetDynamic(Name string) *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Dynamic[key]; ok {
		return lm
	}
	return nil
}

// DeleteDynamic deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mpls_LabelRanges. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) DeleteDynamic(Name string) {
	key := Name

	delete(t.Dynamic, key)
}

// AppendDynamic appends the supplied SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic struct to the
// list Dynamic of SrlNokiaSystem_System_Mpls_LabelRanges. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) AppendDynamic(v *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dynamic == nil {
		t.Dynamic = make(map[string]*SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic)
	}

	if _, ok := t.Dynamic[key]; ok {
		return fmt.Errorf("duplicate key for list Dynamic %v", key)
	}

	t.Dynamic[key] = v
	return nil
}

// NewStatic creates a new entry in the Static list of the
// SrlNokiaSystem_System_Mpls_LabelRanges struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) NewStatic(Name string) (*SrlNokiaSystem_System_Mpls_LabelRanges_Static, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*SrlNokiaSystem_System_Mpls_LabelRanges_Static)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Static[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Static", key)
	}

	t.Static[key] = &SrlNokiaSystem_System_Mpls_LabelRanges_Static{
		Name: &Name,
	}

	return t.Static[key], nil
}

// RenameStatic renames an entry in the list Static within
// the SrlNokiaSystem_System_Mpls_LabelRanges struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) RenameStatic(oldK, newK string) error {
	if _, ok := t.Static[newK]; ok {
		return fmt.Errorf("key %v already exists in Static", newK)
	}

	e, ok := t.Static[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Static", oldK)
	}
	e.Name = &newK

	t.Static[newK] = e
	delete(t.Static, oldK)
	return nil
}

// GetOrCreateStatic retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mpls_LabelRanges. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) GetOrCreateStatic(Name string) *SrlNokiaSystem_System_Mpls_LabelRanges_Static {
	key := Name

	if v, ok := t.Static[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatic(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatic got unexpected error: %v", err))
	}
	return v
}

// GetStatic retrieves the value with the specified key from
// the Static map field of SrlNokiaSystem_System_Mpls_LabelRanges. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) GetStatic(Name string) *SrlNokiaSystem_System_Mpls_LabelRanges_Static {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Static[key]; ok {
		return lm
	}
	return nil
}

// DeleteStatic deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Mpls_LabelRanges. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) DeleteStatic(Name string) {
	key := Name

	delete(t.Static, key)
}

// AppendStatic appends the supplied SrlNokiaSystem_System_Mpls_LabelRanges_Static struct to the
// list Static of SrlNokiaSystem_System_Mpls_LabelRanges. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Mpls_LabelRanges_Static already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) AppendStatic(v *SrlNokiaSystem_System_Mpls_LabelRanges_Static) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Static == nil {
		t.Static = make(map[string]*SrlNokiaSystem_System_Mpls_LabelRanges_Static)
	}

	if _, ok := t.Static[key]; ok {
		return fmt.Errorf("duplicate key for list Static %v", key)
	}

	t.Static[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mpls_LabelRanges
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Dynamic {
		e.PopulateDefaults()
	}
	for _, e := range t.Static {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mpls_LabelRanges"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mpls_LabelRanges.
func (*SrlNokiaSystem_System_Mpls_LabelRanges) ΛBelongingModule() string {
	return "srl_nokia-mpls-label-management"
}

// SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic represents the /srl_nokia-system/system/mpls/label-ranges/dynamic YANG schema element.
type SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic struct {
	EndLabel   *uint32 `path:"end-label" module:"srl_nokia-mpls-label-management"`
	Name       *string `path:"name" module:"srl_nokia-mpls-label-management"`
	StartLabel *uint32 `path:"start-label" module:"srl_nokia-mpls-label-management"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) IsYANGGoStruct() {}

// GetEndLabel retrieves the value of the leaf EndLabel from the SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndLabel is set, it can
// safely use t.GetEndLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndLabel == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) GetEndLabel() uint32 {
	if t == nil || t.EndLabel == nil {
		return 0
	}
	return *t.EndLabel
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetStartLabel retrieves the value of the leaf StartLabel from the SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartLabel is set, it can
// safely use t.GetStartLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartLabel == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) GetStartLabel() uint32 {
	if t == nil || t.StartLabel == nil {
		return 0
	}
	return *t.StartLabel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic.
func (*SrlNokiaSystem_System_Mpls_LabelRanges_Dynamic) ΛBelongingModule() string {
	return "srl_nokia-mpls-label-management"
}

// SrlNokiaSystem_System_Mpls_LabelRanges_Static represents the /srl_nokia-system/system/mpls/label-ranges/static YANG schema element.
type SrlNokiaSystem_System_Mpls_LabelRanges_Static struct {
	EndLabel   *uint32 `path:"end-label" module:"srl_nokia-mpls-label-management"`
	Name       *string `path:"name" module:"srl_nokia-mpls-label-management"`
	Shared     *bool   `path:"shared" module:"srl_nokia-mpls-label-management"`
	StartLabel *uint32 `path:"start-label" module:"srl_nokia-mpls-label-management"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mpls_LabelRanges_Static implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mpls_LabelRanges_Static) IsYANGGoStruct() {}

// GetEndLabel retrieves the value of the leaf EndLabel from the SrlNokiaSystem_System_Mpls_LabelRanges_Static
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndLabel is set, it can
// safely use t.GetEndLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndLabel == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) GetEndLabel() uint32 {
	if t == nil || t.EndLabel == nil {
		return 0
	}
	return *t.EndLabel
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Mpls_LabelRanges_Static
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetShared retrieves the value of the leaf Shared from the SrlNokiaSystem_System_Mpls_LabelRanges_Static
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Shared is set, it can
// safely use t.GetShared() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Shared == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) GetShared() bool {
	if t == nil || t.Shared == nil {
		return true
	}
	return *t.Shared
}

// GetStartLabel retrieves the value of the leaf StartLabel from the SrlNokiaSystem_System_Mpls_LabelRanges_Static
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartLabel is set, it can
// safely use t.GetStartLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartLabel == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) GetStartLabel() uint32 {
	if t == nil || t.StartLabel == nil {
		return 0
	}
	return *t.StartLabel
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mpls_LabelRanges_Static
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Shared == nil {
		var v bool = true
		t.Shared = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Mpls_LabelRanges_Static struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mpls_LabelRanges_Static"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mpls_LabelRanges_Static) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mpls_LabelRanges_Static.
func (*SrlNokiaSystem_System_Mpls_LabelRanges_Static) ΛBelongingModule() string {
	return "srl_nokia-mpls-label-management"
}

// SrlNokiaSystem_System_Mpls_Services represents the /srl_nokia-system/system/mpls/services YANG schema element.
type SrlNokiaSystem_System_Mpls_Services struct {
	Evpn *SrlNokiaSystem_System_Mpls_Services_Evpn `path:"evpn" module:"srl_nokia-mpls-services-evpn-label-management" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mpls_Services implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mpls_Services) IsYANGGoStruct() {}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Mpls_Services) GetOrCreateEvpn() *SrlNokiaSystem_System_Mpls_Services_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &SrlNokiaSystem_System_Mpls_Services_Evpn{}
	return t.Evpn
}

// GetEvpn returns the value of the Evpn struct pointer
// from SrlNokiaSystem_System_Mpls_Services. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Mpls_Services) GetEvpn() *SrlNokiaSystem_System_Mpls_Services_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mpls_Services
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mpls_Services) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Evpn.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_Services) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mpls_Services"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_Services) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mpls_Services) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mpls_Services.
func (*SrlNokiaSystem_System_Mpls_Services) ΛBelongingModule() string {
	return "srl_nokia-mpls-label-management"
}

// SrlNokiaSystem_System_Mpls_Services_Evpn represents the /srl_nokia-system/system/mpls/services/evpn YANG schema element.
type SrlNokiaSystem_System_Mpls_Services_Evpn struct {
	DynamicLabelBlock *string `path:"dynamic-label-block" module:"srl_nokia-mpls-services-evpn-label-management"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mpls_Services_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mpls_Services_Evpn) IsYANGGoStruct() {}

// GetDynamicLabelBlock retrieves the value of the leaf DynamicLabelBlock from the SrlNokiaSystem_System_Mpls_Services_Evpn
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DynamicLabelBlock is set, it can
// safely use t.GetDynamicLabelBlock() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DynamicLabelBlock == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mpls_Services_Evpn) GetDynamicLabelBlock() string {
	if t == nil || t.DynamicLabelBlock == nil {
		return ""
	}
	return *t.DynamicLabelBlock
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mpls_Services_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mpls_Services_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_Services_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mpls_Services_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mpls_Services_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mpls_Services_Evpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mpls_Services_Evpn.
func (*SrlNokiaSystem_System_Mpls_Services_Evpn) ΛBelongingModule() string {
	return "srl_nokia-mpls-services-evpn-label-management"
}

// SrlNokiaSystem_System_Mtu represents the /srl_nokia-system/system/mtu YANG schema element.
type SrlNokiaSystem_System_Mtu struct {
	DefaultIpMtu   *uint16 `path:"default-ip-mtu" module:"srl_nokia-mtu"`
	DefaultL2Mtu   *uint16 `path:"default-l2-mtu" module:"srl_nokia-mtu"`
	DefaultMplsMtu *uint16 `path:"default-mpls-mtu" module:"srl_nokia-mtu"`
	DefaultPortMtu *uint16 `path:"default-port-mtu" module:"srl_nokia-mtu"`
	MinPathMtu     *uint16 `path:"min-path-mtu" module:"srl_nokia-mtu"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Mtu implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Mtu) IsYANGGoStruct() {}

// GetDefaultIpMtu retrieves the value of the leaf DefaultIpMtu from the SrlNokiaSystem_System_Mtu
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultIpMtu is set, it can
// safely use t.GetDefaultIpMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultIpMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mtu) GetDefaultIpMtu() uint16 {
	if t == nil || t.DefaultIpMtu == nil {
		return 1500
	}
	return *t.DefaultIpMtu
}

// GetDefaultL2Mtu retrieves the value of the leaf DefaultL2Mtu from the SrlNokiaSystem_System_Mtu
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultL2Mtu is set, it can
// safely use t.GetDefaultL2Mtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultL2Mtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mtu) GetDefaultL2Mtu() uint16 {
	if t == nil || t.DefaultL2Mtu == nil {
		return 9232
	}
	return *t.DefaultL2Mtu
}

// GetDefaultMplsMtu retrieves the value of the leaf DefaultMplsMtu from the SrlNokiaSystem_System_Mtu
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultMplsMtu is set, it can
// safely use t.GetDefaultMplsMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultMplsMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mtu) GetDefaultMplsMtu() uint16 {
	if t == nil || t.DefaultMplsMtu == nil {
		return 1508
	}
	return *t.DefaultMplsMtu
}

// GetDefaultPortMtu retrieves the value of the leaf DefaultPortMtu from the SrlNokiaSystem_System_Mtu
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultPortMtu is set, it can
// safely use t.GetDefaultPortMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultPortMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mtu) GetDefaultPortMtu() uint16 {
	if t == nil || t.DefaultPortMtu == nil {
		return 9232
	}
	return *t.DefaultPortMtu
}

// GetMinPathMtu retrieves the value of the leaf MinPathMtu from the SrlNokiaSystem_System_Mtu
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinPathMtu is set, it can
// safely use t.GetMinPathMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinPathMtu == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Mtu) GetMinPathMtu() uint16 {
	if t == nil || t.MinPathMtu == nil {
		return 552
	}
	return *t.MinPathMtu
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Mtu
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Mtu) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultIpMtu == nil {
		var v uint16 = 1500
		t.DefaultIpMtu = &v
	}
	if t.DefaultL2Mtu == nil {
		var v uint16 = 9232
		t.DefaultL2Mtu = &v
	}
	if t.DefaultMplsMtu == nil {
		var v uint16 = 1508
		t.DefaultMplsMtu = &v
	}
	if t.DefaultPortMtu == nil {
		var v uint16 = 9232
		t.DefaultPortMtu = &v
	}
	if t.MinPathMtu == nil {
		var v uint16 = 552
		t.MinPathMtu = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mtu) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mtu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mtu) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mtu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Mtu.
func (*SrlNokiaSystem_System_Mtu) ΛBelongingModule() string {
	return "srl_nokia-mtu"
}

// SrlNokiaSystem_System_Name represents the /srl_nokia-system/system/name YANG schema element.
type SrlNokiaSystem_System_Name struct {
	DomainName *string `path:"domain-name" module:"srl_nokia-system-name"`
	HostName   *string `path:"host-name" module:"srl_nokia-system-name"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Name implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Name) IsYANGGoStruct() {}

// GetDomainName retrieves the value of the leaf DomainName from the SrlNokiaSystem_System_Name
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DomainName is set, it can
// safely use t.GetDomainName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DomainName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Name) GetDomainName() string {
	if t == nil || t.DomainName == nil {
		return ""
	}
	return *t.DomainName
}

// GetHostName retrieves the value of the leaf HostName from the SrlNokiaSystem_System_Name
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HostName is set, it can
// safely use t.GetHostName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HostName == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Name) GetHostName() string {
	if t == nil || t.HostName == nil {
		return ""
	}
	return *t.HostName
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Name
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Name) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Name) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Name"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Name) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Name) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Name.
func (*SrlNokiaSystem_System_Name) ΛBelongingModule() string {
	return "srl_nokia-system-name"
}

// SrlNokiaSystem_System_NetworkInstance represents the /srl_nokia-system/system/network-instance YANG schema element.
type SrlNokiaSystem_System_NetworkInstance struct {
	Protocols *SrlNokiaSystem_System_NetworkInstance_Protocols `path:"protocols" module:"srl_nokia-system-network-instance"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance) IsYANGGoStruct() {}

// GetOrCreateProtocols retrieves the value of the Protocols field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance) GetOrCreateProtocols() *SrlNokiaSystem_System_NetworkInstance_Protocols {
	if t.Protocols != nil {
		return t.Protocols
	}
	t.Protocols = &SrlNokiaSystem_System_NetworkInstance_Protocols{}
	return t.Protocols
}

// GetProtocols returns the value of the Protocols struct pointer
// from SrlNokiaSystem_System_NetworkInstance. If the receiver or the field Protocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance) GetProtocols() *SrlNokiaSystem_System_NetworkInstance_Protocols {
	if t != nil && t.Protocols != nil {
		return t.Protocols
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Protocols.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance.
func (*SrlNokiaSystem_System_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols represents the /srl_nokia-system/system/network-instance/protocols YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols struct {
	BgpVpn *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn `path:"bgp-vpn" module:"srl_nokia-system-network-instance-bgp-vpn" yangPresence:"true"`
	Evpn   *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn   `path:"evpn" module:"srl_nokia-system-network-instance" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols) IsYANGGoStruct() {}

// GetOrCreateBgpVpn retrieves the value of the BgpVpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) GetOrCreateBgpVpn() *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn {
	if t.BgpVpn != nil {
		return t.BgpVpn
	}
	t.BgpVpn = &SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn{}
	return t.BgpVpn
}

// GetOrCreateEvpn retrieves the value of the Evpn field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) GetOrCreateEvpn() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn {
	if t.Evpn != nil {
		return t.Evpn
	}
	t.Evpn = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn{}
	return t.Evpn
}

// GetBgpVpn returns the value of the BgpVpn struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols. If the receiver or the field BgpVpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) GetBgpVpn() *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn {
	if t != nil && t.BgpVpn != nil {
		return t.BgpVpn
	}
	return nil
}

// GetEvpn returns the value of the Evpn struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols. If the receiver or the field Evpn is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) GetEvpn() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn {
	if t != nil && t.Evpn != nil {
		return t.Evpn
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.BgpVpn.PopulateDefaults()
	t.Evpn.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn represents the /srl_nokia-system/system/network-instance/protocols/bgp-vpn YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn struct {
	BgpInstance map[uint8]*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance `path:"bgp-instance" module:"srl_nokia-system-network-instance-bgp-vpn"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) IsYANGGoStruct() {}

// NewBgpInstance creates a new entry in the BgpInstance list of the
// SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) NewBgpInstance(Id uint8) (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpInstance == nil {
		t.BgpInstance = make(map[uint8]*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BgpInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BgpInstance", key)
	}

	t.BgpInstance[key] = &SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance{
		Id: &Id,
	}

	return t.BgpInstance[key], nil
}

// RenameBgpInstance renames an entry in the list BgpInstance within
// the SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) RenameBgpInstance(oldK, newK uint8) error {
	if _, ok := t.BgpInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in BgpInstance", newK)
	}

	e, ok := t.BgpInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BgpInstance", oldK)
	}
	e.Id = &newK

	t.BgpInstance[newK] = e
	delete(t.BgpInstance, oldK)
	return nil
}

// GetOrCreateBgpInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) GetOrCreateBgpInstance(Id uint8) *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance {
	key := Id

	if v, ok := t.BgpInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBgpInstance(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBgpInstance got unexpected error: %v", err))
	}
	return v
}

// GetBgpInstance retrieves the value with the specified key from
// the BgpInstance map field of SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) GetBgpInstance(Id uint8) *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.BgpInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteBgpInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) DeleteBgpInstance(Id uint8) {
	key := Id

	delete(t.BgpInstance, key)
}

// AppendBgpInstance appends the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance struct to the
// list BgpInstance of SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) AppendBgpInstance(
	v *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance,
) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpInstance == nil {
		t.BgpInstance = make(map[uint8]*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance)
	}

	if _, ok := t.BgpInstance[key]; ok {
		return fmt.Errorf("duplicate key for list BgpInstance %v", key)
	}

	t.BgpInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.BgpInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-vpn"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance represents the /srl_nokia-system/system/network-instance/protocols/bgp-vpn/bgp-instance YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance struct {
	Id                 *uint8                                                                                 `path:"id" module:"srl_nokia-system-network-instance-bgp-vpn"`
	RouteDistinguisher *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher `path:"route-distinguisher" module:"srl_nokia-system-network-instance-bgp-vpn"`
	RouteTarget        *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget        `path:"route-target" module:"srl_nokia-system-network-instance-bgp-vpn"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) IsYANGGoStruct() {}

// GetOrCreateRouteDistinguisher retrieves the value of the RouteDistinguisher field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) GetOrCreateRouteDistinguisher() *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher {
	if t.RouteDistinguisher != nil {
		return t.RouteDistinguisher
	}
	t.RouteDistinguisher = &SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher{}
	return t.RouteDistinguisher
}

// GetOrCreateRouteTarget retrieves the value of the RouteTarget field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) GetOrCreateRouteTarget() *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget {
	if t.RouteTarget != nil {
		return t.RouteTarget
	}
	t.RouteTarget = &SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget{}
	return t.RouteTarget
}

// GetRouteDistinguisher returns the value of the RouteDistinguisher struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance. If the receiver or the field RouteDistinguisher is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) GetRouteDistinguisher() *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher {
	if t != nil && t.RouteDistinguisher != nil {
		return t.RouteDistinguisher
	}
	return nil
}

// GetRouteTarget returns the value of the RouteTarget struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance. If the receiver or the field RouteTarget is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) GetRouteTarget() *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget {
	if t != nil && t.RouteTarget != nil {
		return t.RouteTarget
	}
	return nil
}

// GetId retrieves the value of the leaf Id from the SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) GetId() uint8 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.RouteDistinguisher.PopulateDefaults()
	t.RouteTarget.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-vpn"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher represents the /srl_nokia-system/system/network-instance/protocols/bgp-vpn/bgp-instance/route-distinguisher YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher struct{}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteDistinguisher) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-vpn"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget represents the /srl_nokia-system/system/network-instance/protocols/bgp-vpn/bgp-instance/route-target YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget struct{}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_BgpVpn_BgpInstance_RouteTarget) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-vpn"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn represents the /srl_nokia-system/system/network-instance/protocols/evpn YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn struct {
	EthernetSegments *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments `path:"ethernet-segments" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments" yangPresence:"true"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) IsYANGGoStruct() {}

// GetOrCreateEthernetSegments retrieves the value of the EthernetSegments field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) GetOrCreateEthernetSegments() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments {
	if t.EthernetSegments != nil {
		return t.EthernetSegments
	}
	t.EthernetSegments = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments{}
	return t.EthernetSegments
}

// GetEthernetSegments returns the value of the EthernetSegments struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn. If the receiver or the field EthernetSegments is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) GetEthernetSegments() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments {
	if t != nil && t.EthernetSegments != nil {
		return t.EthernetSegments
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.EthernetSegments.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments struct {
	BgpInstance map[uint8]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance `path:"bgp-instance" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	Timers      *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers                `path:"timers" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) IsYANGGoStruct() {}

// NewBgpInstance creates a new entry in the BgpInstance list of the
// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) NewBgpInstance(
	Id uint8,
) (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpInstance == nil {
		t.BgpInstance = make(map[uint8]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BgpInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BgpInstance", key)
	}

	t.BgpInstance[key] = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance{
		Id: &Id,
	}

	return t.BgpInstance[key], nil
}

// RenameBgpInstance renames an entry in the list BgpInstance within
// the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) RenameBgpInstance(oldK, newK uint8) error {
	if _, ok := t.BgpInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in BgpInstance", newK)
	}

	e, ok := t.BgpInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BgpInstance", oldK)
	}
	e.Id = &newK

	t.BgpInstance[newK] = e
	delete(t.BgpInstance, oldK)
	return nil
}

// GetOrCreateBgpInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) GetOrCreateBgpInstance(
	Id uint8,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance {
	key := Id

	if v, ok := t.BgpInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBgpInstance(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBgpInstance got unexpected error: %v", err))
	}
	return v
}

// GetBgpInstance retrieves the value with the specified key from
// the BgpInstance map field of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) GetBgpInstance(
	Id uint8,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance {
	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.BgpInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteBgpInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) DeleteBgpInstance(Id uint8) {
	key := Id

	delete(t.BgpInstance, key)
}

// AppendBgpInstance appends the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance struct to the
// list BgpInstance of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) AppendBgpInstance(
	v *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance,
) error {
	if v.Id == nil {
		return fmt.Errorf("invalid nil key received for Id")
	}

	key := *v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpInstance == nil {
		t.BgpInstance = make(map[uint8]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance)
	}

	if _, ok := t.BgpInstance[key]; ok {
		return fmt.Errorf("duplicate key for list BgpInstance %v", key)
	}

	t.BgpInstance[key] = v
	return nil
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) GetOrCreateTimers() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers{}
	return t.Timers
}

// GetTimers returns the value of the Timers struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) GetTimers() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Timers.PopulateDefaults()
	for _, e := range t.BgpInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance struct {
	EthernetSegment map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment `path:"ethernet-segment" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	Id              *uint8                                                                                                        `path:"id" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) IsYANGGoStruct() {
}

// NewEthernetSegment creates a new entry in the EthernetSegment list of the
// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) NewEthernetSegment(
	Name string,
) (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthernetSegment == nil {
		t.EthernetSegment = make(map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EthernetSegment[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EthernetSegment", key)
	}

	t.EthernetSegment[key] = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment{
		Name: &Name,
	}

	return t.EthernetSegment[key], nil
}

// RenameEthernetSegment renames an entry in the list EthernetSegment within
// the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) RenameEthernetSegment(oldK, newK string) error {
	if _, ok := t.EthernetSegment[newK]; ok {
		return fmt.Errorf("key %v already exists in EthernetSegment", newK)
	}

	e, ok := t.EthernetSegment[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EthernetSegment", oldK)
	}
	e.Name = &newK

	t.EthernetSegment[newK] = e
	delete(t.EthernetSegment, oldK)
	return nil
}

// GetOrCreateEthernetSegment retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) GetOrCreateEthernetSegment(
	Name string,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment {
	key := Name

	if v, ok := t.EthernetSegment[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEthernetSegment(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEthernetSegment got unexpected error: %v", err))
	}
	return v
}

// GetEthernetSegment retrieves the value with the specified key from
// the EthernetSegment map field of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) GetEthernetSegment(
	Name string,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.EthernetSegment[key]; ok {
		return lm
	}
	return nil
}

// DeleteEthernetSegment deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) DeleteEthernetSegment(Name string) {
	key := Name

	delete(t.EthernetSegment, key)
}

// AppendEthernetSegment appends the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment struct to the
// list EthernetSegment of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) AppendEthernetSegment(
	v *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthernetSegment == nil {
		t.EthernetSegment = make(map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment)
	}

	if _, ok := t.EthernetSegment[key]; ok {
		return fmt.Errorf("duplicate key for list EthernetSegment %v", key)
	}

	t.EthernetSegment[key] = v
	return nil
}

// GetId retrieves the value of the leaf Id from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) GetId() uint8 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EthernetSegment {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment struct {
	AdminState      E_SrlNokiaCommon_AdminState                                                                                             `path:"admin-state" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	DfElection      *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection           `path:"df-election" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	Esi             *string                                                                                                                 `path:"esi" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	Interface       map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface `path:"interface" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	MultiHomingMode E_SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_MultiHomingMode                                                  `path:"multi-homing-mode" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	Name            *string                                                                                                                 `path:"name" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	NextHop         map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop   `path:"next-hop" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	Routes          *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes               `path:"routes" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	Type            E_SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_EsType                                                           `path:"type" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) IsYANGGoStruct() {
}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) NewInterface(
	EthernetInterface string,
) (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface)
	}

	key := EthernetInterface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface{
		EthernetInterface: &EthernetInterface,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.EthernetInterface = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetOrCreateInterface(
	EthernetInterface string,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface {
	key := EthernetInterface

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(EthernetInterface)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetInterface(
	EthernetInterface string,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface {
	if t == nil {
		return nil
	}

	key := EthernetInterface

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) DeleteInterface(EthernetInterface string) {
	key := EthernetInterface

	delete(t.Interface, key)
}

// AppendInterface appends the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface struct to the
// list Interface of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) AppendInterface(
	v *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface,
) error {
	if v.EthernetInterface == nil {
		return fmt.Errorf("invalid nil key received for EthernetInterface")
	}

	key := *v.EthernetInterface

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewNextHop creates a new entry in the NextHop list of the
// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) NewNextHop(
	L3NextHop string,
) (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop)
	}

	key := L3NextHop

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop{
		L3NextHop: &L3NextHop,
	}

	return t.NextHop[key], nil
}

// RenameNextHop renames an entry in the list NextHop within
// the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) RenameNextHop(oldK, newK string) error {
	if _, ok := t.NextHop[newK]; ok {
		return fmt.Errorf("key %v already exists in NextHop", newK)
	}

	e, ok := t.NextHop[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NextHop", oldK)
	}
	e.L3NextHop = &newK

	t.NextHop[newK] = e
	delete(t.NextHop, oldK)
	return nil
}

// GetOrCreateNextHop retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetOrCreateNextHop(
	L3NextHop string,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop {
	key := L3NextHop

	if v, ok := t.NextHop[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNextHop(L3NextHop)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNextHop got unexpected error: %v", err))
	}
	return v
}

// GetNextHop retrieves the value with the specified key from
// the NextHop map field of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetNextHop(
	L3NextHop string,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop {
	if t == nil {
		return nil
	}

	key := L3NextHop

	if lm, ok := t.NextHop[key]; ok {
		return lm
	}
	return nil
}

// DeleteNextHop deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) DeleteNextHop(L3NextHop string) {
	key := L3NextHop

	delete(t.NextHop, key)
}

// AppendNextHop appends the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop struct to the
// list NextHop of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) AppendNextHop(
	v *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop,
) error {
	if v.L3NextHop == nil {
		return fmt.Errorf("invalid nil key received for L3NextHop")
	}

	key := *v.L3NextHop

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[string]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop)
	}

	if _, ok := t.NextHop[key]; ok {
		return fmt.Errorf("duplicate key for list NextHop %v", key)
	}

	t.NextHop[key] = v
	return nil
}

// GetOrCreateDfElection retrieves the value of the DfElection field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetOrCreateDfElection() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection {
	if t.DfElection != nil {
		return t.DfElection
	}
	t.DfElection = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection{}
	return t.DfElection
}

// GetOrCreateRoutes retrieves the value of the Routes field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetOrCreateRoutes() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes {
	if t.Routes != nil {
		return t.Routes
	}
	t.Routes = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes{}
	return t.Routes
}

// GetDfElection returns the value of the DfElection struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the receiver or the field DfElection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetDfElection() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection {
	if t != nil && t.DfElection != nil {
		return t.DfElection
	}
	return nil
}

// GetRoutes returns the value of the Routes struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment. If the receiver or the field Routes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetRoutes() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes {
	if t != nil && t.Routes != nil {
		return t.Routes
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetEsi retrieves the value of the leaf Esi from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetMultiHomingMode retrieves the value of the leaf MultiHomingMode from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MultiHomingMode is set, it can
// safely use t.GetMultiHomingMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MultiHomingMode == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetMultiHomingMode() E_SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_MultiHomingMode {
	if t == nil || t.MultiHomingMode == 0 {
		return SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_MultiHomingMode_all_active
	}
	return t.MultiHomingMode
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetType retrieves the value of the leaf Type from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) GetType() E_SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_EsType {
	if t == nil || t.Type == 0 {
		return SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_EsType_none
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.MultiHomingMode == 0 {
		t.MultiHomingMode = SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_MultiHomingMode_all_active
	}
	if t.Type == 0 {
		t.Type = SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_EsType_none
	}
	t.DfElection.PopulateDefaults()
	t.Routes.PopulateDefaults()
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.NextHop {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection struct {
	Algorithm                        *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm                        `path:"algorithm" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	InterfaceStandbySignalingOnNonDf *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf `path:"interface-standby-signaling-on-non-df" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments" yangPresence:"true"`
	Timers                           *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers                           `path:"timers" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) IsYANGGoStruct() {
}

// GetOrCreateAlgorithm retrieves the value of the Algorithm field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) GetOrCreateAlgorithm() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm {
	if t.Algorithm != nil {
		return t.Algorithm
	}
	t.Algorithm = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm{}
	return t.Algorithm
}

// GetOrCreateInterfaceStandbySignalingOnNonDf retrieves the value of the InterfaceStandbySignalingOnNonDf field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) GetOrCreateInterfaceStandbySignalingOnNonDf() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf {
	if t.InterfaceStandbySignalingOnNonDf != nil {
		return t.InterfaceStandbySignalingOnNonDf
	}
	t.InterfaceStandbySignalingOnNonDf = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf{}
	return t.InterfaceStandbySignalingOnNonDf
}

// GetOrCreateTimers retrieves the value of the Timers field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) GetOrCreateTimers() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers {
	if t.Timers != nil {
		return t.Timers
	}
	t.Timers = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers{}
	return t.Timers
}

// GetAlgorithm returns the value of the Algorithm struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection. If the receiver or the field Algorithm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) GetAlgorithm() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm {
	if t != nil && t.Algorithm != nil {
		return t.Algorithm
	}
	return nil
}

// GetInterfaceStandbySignalingOnNonDf returns the value of the InterfaceStandbySignalingOnNonDf struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection. If the receiver or the field InterfaceStandbySignalingOnNonDf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) GetInterfaceStandbySignalingOnNonDf() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf {
	if t != nil && t.InterfaceStandbySignalingOnNonDf != nil {
		return t.InterfaceStandbySignalingOnNonDf
	}
	return nil
}

// GetTimers returns the value of the Timers struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection. If the receiver or the field Timers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) GetTimers() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers {
	if t != nil && t.Timers != nil {
		return t.Timers
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Algorithm.PopulateDefaults()
	t.InterfaceStandbySignalingOnNonDf.PopulateDefaults()
	t.Timers.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election/algorithm YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm struct {
	ManualAlg     *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg     `path:"manual-alg" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments" yangPresence:"true"`
	PreferenceAlg *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg `path:"preference-alg" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments" yangPresence:"true"`
	Type          E_SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_DfAlgorithmType                                                                `path:"type" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) IsYANGGoStruct() {
}

// GetOrCreateManualAlg retrieves the value of the ManualAlg field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) GetOrCreateManualAlg() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg {
	if t.ManualAlg != nil {
		return t.ManualAlg
	}
	t.ManualAlg = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg{}
	return t.ManualAlg
}

// GetOrCreatePreferenceAlg retrieves the value of the PreferenceAlg field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) GetOrCreatePreferenceAlg() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg {
	if t.PreferenceAlg != nil {
		return t.PreferenceAlg
	}
	t.PreferenceAlg = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg{}
	return t.PreferenceAlg
}

// GetManualAlg returns the value of the ManualAlg struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm. If the receiver or the field ManualAlg is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) GetManualAlg() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg {
	if t != nil && t.ManualAlg != nil {
		return t.ManualAlg
	}
	return nil
}

// GetPreferenceAlg returns the value of the PreferenceAlg struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm. If the receiver or the field PreferenceAlg is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) GetPreferenceAlg() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg {
	if t != nil && t.PreferenceAlg != nil {
		return t.PreferenceAlg
	}
	return nil
}

// GetType retrieves the value of the leaf Type from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) GetType() E_SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_DfAlgorithmType {
	if t == nil || t.Type == 0 {
		return SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_DfAlgorithmType_default
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Type == 0 {
		t.Type = SrlNokiaSystemNetworkInstanceBgpEvpnEthernetSegments_DfAlgorithmType_default
	}
	t.ManualAlg.PopulateDefaults()
	t.PreferenceAlg.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election/algorithm/manual-alg YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg struct {
	PrimaryEviRange map[uint32]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange `path:"primary-evi-range" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) IsYANGGoStruct() {
}

// NewPrimaryEviRange creates a new entry in the PrimaryEviRange list of the
// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) NewPrimaryEviRange(
	StartEvi uint32,
) (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrimaryEviRange == nil {
		t.PrimaryEviRange = make(map[uint32]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange)
	}

	key := StartEvi

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrimaryEviRange[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrimaryEviRange", key)
	}

	t.PrimaryEviRange[key] = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange{
		StartEvi: &StartEvi,
	}

	return t.PrimaryEviRange[key], nil
}

// RenamePrimaryEviRange renames an entry in the list PrimaryEviRange within
// the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) RenamePrimaryEviRange(oldK, newK uint32) error {
	if _, ok := t.PrimaryEviRange[newK]; ok {
		return fmt.Errorf("key %v already exists in PrimaryEviRange", newK)
	}

	e, ok := t.PrimaryEviRange[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrimaryEviRange", oldK)
	}
	e.StartEvi = &newK

	t.PrimaryEviRange[newK] = e
	delete(t.PrimaryEviRange, oldK)
	return nil
}

// GetOrCreatePrimaryEviRange retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) GetOrCreatePrimaryEviRange(
	StartEvi uint32,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange {
	key := StartEvi

	if v, ok := t.PrimaryEviRange[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrimaryEviRange(StartEvi)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrimaryEviRange got unexpected error: %v", err))
	}
	return v
}

// GetPrimaryEviRange retrieves the value with the specified key from
// the PrimaryEviRange map field of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) GetPrimaryEviRange(
	StartEvi uint32,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange {
	if t == nil {
		return nil
	}

	key := StartEvi

	if lm, ok := t.PrimaryEviRange[key]; ok {
		return lm
	}
	return nil
}

// DeletePrimaryEviRange deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) DeletePrimaryEviRange(StartEvi uint32) {
	key := StartEvi

	delete(t.PrimaryEviRange, key)
}

// AppendPrimaryEviRange appends the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange struct to the
// list PrimaryEviRange of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) AppendPrimaryEviRange(
	v *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange,
) error {
	if v.StartEvi == nil {
		return fmt.Errorf("invalid nil key received for StartEvi")
	}

	key := *v.StartEvi

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrimaryEviRange == nil {
		t.PrimaryEviRange = make(map[uint32]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange)
	}

	if _, ok := t.PrimaryEviRange[key]; ok {
		return fmt.Errorf("duplicate key for list PrimaryEviRange %v", key)
	}

	t.PrimaryEviRange[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.PrimaryEviRange {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election/algorithm/manual-alg/primary-evi-range YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange struct {
	EndEvi   *uint32 `path:"end-evi" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	StartEvi *uint32 `path:"start-evi" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) IsYANGGoStruct() {
}

// GetEndEvi retrieves the value of the leaf EndEvi from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndEvi is set, it can
// safely use t.GetEndEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndEvi == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) GetEndEvi() uint32 {
	if t == nil || t.EndEvi == nil {
		return 0
	}
	return *t.EndEvi
}

// GetStartEvi retrieves the value of the leaf StartEvi from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StartEvi is set, it can
// safely use t.GetStartEvi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StartEvi == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) GetStartEvi() uint32 {
	if t == nil || t.StartEvi == nil {
		return 0
	}
	return *t.StartEvi
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) ΛListKeyMap() (map[string]interface{}, error) {
	if t.StartEvi == nil {
		return nil, fmt.Errorf("nil value for key StartEvi")
	}

	return map[string]interface{}{
		"start-evi": *t.StartEvi,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_ManualAlg_PrimaryEviRange) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election/algorithm/preference-alg YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg struct {
	Capabilities    *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities `path:"capabilities" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	PreferenceValue *uint32                                                                                                                                            `path:"preference-value" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) IsYANGGoStruct() {
}

// GetOrCreateCapabilities retrieves the value of the Capabilities field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) GetOrCreateCapabilities() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities {
	if t.Capabilities != nil {
		return t.Capabilities
	}
	t.Capabilities = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities{}
	return t.Capabilities
}

// GetCapabilities returns the value of the Capabilities struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg. If the receiver or the field Capabilities is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) GetCapabilities() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities {
	if t != nil && t.Capabilities != nil {
		return t.Capabilities
	}
	return nil
}

// GetPreferenceValue retrieves the value of the leaf PreferenceValue from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreferenceValue is set, it can
// safely use t.GetPreferenceValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreferenceValue == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) GetPreferenceValue() uint32 {
	if t == nil || t.PreferenceValue == nil {
		return 32767
	}
	return *t.PreferenceValue
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PreferenceValue == nil {
		var v uint32 = 32767
		t.PreferenceValue = &v
	}
	t.Capabilities.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election/algorithm/preference-alg/capabilities YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities struct {
	AcDf         E_SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities_AcDf `path:"ac-df" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	NonRevertive *bool                                                                                                                                                    `path:"non-revertive" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) IsYANGGoStruct() {
}

// GetAcDf retrieves the value of the leaf AcDf from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcDf is set, it can
// safely use t.GetAcDf() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcDf == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) GetAcDf() E_SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities_AcDf {
	if t == nil || t.AcDf == 0 {
		return SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities_AcDf_include
	}
	return t.AcDf
}

// GetNonRevertive retrieves the value of the leaf NonRevertive from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NonRevertive is set, it can
// safely use t.GetNonRevertive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NonRevertive == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) GetNonRevertive() bool {
	if t == nil || t.NonRevertive == nil {
		return false
	}
	return *t.NonRevertive
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcDf == 0 {
		t.AcDf = SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities_AcDf_include
	}
	if t.NonRevertive == nil {
		var v bool = false
		t.NonRevertive = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Algorithm_PreferenceAlg_Capabilities) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election/interface-standby-signaling-on-non-df YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf struct{}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_InterfaceStandbySignalingOnNonDf) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/df-election/timers YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers struct {
	ActivationTimer *uint32 `path:"activation-timer" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers) IsYANGGoStruct() {
}

// GetActivationTimer retrieves the value of the leaf ActivationTimer from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActivationTimer is set, it can
// safely use t.GetActivationTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActivationTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers) GetActivationTimer() uint32 {
	if t == nil || t.ActivationTimer == nil {
		return 0
	}
	return *t.ActivationTimer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_DfElection_Timers) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/interface YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface struct {
	EthernetInterface *string `path:"ethernet-interface" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) IsYANGGoStruct() {
}

// GetEthernetInterface retrieves the value of the leaf EthernetInterface from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EthernetInterface is set, it can
// safely use t.GetEthernetInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EthernetInterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) GetEthernetInterface() string {
	if t == nil || t.EthernetInterface == nil {
		return ""
	}
	return *t.EthernetInterface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.EthernetInterface == nil {
		return nil, fmt.Errorf("nil value for key EthernetInterface")
	}

	return map[string]interface{}{
		"ethernet-interface": *t.EthernetInterface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Interface) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/next-hop YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop struct {
	Evi       map[uint32]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi `path:"evi" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	L3NextHop *string                                                                                                                   `path:"l3-next-hop" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) IsYANGGoStruct() {
}

// NewEvi creates a new entry in the Evi list of the
// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) NewEvi(
	Start uint32,
) (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Evi == nil {
		t.Evi = make(map[uint32]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi)
	}

	key := Start

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Evi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Evi", key)
	}

	t.Evi[key] = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi{
		Start: &Start,
	}

	return t.Evi[key], nil
}

// RenameEvi renames an entry in the list Evi within
// the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) RenameEvi(oldK, newK uint32) error {
	if _, ok := t.Evi[newK]; ok {
		return fmt.Errorf("key %v already exists in Evi", newK)
	}

	e, ok := t.Evi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Evi", oldK)
	}
	e.Start = &newK

	t.Evi[newK] = e
	delete(t.Evi, oldK)
	return nil
}

// GetOrCreateEvi retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) GetOrCreateEvi(
	Start uint32,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi {
	key := Start

	if v, ok := t.Evi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEvi(Start)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEvi got unexpected error: %v", err))
	}
	return v
}

// GetEvi retrieves the value with the specified key from
// the Evi map field of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) GetEvi(
	Start uint32,
) *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi {
	if t == nil {
		return nil
	}

	key := Start

	if lm, ok := t.Evi[key]; ok {
		return lm
	}
	return nil
}

// DeleteEvi deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) DeleteEvi(Start uint32) {
	key := Start

	delete(t.Evi, key)
}

// AppendEvi appends the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi struct to the
// list Evi of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) AppendEvi(
	v *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi,
) error {
	if v.Start == nil {
		return fmt.Errorf("invalid nil key received for Start")
	}

	key := *v.Start

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Evi == nil {
		t.Evi = make(map[uint32]*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi)
	}

	if _, ok := t.Evi[key]; ok {
		return fmt.Errorf("duplicate key for list Evi %v", key)
	}

	t.Evi[key] = v
	return nil
}

// GetL3NextHop retrieves the value of the leaf L3NextHop from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L3NextHop is set, it can
// safely use t.GetL3NextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L3NextHop == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) GetL3NextHop() string {
	if t == nil || t.L3NextHop == nil {
		return ""
	}
	return *t.L3NextHop
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Evi {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.L3NextHop == nil {
		return nil, fmt.Errorf("nil value for key L3NextHop")
	}

	return map[string]interface{}{
		"l3-next-hop": *t.L3NextHop,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/next-hop/evi YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi struct {
	Start *uint32 `path:"start" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) IsYANGGoStruct() {
}

// GetStart retrieves the value of the leaf Start from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) GetStart() uint32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Start == nil {
		return nil, fmt.Errorf("nil value for key Start")
	}

	return map[string]interface{}{
		"start": *t.Start,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_NextHop_Evi) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/routes YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes struct {
	EthernetSegment *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment `path:"ethernet-segment" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	NextHop         E_SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_NextHop        `path:"next-hop" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) IsYANGGoStruct() {
}

// GetOrCreateEthernetSegment retrieves the value of the EthernetSegment field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) GetOrCreateEthernetSegment() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment {
	if t.EthernetSegment != nil {
		return t.EthernetSegment
	}
	t.EthernetSegment = &SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment{}
	return t.EthernetSegment
}

// GetEthernetSegment returns the value of the EthernetSegment struct pointer
// from SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes. If the receiver or the field EthernetSegment is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) GetEthernetSegment() *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment {
	if t != nil && t.EthernetSegment != nil {
		return t.EthernetSegment
	}
	return nil
}

// GetNextHop retrieves the value of the leaf NextHop from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHop is set, it can
// safely use t.GetNextHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHop == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) GetNextHop() E_SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_NextHop {
	if t == nil || t.NextHop == 0 {
		return SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_NextHop_use_system_ipv4_address
	}
	return t.NextHop
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.NextHop == 0 {
		t.NextHop = SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_NextHop_use_system_ipv4_address
	}
	t.EthernetSegment.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/bgp-instance/ethernet-segment/routes/ethernet-segment YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment struct {
	OriginatingIp E_SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment_OriginatingIp `path:"originating-ip" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment) IsYANGGoStruct() {
}

// GetOriginatingIp retrieves the value of the leaf OriginatingIp from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginatingIp is set, it can
// safely use t.GetOriginatingIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginatingIp == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment) GetOriginatingIp() E_SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment_OriginatingIp {
	if t == nil || t.OriginatingIp == 0 {
		return SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment_OriginatingIp_use_system_ipv4_address
	}
	return t.OriginatingIp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.OriginatingIp == 0 {
		t.OriginatingIp = SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment_OriginatingIp_use_system_ipv4_address
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_BgpInstance_EthernetSegment_Routes_EthernetSegment) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers represents the /srl_nokia-system/system/network-instance/protocols/evpn/ethernet-segments/timers YANG schema element.
type SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers struct {
	ActivationTimer *uint32 `path:"activation-timer" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
	BootTimer       *uint32 `path:"boot-timer" module:"srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) IsYANGGoStruct() {
}

// GetActivationTimer retrieves the value of the leaf ActivationTimer from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActivationTimer is set, it can
// safely use t.GetActivationTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActivationTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) GetActivationTimer() uint32 {
	if t == nil || t.ActivationTimer == nil {
		return 3
	}
	return *t.ActivationTimer
}

// GetBootTimer retrieves the value of the leaf BootTimer from the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BootTimer is set, it can
// safely use t.GetBootTimer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BootTimer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) GetBootTimer() uint32 {
	if t == nil || t.BootTimer == nil {
		return 10
	}
	return *t.BootTimer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ActivationTimer == nil {
		var v uint32 = 3
		t.ActivationTimer = &v
	}
	if t.BootTimer == nil {
		var v uint32 = 10
		t.BootTimer = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers.
func (*SrlNokiaSystem_System_NetworkInstance_Protocols_Evpn_EthernetSegments_Timers) ΛBelongingModule() string {
	return "srl_nokia-system-network-instance-bgp-evpn-ethernet-segments"
}

// SrlNokiaSystem_System_Ntp represents the /srl_nokia-system/system/ntp YANG schema element.
type SrlNokiaSystem_System_Ntp struct {
	AdminState      E_SrlNokiaCommon_AdminState                  `path:"admin-state" module:"srl_nokia-ntp"`
	NetworkInstance *string                                      `path:"network-instance" module:"srl_nokia-ntp"`
	Server          map[string]*SrlNokiaSystem_System_Ntp_Server `path:"server" module:"srl_nokia-ntp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Ntp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Ntp) IsYANGGoStruct() {}

// NewServer creates a new entry in the Server list of the
// SrlNokiaSystem_System_Ntp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Ntp) NewServer(Address string) (*SrlNokiaSystem_System_Ntp_Server, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaSystem_System_Ntp_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &SrlNokiaSystem_System_Ntp_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// RenameServer renames an entry in the list Server within
// the SrlNokiaSystem_System_Ntp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Ntp) RenameServer(oldK, newK string) error {
	if _, ok := t.Server[newK]; ok {
		return fmt.Errorf("key %v already exists in Server", newK)
	}

	e, ok := t.Server[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Server", oldK)
	}
	e.Address = &newK

	t.Server[newK] = e
	delete(t.Server, oldK)
	return nil
}

// GetOrCreateServer retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Ntp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Ntp) GetOrCreateServer(Address string) *SrlNokiaSystem_System_Ntp_Server {
	key := Address

	if v, ok := t.Server[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServer(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServer got unexpected error: %v", err))
	}
	return v
}

// GetServer retrieves the value with the specified key from
// the Server map field of SrlNokiaSystem_System_Ntp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Ntp) GetServer(Address string) *SrlNokiaSystem_System_Ntp_Server {
	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.Server[key]; ok {
		return lm
	}
	return nil
}

// DeleteServer deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Ntp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Ntp) DeleteServer(Address string) {
	key := Address

	delete(t.Server, key)
}

// AppendServer appends the supplied SrlNokiaSystem_System_Ntp_Server struct to the
// list Server of SrlNokiaSystem_System_Ntp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Ntp_Server already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Ntp) AppendServer(v *SrlNokiaSystem_System_Ntp_Server) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key received for Address")
	}

	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaSystem_System_Ntp_Server)
	}

	if _, ok := t.Server[key]; ok {
		return fmt.Errorf("duplicate key for list Server %v", key)
	}

	t.Server[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Ntp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Ntp) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Ntp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Ntp) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Ntp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Ntp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Server {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Ntp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Ntp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Ntp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Ntp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Ntp.
func (*SrlNokiaSystem_System_Ntp) ΛBelongingModule() string {
	return "srl_nokia-ntp"
}

// SrlNokiaSystem_System_Ntp_Server represents the /srl_nokia-system/system/ntp/server YANG schema element.
type SrlNokiaSystem_System_Ntp_Server struct {
	Address *string `path:"address" module:"srl_nokia-ntp"`
	Iburst  *bool   `path:"iburst" module:"srl_nokia-ntp"`
	Prefer  *bool   `path:"prefer" module:"srl_nokia-ntp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Ntp_Server implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Ntp_Server) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the SrlNokiaSystem_System_Ntp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Ntp_Server) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIburst retrieves the value of the leaf Iburst from the SrlNokiaSystem_System_Ntp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Iburst is set, it can
// safely use t.GetIburst() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Iburst == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Ntp_Server) GetIburst() bool {
	if t == nil || t.Iburst == nil {
		return false
	}
	return *t.Iburst
}

// GetPrefer retrieves the value of the leaf Prefer from the SrlNokiaSystem_System_Ntp_Server
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefer is set, it can
// safely use t.GetPrefer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefer == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Ntp_Server) GetPrefer() bool {
	if t == nil || t.Prefer == nil {
		return false
	}
	return *t.Prefer
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Ntp_Server
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Ntp_Server) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Iburst == nil {
		var v bool = false
		t.Iburst = &v
	}
	if t.Prefer == nil {
		var v bool = false
		t.Prefer = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Ntp_Server struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Ntp_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Ntp_Server) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Ntp_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Ntp_Server) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Ntp_Server) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Ntp_Server.
func (*SrlNokiaSystem_System_Ntp_Server) ΛBelongingModule() string {
	return "srl_nokia-ntp"
}

// SrlNokiaSystem_System_P4RtServer represents the /srl_nokia-system/system/p4rt-server YANG schema element.
type SrlNokiaSystem_System_P4RtServer struct {
	AdminState      E_SrlNokiaCommon_AdminState                                  `path:"admin-state" module:"srl_nokia-p4rt-server"`
	NetworkInstance map[string]*SrlNokiaSystem_System_P4RtServer_NetworkInstance `path:"network-instance" module:"srl_nokia-p4rt-server"`
	RateLimit       *uint16                                                      `path:"rate-limit" module:"srl_nokia-p4rt-server"`
	SessionLimit    *uint16                                                      `path:"session-limit" module:"srl_nokia-p4rt-server"`
	Timeout         *uint16                                                      `path:"timeout" module:"srl_nokia-p4rt-server"`
	TraceOptions    []E_SrlNokiaSystem_System_P4RtServer_TraceOptions            `path:"trace-options" module:"srl_nokia-p4rt-server"`
	UnixSocket      *SrlNokiaSystem_System_P4RtServer_UnixSocket                 `path:"unix-socket" module:"srl_nokia-p4rt-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_P4RtServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_P4RtServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_P4RtServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_P4RtServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_P4RtServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_P4RtServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_P4RtServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_P4RtServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_P4RtServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_P4RtServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_P4RtServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_P4RtServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_P4RtServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_P4RtServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_P4RtServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_P4RtServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_P4RtServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_P4RtServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_P4RtServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_P4RtServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_P4RtServer) AppendNetworkInstance(
	v *SrlNokiaSystem_System_P4RtServer_NetworkInstance,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_P4RtServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetOrCreateUnixSocket retrieves the value of the UnixSocket field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_P4RtServer) GetOrCreateUnixSocket() *SrlNokiaSystem_System_P4RtServer_UnixSocket {
	if t.UnixSocket != nil {
		return t.UnixSocket
	}
	t.UnixSocket = &SrlNokiaSystem_System_P4RtServer_UnixSocket{}
	return t.UnixSocket
}

// GetUnixSocket returns the value of the UnixSocket struct pointer
// from SrlNokiaSystem_System_P4RtServer. If the receiver or the field UnixSocket is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_P4RtServer) GetUnixSocket() *SrlNokiaSystem_System_P4RtServer_UnixSocket {
	if t != nil && t.UnixSocket != nil {
		return t.UnixSocket
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_P4RtServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetRateLimit retrieves the value of the leaf RateLimit from the SrlNokiaSystem_System_P4RtServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimit is set, it can
// safely use t.GetRateLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer) GetRateLimit() uint16 {
	if t == nil || t.RateLimit == nil {
		return 60
	}
	return *t.RateLimit
}

// GetSessionLimit retrieves the value of the leaf SessionLimit from the SrlNokiaSystem_System_P4RtServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionLimit is set, it can
// safely use t.GetSessionLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer) GetSessionLimit() uint16 {
	if t == nil || t.SessionLimit == nil {
		return 20
	}
	return *t.SessionLimit
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_P4RtServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 7200
	}
	return *t.Timeout
}

// GetTraceOptions retrieves the value of the leaf TraceOptions from the SrlNokiaSystem_System_P4RtServer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TraceOptions is set, it can
// safely use t.GetTraceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TraceOptions == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer) GetTraceOptions() []E_SrlNokiaSystem_System_P4RtServer_TraceOptions {
	if t == nil || t.TraceOptions == nil {
		return nil
	}
	return t.TraceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_P4RtServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_P4RtServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.RateLimit == nil {
		var v uint16 = 60
		t.RateLimit = &v
	}
	if t.SessionLimit == nil {
		var v uint16 = 20
		t.SessionLimit = &v
	}
	if t.Timeout == nil {
		var v uint16 = 7200
		t.Timeout = &v
	}
	t.UnixSocket.PopulateDefaults()
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_P4RtServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_P4RtServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_P4RtServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_P4RtServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_P4RtServer.
func (*SrlNokiaSystem_System_P4RtServer) ΛBelongingModule() string {
	return "srl_nokia-p4rt-server"
}

// SrlNokiaSystem_System_P4RtServer_NetworkInstance represents the /srl_nokia-system/system/p4rt-server/network-instance YANG schema element.
type SrlNokiaSystem_System_P4RtServer_NetworkInstance struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-p4rt-server"`
	Name              *string                     `path:"name" module:"srl_nokia-p4rt-server"`
	Port              *uint16                     `path:"port" module:"srl_nokia-p4rt-server"`
	SourceAddress     []string                    `path:"source-address" module:"srl_nokia-p4rt-server"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-p4rt-server"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-p4rt-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_P4RtServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_P4RtServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_P4RtServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_P4RtServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_P4RtServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 9559
	}
	return *t.Port
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_P4RtServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return nil
	}
	return t.SourceAddress
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_P4RtServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_P4RtServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_P4RtServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.Port == nil {
		var v uint16 = 9559
		t.Port = &v
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_P4RtServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_P4RtServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_P4RtServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_P4RtServer_NetworkInstance.
func (*SrlNokiaSystem_System_P4RtServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-p4rt-server"
}

// SrlNokiaSystem_System_P4RtServer_UnixSocket represents the /srl_nokia-system/system/p4rt-server/unix-socket YANG schema element.
type SrlNokiaSystem_System_P4RtServer_UnixSocket struct {
	AdminState        E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-p4rt-server"`
	TlsProfile        *string                     `path:"tls-profile" module:"srl_nokia-p4rt-server"`
	UseAuthentication *bool                       `path:"use-authentication" module:"srl_nokia-p4rt-server"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_P4RtServer_UnixSocket implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_P4RtServer_UnixSocket) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_P4RtServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_UnixSocket) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetTlsProfile retrieves the value of the leaf TlsProfile from the SrlNokiaSystem_System_P4RtServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TlsProfile is set, it can
// safely use t.GetTlsProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TlsProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_UnixSocket) GetTlsProfile() string {
	if t == nil || t.TlsProfile == nil {
		return ""
	}
	return *t.TlsProfile
}

// GetUseAuthentication retrieves the value of the leaf UseAuthentication from the SrlNokiaSystem_System_P4RtServer_UnixSocket
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UseAuthentication is set, it can
// safely use t.GetUseAuthentication() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UseAuthentication == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_P4RtServer_UnixSocket) GetUseAuthentication() bool {
	if t == nil || t.UseAuthentication == nil {
		return true
	}
	return *t.UseAuthentication
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_P4RtServer_UnixSocket
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_P4RtServer_UnixSocket) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.UseAuthentication == nil {
		var v bool = true
		t.UseAuthentication = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_P4RtServer_UnixSocket) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_P4RtServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_P4RtServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_P4RtServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_P4RtServer_UnixSocket.
func (*SrlNokiaSystem_System_P4RtServer_UnixSocket) ΛBelongingModule() string {
	return "srl_nokia-p4rt-server"
}

// SrlNokiaSystem_System_RaGuardPolicy represents the /srl_nokia-system/system/ra-guard-policy YANG schema element.
type SrlNokiaSystem_System_RaGuardPolicy struct {
	Action             E_SrlNokiaSystem_System_RaGuardPolicy_Action           `path:"action" module:"srl_nokia-ra_guard"`
	AdvertisePrefixSet *string                                                `path:"advertise-prefix-set" module:"srl_nokia-ra_guard"`
	HopLimit           *uint8                                                 `path:"hop-limit" module:"srl_nokia-ra_guard"`
	ManagedConfigFlag  *bool                                                  `path:"managed-config-flag" module:"srl_nokia-ra_guard"`
	Name               *string                                                `path:"name" module:"srl_nokia-ra_guard"`
	OtherConfigFlag    *bool                                                  `path:"other-config-flag" module:"srl_nokia-ra_guard"`
	RouterPreference   E_SrlNokiaSystem_System_RaGuardPolicy_RouterPreference `path:"router-preference" module:"srl_nokia-ra_guard"`
	SourcePrefixSet    *string                                                `path:"source-prefix-set" module:"srl_nokia-ra_guard"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_RaGuardPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_RaGuardPolicy) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetAction() E_SrlNokiaSystem_System_RaGuardPolicy_Action {
	if t == nil || t.Action == 0 {
		return SrlNokiaSystem_System_RaGuardPolicy_Action_discard
	}
	return t.Action
}

// GetAdvertisePrefixSet retrieves the value of the leaf AdvertisePrefixSet from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvertisePrefixSet is set, it can
// safely use t.GetAdvertisePrefixSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvertisePrefixSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetAdvertisePrefixSet() string {
	if t == nil || t.AdvertisePrefixSet == nil {
		return ""
	}
	return *t.AdvertisePrefixSet
}

// GetHopLimit retrieves the value of the leaf HopLimit from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopLimit is set, it can
// safely use t.GetHopLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetHopLimit() uint8 {
	if t == nil || t.HopLimit == nil {
		return 0
	}
	return *t.HopLimit
}

// GetManagedConfigFlag retrieves the value of the leaf ManagedConfigFlag from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ManagedConfigFlag is set, it can
// safely use t.GetManagedConfigFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ManagedConfigFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetManagedConfigFlag() bool {
	if t == nil || t.ManagedConfigFlag == nil {
		return false
	}
	return *t.ManagedConfigFlag
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOtherConfigFlag retrieves the value of the leaf OtherConfigFlag from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OtherConfigFlag is set, it can
// safely use t.GetOtherConfigFlag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OtherConfigFlag == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetOtherConfigFlag() bool {
	if t == nil || t.OtherConfigFlag == nil {
		return false
	}
	return *t.OtherConfigFlag
}

// GetRouterPreference retrieves the value of the leaf RouterPreference from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterPreference is set, it can
// safely use t.GetRouterPreference() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterPreference == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetRouterPreference() E_SrlNokiaSystem_System_RaGuardPolicy_RouterPreference {
	if t == nil || t.RouterPreference == 0 {
		return 0
	}
	return t.RouterPreference
}

// GetSourcePrefixSet retrieves the value of the leaf SourcePrefixSet from the SrlNokiaSystem_System_RaGuardPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourcePrefixSet is set, it can
// safely use t.GetSourcePrefixSet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourcePrefixSet == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_RaGuardPolicy) GetSourcePrefixSet() string {
	if t == nil || t.SourcePrefixSet == nil {
		return ""
	}
	return *t.SourcePrefixSet
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_RaGuardPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_RaGuardPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = SrlNokiaSystem_System_RaGuardPolicy_Action_discard
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_RaGuardPolicy struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_RaGuardPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_RaGuardPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_RaGuardPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_RaGuardPolicy) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_RaGuardPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_RaGuardPolicy.
func (*SrlNokiaSystem_System_RaGuardPolicy) ΛBelongingModule() string {
	return "srl_nokia-ra_guard"
}

// SrlNokiaSystem_System_Sflow represents the /srl_nokia-system/system/sflow YANG schema element.
type SrlNokiaSystem_System_Sflow struct {
	AdminState    E_SrlNokiaCommon_AdminState                       `path:"admin-state" module:"srl_nokia-sflow"`
	Collector     map[uint16]*SrlNokiaSystem_System_Sflow_Collector `path:"collector" module:"srl_nokia-sflow"`
	SampleRate    *uint32                                           `path:"sample-rate" module:"srl_nokia-sflow"`
	SampleSize    *uint16                                           `path:"sample-size" module:"srl_nokia-sflow"`
	SourceAddress *string                                           `path:"source-address" module:"srl_nokia-sflow"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sflow) IsYANGGoStruct() {}

// NewCollector creates a new entry in the Collector list of the
// SrlNokiaSystem_System_Sflow struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sflow) NewCollector(CollectorId uint16) (*SrlNokiaSystem_System_Sflow_Collector, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Collector == nil {
		t.Collector = make(map[uint16]*SrlNokiaSystem_System_Sflow_Collector)
	}

	key := CollectorId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Collector[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Collector", key)
	}

	t.Collector[key] = &SrlNokiaSystem_System_Sflow_Collector{
		CollectorId: &CollectorId,
	}

	return t.Collector[key], nil
}

// RenameCollector renames an entry in the list Collector within
// the SrlNokiaSystem_System_Sflow struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sflow) RenameCollector(oldK, newK uint16) error {
	if _, ok := t.Collector[newK]; ok {
		return fmt.Errorf("key %v already exists in Collector", newK)
	}

	e, ok := t.Collector[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Collector", oldK)
	}
	e.CollectorId = &newK

	t.Collector[newK] = e
	delete(t.Collector, oldK)
	return nil
}

// GetOrCreateCollector retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sflow. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sflow) GetOrCreateCollector(CollectorId uint16) *SrlNokiaSystem_System_Sflow_Collector {
	key := CollectorId

	if v, ok := t.Collector[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCollector(CollectorId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCollector got unexpected error: %v", err))
	}
	return v
}

// GetCollector retrieves the value with the specified key from
// the Collector map field of SrlNokiaSystem_System_Sflow. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sflow) GetCollector(CollectorId uint16) *SrlNokiaSystem_System_Sflow_Collector {
	if t == nil {
		return nil
	}

	key := CollectorId

	if lm, ok := t.Collector[key]; ok {
		return lm
	}
	return nil
}

// DeleteCollector deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sflow. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sflow) DeleteCollector(CollectorId uint16) {
	key := CollectorId

	delete(t.Collector, key)
}

// AppendCollector appends the supplied SrlNokiaSystem_System_Sflow_Collector struct to the
// list Collector of SrlNokiaSystem_System_Sflow. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sflow_Collector already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sflow) AppendCollector(v *SrlNokiaSystem_System_Sflow_Collector) error {
	if v.CollectorId == nil {
		return fmt.Errorf("invalid nil key received for CollectorId")
	}

	key := *v.CollectorId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Collector == nil {
		t.Collector = make(map[uint16]*SrlNokiaSystem_System_Sflow_Collector)
	}

	if _, ok := t.Collector[key]; ok {
		return fmt.Errorf("duplicate key for list Collector %v", key)
	}

	t.Collector[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetSampleRate retrieves the value of the leaf SampleRate from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SampleRate is set, it can
// safely use t.GetSampleRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SampleRate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetSampleRate() uint32 {
	if t == nil || t.SampleRate == nil {
		return 10000
	}
	return *t.SampleRate
}

// GetSampleSize retrieves the value of the leaf SampleSize from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SampleSize is set, it can
// safely use t.GetSampleSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SampleSize == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetSampleSize() uint16 {
	if t == nil || t.SampleSize == nil {
		return 256
	}
	return *t.SampleSize
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Sflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.SampleRate == nil {
		var v uint32 = 10000
		t.SampleRate = &v
	}
	if t.SampleSize == nil {
		var v uint16 = 256
		t.SampleSize = &v
	}
	for _, e := range t.Collector {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sflow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sflow.
func (*SrlNokiaSystem_System_Sflow) ΛBelongingModule() string {
	return "srl_nokia-sflow"
}

// SrlNokiaSystem_System_Sflow_Collector represents the /srl_nokia-system/system/sflow/collector YANG schema element.
type SrlNokiaSystem_System_Sflow_Collector struct {
	CollectorAddress *string `path:"collector-address" module:"srl_nokia-sflow"`
	CollectorId      *uint16 `path:"collector-id" module:"srl_nokia-sflow"`
	NetworkInstance  *string `path:"network-instance" module:"srl_nokia-sflow"`
	Port             *uint16 `path:"port" module:"srl_nokia-sflow"`
	SourceAddress    *string `path:"source-address" module:"srl_nokia-sflow"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sflow_Collector implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sflow_Collector) IsYANGGoStruct() {}

// GetCollectorAddress retrieves the value of the leaf CollectorAddress from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectorAddress is set, it can
// safely use t.GetCollectorAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectorAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetCollectorAddress() string {
	if t == nil || t.CollectorAddress == nil {
		return ""
	}
	return *t.CollectorAddress
}

// GetCollectorId retrieves the value of the leaf CollectorId from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectorId is set, it can
// safely use t.GetCollectorId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectorId == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetCollectorId() uint16 {
	if t == nil || t.CollectorId == nil {
		return 0
	}
	return *t.CollectorId
}

// GetNetworkInstance retrieves the value of the leaf NetworkInstance from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkInstance is set, it can
// safely use t.GetNetworkInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkInstance == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetNetworkInstance() string {
	if t == nil || t.NetworkInstance == nil {
		return ""
	}
	return *t.NetworkInstance
}

// GetPort retrieves the value of the leaf Port from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Port is set, it can
// safely use t.GetPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Port == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetPort() uint16 {
	if t == nil || t.Port == nil {
		return 6343
	}
	return *t.Port
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Sflow_Collector
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sflow_Collector) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sflow_Collector
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sflow_Collector) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Port == nil {
		var v uint16 = 6343
		t.Port = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sflow_Collector struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛListKeyMap() (map[string]interface{}, error) {
	if t.CollectorId == nil {
		return nil, fmt.Errorf("nil value for key CollectorId")
	}

	return map[string]interface{}{
		"collector-id": *t.CollectorId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sflow_Collector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow_Collector) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sflow_Collector.
func (*SrlNokiaSystem_System_Sflow_Collector) ΛBelongingModule() string {
	return "srl_nokia-sflow"
}

// SrlNokiaSystem_System_Snmp represents the /srl_nokia-system/system/snmp YANG schema element.
type SrlNokiaSystem_System_Snmp struct {
	Community       *string                                                `path:"community" module:"srl_nokia-snmp"`
	NetworkInstance map[string]*SrlNokiaSystem_System_Snmp_NetworkInstance `path:"network-instance" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Snmp) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_Snmp_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Snmp_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_Snmp_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_Snmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Snmp) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Snmp) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_Snmp_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_Snmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Snmp) GetNetworkInstance(Name string) *SrlNokiaSystem_System_Snmp_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Snmp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Snmp) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_Snmp_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_Snmp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Snmp_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Snmp) AppendNetworkInstance(v *SrlNokiaSystem_System_Snmp_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Snmp_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// GetCommunity retrieves the value of the leaf Community from the SrlNokiaSystem_System_Snmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Community is set, it can
// safely use t.GetCommunity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Community == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp) GetCommunity() string {
	if t == nil || t.Community == nil {
		return ""
	}
	return *t.Community
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp.
func (*SrlNokiaSystem_System_Snmp) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_Snmp_NetworkInstance represents the /srl_nokia-system/system/snmp/network-instance YANG schema element.
type SrlNokiaSystem_System_Snmp_NetworkInstance struct {
	AdminState    E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-snmp"`
	Name          *string                     `path:"name" module:"srl_nokia-snmp"`
	SourceAddress []string                    `path:"source-address" module:"srl_nokia-snmp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Snmp_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Snmp_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Snmp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Snmp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_Snmp_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return []string{"::"}
	}
	return t.SourceAddress
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Snmp_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SourceAddress == nil {
		t.SourceAddress = []string{"::"}
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Snmp_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Snmp_NetworkInstance.
func (*SrlNokiaSystem_System_Snmp_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-snmp"
}

// SrlNokiaSystem_System_SshServer represents the /srl_nokia-system/system/ssh-server YANG schema element.
type SrlNokiaSystem_System_SshServer struct {
	NetworkInstance map[string]*SrlNokiaSystem_System_SshServer_NetworkInstance `path:"network-instance" module:"srl_nokia-ssh"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_SshServer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_SshServer) IsYANGGoStruct() {}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_SshServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_SshServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_SshServer_NetworkInstance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_SshServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_SshServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// RenameNetworkInstance renames an entry in the list NetworkInstance within
// the SrlNokiaSystem_System_SshServer struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_SshServer) RenameNetworkInstance(oldK, newK string) error {
	if _, ok := t.NetworkInstance[newK]; ok {
		return fmt.Errorf("key %v already exists in NetworkInstance", newK)
	}

	e, ok := t.NetworkInstance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NetworkInstance", oldK)
	}
	e.Name = &newK

	t.NetworkInstance[newK] = e
	delete(t.NetworkInstance, oldK)
	return nil
}

// GetOrCreateNetworkInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_SshServer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_SshServer) GetOrCreateNetworkInstance(Name string) *SrlNokiaSystem_System_SshServer_NetworkInstance {
	key := Name

	if v, ok := t.NetworkInstance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNetworkInstance(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNetworkInstance got unexpected error: %v", err))
	}
	return v
}

// GetNetworkInstance retrieves the value with the specified key from
// the NetworkInstance map field of SrlNokiaSystem_System_SshServer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_SshServer) GetNetworkInstance(Name string) *SrlNokiaSystem_System_SshServer_NetworkInstance {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.NetworkInstance[key]; ok {
		return lm
	}
	return nil
}

// DeleteNetworkInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_SshServer. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_SshServer) DeleteNetworkInstance(Name string) {
	key := Name

	delete(t.NetworkInstance, key)
}

// AppendNetworkInstance appends the supplied SrlNokiaSystem_System_SshServer_NetworkInstance struct to the
// list NetworkInstance of SrlNokiaSystem_System_SshServer. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_SshServer_NetworkInstance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_SshServer) AppendNetworkInstance(v *SrlNokiaSystem_System_SshServer_NetworkInstance) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_SshServer_NetworkInstance)
	}

	if _, ok := t.NetworkInstance[key]; ok {
		return fmt.Errorf("duplicate key for list NetworkInstance %v", key)
	}

	t.NetworkInstance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_SshServer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_SshServer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.NetworkInstance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_SshServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_SshServer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_SshServer.
func (*SrlNokiaSystem_System_SshServer) ΛBelongingModule() string {
	return "srl_nokia-ssh"
}

// SrlNokiaSystem_System_SshServer_NetworkInstance represents the /srl_nokia-system/system/ssh-server/network-instance YANG schema element.
type SrlNokiaSystem_System_SshServer_NetworkInstance struct {
	AdminState    E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-ssh"`
	Name          *string                     `path:"name" module:"srl_nokia-ssh"`
	RateLimit     *uint16                     `path:"rate-limit" module:"srl_nokia-ssh"`
	SourceAddress []string                    `path:"source-address" module:"srl_nokia-ssh"`
	Timeout       *uint16                     `path:"timeout" module:"srl_nokia-ssh"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_SshServer_NetworkInstance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_SshServer_NetworkInstance) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return 0
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRateLimit retrieves the value of the leaf RateLimit from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RateLimit is set, it can
// safely use t.GetRateLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RateLimit == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetRateLimit() uint16 {
	if t == nil || t.RateLimit == nil {
		return 20
	}
	return *t.RateLimit
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetSourceAddress() []string {
	if t == nil || t.SourceAddress == nil {
		return nil
	}
	return t.SourceAddress
}

// GetTimeout retrieves the value of the leaf Timeout from the SrlNokiaSystem_System_SshServer_NetworkInstance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) GetTimeout() uint16 {
	if t == nil || t.Timeout == nil {
		return 0
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_SshServer_NetworkInstance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RateLimit == nil {
		var v uint16 = 20
		t.RateLimit = &v
	}
	if t.Timeout == nil {
		var v uint16 = 0
		t.Timeout = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_SshServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_SshServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_SshServer_NetworkInstance.
func (*SrlNokiaSystem_System_SshServer_NetworkInstance) ΛBelongingModule() string {
	return "srl_nokia-ssh"
}

// SrlNokiaSystem_System_Sync represents the /srl_nokia-system/system/sync YANG schema element.
type SrlNokiaSystem_System_Sync struct {
	FreqClock      *SrlNokiaSystem_System_Sync_FreqClock      `path:"freq-clock" module:"srl_nokia-sync"`
	FreqReferences *SrlNokiaSystem_System_Sync_FreqReferences `path:"freq-references" module:"srl_nokia-sync"`
	OnePps         *SrlNokiaSystem_System_Sync_OnePps         `path:"one-pps" module:"srl_nokia-sync"`
	Ptp            *SrlNokiaSystem_System_Sync_Ptp            `path:"ptp" module:"srl_nokia-sync"`
	TimeClock      *SrlNokiaSystem_System_Sync_TimeClock      `path:"time-clock" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync) IsYANGGoStruct() {}

// GetOrCreateFreqClock retrieves the value of the FreqClock field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateFreqClock() *SrlNokiaSystem_System_Sync_FreqClock {
	if t.FreqClock != nil {
		return t.FreqClock
	}
	t.FreqClock = &SrlNokiaSystem_System_Sync_FreqClock{}
	return t.FreqClock
}

// GetOrCreateFreqReferences retrieves the value of the FreqReferences field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateFreqReferences() *SrlNokiaSystem_System_Sync_FreqReferences {
	if t.FreqReferences != nil {
		return t.FreqReferences
	}
	t.FreqReferences = &SrlNokiaSystem_System_Sync_FreqReferences{}
	return t.FreqReferences
}

// GetOrCreateOnePps retrieves the value of the OnePps field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateOnePps() *SrlNokiaSystem_System_Sync_OnePps {
	if t.OnePps != nil {
		return t.OnePps
	}
	t.OnePps = &SrlNokiaSystem_System_Sync_OnePps{}
	return t.OnePps
}

// GetOrCreatePtp retrieves the value of the Ptp field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreatePtp() *SrlNokiaSystem_System_Sync_Ptp {
	if t.Ptp != nil {
		return t.Ptp
	}
	t.Ptp = &SrlNokiaSystem_System_Sync_Ptp{}
	return t.Ptp
}

// GetOrCreateTimeClock retrieves the value of the TimeClock field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync) GetOrCreateTimeClock() *SrlNokiaSystem_System_Sync_TimeClock {
	if t.TimeClock != nil {
		return t.TimeClock
	}
	t.TimeClock = &SrlNokiaSystem_System_Sync_TimeClock{}
	return t.TimeClock
}

// GetFreqClock returns the value of the FreqClock struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field FreqClock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetFreqClock() *SrlNokiaSystem_System_Sync_FreqClock {
	if t != nil && t.FreqClock != nil {
		return t.FreqClock
	}
	return nil
}

// GetFreqReferences returns the value of the FreqReferences struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field FreqReferences is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetFreqReferences() *SrlNokiaSystem_System_Sync_FreqReferences {
	if t != nil && t.FreqReferences != nil {
		return t.FreqReferences
	}
	return nil
}

// GetOnePps returns the value of the OnePps struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field OnePps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetOnePps() *SrlNokiaSystem_System_Sync_OnePps {
	if t != nil && t.OnePps != nil {
		return t.OnePps
	}
	return nil
}

// GetPtp returns the value of the Ptp struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field Ptp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetPtp() *SrlNokiaSystem_System_Sync_Ptp {
	if t != nil && t.Ptp != nil {
		return t.Ptp
	}
	return nil
}

// GetTimeClock returns the value of the TimeClock struct pointer
// from SrlNokiaSystem_System_Sync. If the receiver or the field TimeClock is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync) GetTimeClock() *SrlNokiaSystem_System_Sync_TimeClock {
	if t != nil && t.TimeClock != nil {
		return t.TimeClock
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FreqClock.PopulateDefaults()
	t.FreqReferences.PopulateDefaults()
	t.OnePps.PopulateDefaults()
	t.Ptp.PopulateDefaults()
	t.TimeClock.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync.
func (*SrlNokiaSystem_System_Sync) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_FreqClock represents the /srl_nokia-system/system/sync/freq-clock YANG schema element.
type SrlNokiaSystem_System_Sync_FreqClock struct {
	NetworkType      E_SrlNokiaSystem_System_Sync_FreqClock_NetworkType `path:"network-type" module:"srl_nokia-sync"`
	QlInputThreshold E_SrlNokiaSyncTypes_SettableQlValues               `path:"ql-input-threshold" module:"srl_nokia-sync"`
	QlSelection      *bool                                              `path:"ql-selection" module:"srl_nokia-sync"`
	Revert           *bool                                              `path:"revert" module:"srl_nokia-sync"`
	WaitToRestore    *int8                                              `path:"wait-to-restore" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_FreqClock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_FreqClock) IsYANGGoStruct() {}

// GetNetworkType retrieves the value of the leaf NetworkType from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkType is set, it can
// safely use t.GetNetworkType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkType == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetNetworkType() E_SrlNokiaSystem_System_Sync_FreqClock_NetworkType {
	if t == nil || t.NetworkType == 0 {
		return SrlNokiaSystem_System_Sync_FreqClock_NetworkType_sonet
	}
	return t.NetworkType
}

// GetQlInputThreshold retrieves the value of the leaf QlInputThreshold from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QlInputThreshold is set, it can
// safely use t.GetQlInputThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QlInputThreshold == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetQlInputThreshold() E_SrlNokiaSyncTypes_SettableQlValues {
	if t == nil || t.QlInputThreshold == 0 {
		return SrlNokiaSyncTypes_SettableQlValues_unused
	}
	return t.QlInputThreshold
}

// GetQlSelection retrieves the value of the leaf QlSelection from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QlSelection is set, it can
// safely use t.GetQlSelection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QlSelection == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetQlSelection() bool {
	if t == nil || t.QlSelection == nil {
		return false
	}
	return *t.QlSelection
}

// GetRevert retrieves the value of the leaf Revert from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Revert is set, it can
// safely use t.GetRevert() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Revert == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetRevert() bool {
	if t == nil || t.Revert == nil {
		return false
	}
	return *t.Revert
}

// GetWaitToRestore retrieves the value of the leaf WaitToRestore from the SrlNokiaSystem_System_Sync_FreqClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WaitToRestore is set, it can
// safely use t.GetWaitToRestore() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WaitToRestore == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqClock) GetWaitToRestore() int8 {
	if t == nil || t.WaitToRestore == nil {
		return 5
	}
	return *t.WaitToRestore
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_FreqClock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_FreqClock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.NetworkType == 0 {
		t.NetworkType = SrlNokiaSystem_System_Sync_FreqClock_NetworkType_sonet
	}
	if t.QlInputThreshold == 0 {
		t.QlInputThreshold = SrlNokiaSyncTypes_SettableQlValues_unused
	}
	if t.QlSelection == nil {
		var v bool = false
		t.QlSelection = &v
	}
	if t.Revert == nil {
		var v bool = false
		t.Revert = &v
	}
	if t.WaitToRestore == nil {
		var v int8 = 5
		t.WaitToRestore = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqClock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_FreqClock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqClock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_FreqClock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_FreqClock.
func (*SrlNokiaSystem_System_Sync_FreqClock) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_FreqReferences represents the /srl_nokia-system/system/sync/freq-references YANG schema element.
type SrlNokiaSystem_System_Sync_FreqReferences struct {
	Instance map[uint8]*SrlNokiaSystem_System_Sync_FreqReferences_Instance `path:"instance" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_FreqReferences implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_FreqReferences) IsYANGGoStruct() {}

// NewInstance creates a new entry in the Instance list of the
// SrlNokiaSystem_System_Sync_FreqReferences struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) NewInstance(InstanceNumber uint8) (*SrlNokiaSystem_System_Sync_FreqReferences_Instance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint8]*SrlNokiaSystem_System_Sync_FreqReferences_Instance)
	}

	key := InstanceNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &SrlNokiaSystem_System_Sync_FreqReferences_Instance{
		InstanceNumber: &InstanceNumber,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the SrlNokiaSystem_System_Sync_FreqReferences struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) RenameInstance(oldK, newK uint8) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.InstanceNumber = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_FreqReferences. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) GetOrCreateInstance(InstanceNumber uint8) *SrlNokiaSystem_System_Sync_FreqReferences_Instance {
	key := InstanceNumber

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(InstanceNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of SrlNokiaSystem_System_Sync_FreqReferences. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) GetInstance(InstanceNumber uint8) *SrlNokiaSystem_System_Sync_FreqReferences_Instance {
	if t == nil {
		return nil
	}

	key := InstanceNumber

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_FreqReferences. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) DeleteInstance(InstanceNumber uint8) {
	key := InstanceNumber

	delete(t.Instance, key)
}

// AppendInstance appends the supplied SrlNokiaSystem_System_Sync_FreqReferences_Instance struct to the
// list Instance of SrlNokiaSystem_System_Sync_FreqReferences. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sync_FreqReferences_Instance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) AppendInstance(
	v *SrlNokiaSystem_System_Sync_FreqReferences_Instance,
) error {
	if v.InstanceNumber == nil {
		return fmt.Errorf("invalid nil key received for InstanceNumber")
	}

	key := *v.InstanceNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint8]*SrlNokiaSystem_System_Sync_FreqReferences_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_FreqReferences
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Instance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_FreqReferences"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_FreqReferences) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_FreqReferences.
func (*SrlNokiaSystem_System_Sync_FreqReferences) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_FreqReferences_Instance represents the /srl_nokia-system/system/sync/freq-references/instance YANG schema element.
type SrlNokiaSystem_System_Sync_FreqReferences_Instance struct {
	InstanceNumber      *uint8                               `path:"instance-number" module:"srl_nokia-sync"`
	Priority            *uint8                               `path:"priority" module:"srl_nokia-sync"`
	QlOverride          E_SrlNokiaSyncTypes_SettableQlValues `path:"ql-override" module:"srl_nokia-sync"`
	UnderlyingInterface *string                              `path:"underlying-interface" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_FreqReferences_Instance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_FreqReferences_Instance) IsYANGGoStruct() {}

// GetInstanceNumber retrieves the value of the leaf InstanceNumber from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceNumber is set, it can
// safely use t.GetInstanceNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetInstanceNumber() uint8 {
	if t == nil || t.InstanceNumber == nil {
		return 0
	}
	return *t.InstanceNumber
}

// GetPriority retrieves the value of the leaf Priority from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// GetQlOverride retrieves the value of the leaf QlOverride from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QlOverride is set, it can
// safely use t.GetQlOverride() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QlOverride == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetQlOverride() E_SrlNokiaSyncTypes_SettableQlValues {
	if t == nil || t.QlOverride == 0 {
		return SrlNokiaSyncTypes_SettableQlValues_unused
	}
	return t.QlOverride
}

// GetUnderlyingInterface retrieves the value of the leaf UnderlyingInterface from the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnderlyingInterface is set, it can
// safely use t.GetUnderlyingInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnderlyingInterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) GetUnderlyingInterface() string {
	if t == nil || t.UnderlyingInterface == nil {
		return ""
	}
	return *t.UnderlyingInterface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_FreqReferences_Instance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Priority == nil {
		var v uint8 = 0
		t.Priority = &v
	}
	if t.QlOverride == 0 {
		t.QlOverride = SrlNokiaSyncTypes_SettableQlValues_unused
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sync_FreqReferences_Instance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceNumber == nil {
		return nil, fmt.Errorf("nil value for key InstanceNumber")
	}

	return map[string]interface{}{
		"instance-number": *t.InstanceNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_FreqReferences_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_FreqReferences_Instance.
func (*SrlNokiaSystem_System_Sync_FreqReferences_Instance) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_OnePps represents the /srl_nokia-system/system/sync/one-pps YANG schema element.
type SrlNokiaSystem_System_Sync_OnePps struct {
	AdminState E_SrlNokiaCommon_AdminState `path:"admin-state" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_OnePps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_OnePps) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sync_OnePps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_OnePps) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_OnePps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_OnePps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_OnePps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_OnePps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_OnePps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_OnePps) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_OnePps.
func (*SrlNokiaSystem_System_Sync_OnePps) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp represents the /srl_nokia-system/system/sync/ptp YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp struct {
	Instance   map[uint32]*SrlNokiaSystem_System_Sync_Ptp_Instance `path:"instance" module:"srl_nokia-sync"`
	PtpProfile E_SrlNokiaSystem_System_Sync_Ptp_PtpProfile         `path:"ptp-profile" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp) IsYANGGoStruct() {}

// NewInstance creates a new entry in the Instance list of the
// SrlNokiaSystem_System_Sync_Ptp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sync_Ptp) NewInstance(InstanceIndex uint32) (*SrlNokiaSystem_System_Sync_Ptp_Instance, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint32]*SrlNokiaSystem_System_Sync_Ptp_Instance)
	}

	key := InstanceIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Instance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Instance", key)
	}

	t.Instance[key] = &SrlNokiaSystem_System_Sync_Ptp_Instance{
		InstanceIndex: &InstanceIndex,
	}

	return t.Instance[key], nil
}

// RenameInstance renames an entry in the list Instance within
// the SrlNokiaSystem_System_Sync_Ptp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sync_Ptp) RenameInstance(oldK, newK uint32) error {
	if _, ok := t.Instance[newK]; ok {
		return fmt.Errorf("key %v already exists in Instance", newK)
	}

	e, ok := t.Instance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Instance", oldK)
	}
	e.InstanceIndex = &newK

	t.Instance[newK] = e
	delete(t.Instance, oldK)
	return nil
}

// GetOrCreateInstance retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sync_Ptp) GetOrCreateInstance(InstanceIndex uint32) *SrlNokiaSystem_System_Sync_Ptp_Instance {
	key := InstanceIndex

	if v, ok := t.Instance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInstance(InstanceIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInstance got unexpected error: %v", err))
	}
	return v
}

// GetInstance retrieves the value with the specified key from
// the Instance map field of SrlNokiaSystem_System_Sync_Ptp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp) GetInstance(InstanceIndex uint32) *SrlNokiaSystem_System_Sync_Ptp_Instance {
	if t == nil {
		return nil
	}

	key := InstanceIndex

	if lm, ok := t.Instance[key]; ok {
		return lm
	}
	return nil
}

// DeleteInstance deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sync_Ptp) DeleteInstance(InstanceIndex uint32) {
	key := InstanceIndex

	delete(t.Instance, key)
}

// AppendInstance appends the supplied SrlNokiaSystem_System_Sync_Ptp_Instance struct to the
// list Instance of SrlNokiaSystem_System_Sync_Ptp. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sync_Ptp_Instance already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sync_Ptp) AppendInstance(v *SrlNokiaSystem_System_Sync_Ptp_Instance) error {
	if v.InstanceIndex == nil {
		return fmt.Errorf("invalid nil key received for InstanceIndex")
	}

	key := *v.InstanceIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Instance == nil {
		t.Instance = make(map[uint32]*SrlNokiaSystem_System_Sync_Ptp_Instance)
	}

	if _, ok := t.Instance[key]; ok {
		return fmt.Errorf("duplicate key for list Instance %v", key)
	}

	t.Instance[key] = v
	return nil
}

// GetPtpProfile retrieves the value of the leaf PtpProfile from the SrlNokiaSystem_System_Sync_Ptp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PtpProfile is set, it can
// safely use t.GetPtpProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PtpProfile == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp) GetPtpProfile() E_SrlNokiaSystem_System_Sync_Ptp_PtpProfile {
	if t == nil || t.PtpProfile == 0 {
		return SrlNokiaSystem_System_Sync_Ptp_PtpProfile_itug8275dot1
	}
	return t.PtpProfile
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PtpProfile == 0 {
		t.PtpProfile = SrlNokiaSystem_System_Sync_Ptp_PtpProfile_itug8275dot1
	}
	for _, e := range t.Instance {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp.
func (*SrlNokiaSystem_System_Sync_Ptp) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance represents the /srl_nokia-system/system/sync/ptp/instance YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance struct {
	DefaultDs     *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs             `path:"default-ds" module:"srl_nokia-sync"`
	InstanceIndex *uint32                                                        `path:"instance-index" module:"srl_nokia-sync"`
	PortDsList    map[uint16]*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList `path:"port-ds-list" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance) IsYANGGoStruct() {}

// NewPortDsList creates a new entry in the PortDsList list of the
// SrlNokiaSystem_System_Sync_Ptp_Instance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) NewPortDsList(PortNumber uint16) (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PortDsList == nil {
		t.PortDsList = make(map[uint16]*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList)
	}

	key := PortNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PortDsList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PortDsList", key)
	}

	t.PortDsList[key] = &SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList{
		PortNumber: &PortNumber,
	}

	return t.PortDsList[key], nil
}

// RenamePortDsList renames an entry in the list PortDsList within
// the SrlNokiaSystem_System_Sync_Ptp_Instance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) RenamePortDsList(oldK, newK uint16) error {
	if _, ok := t.PortDsList[newK]; ok {
		return fmt.Errorf("key %v already exists in PortDsList", newK)
	}

	e, ok := t.PortDsList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PortDsList", oldK)
	}
	e.PortNumber = &newK

	t.PortDsList[newK] = e
	delete(t.PortDsList, oldK)
	return nil
}

// GetOrCreatePortDsList retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp_Instance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetOrCreatePortDsList(PortNumber uint16) *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList {
	key := PortNumber

	if v, ok := t.PortDsList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPortDsList(PortNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePortDsList got unexpected error: %v", err))
	}
	return v
}

// GetPortDsList retrieves the value with the specified key from
// the PortDsList map field of SrlNokiaSystem_System_Sync_Ptp_Instance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetPortDsList(PortNumber uint16) *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList {
	if t == nil {
		return nil
	}

	key := PortNumber

	if lm, ok := t.PortDsList[key]; ok {
		return lm
	}
	return nil
}

// DeletePortDsList deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Sync_Ptp_Instance. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) DeletePortDsList(PortNumber uint16) {
	key := PortNumber

	delete(t.PortDsList, key)
}

// AppendPortDsList appends the supplied SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList struct to the
// list PortDsList of SrlNokiaSystem_System_Sync_Ptp_Instance. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) AppendPortDsList(
	v *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList,
) error {
	if v.PortNumber == nil {
		return fmt.Errorf("invalid nil key received for PortNumber")
	}

	key := *v.PortNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PortDsList == nil {
		t.PortDsList = make(map[uint16]*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList)
	}

	if _, ok := t.PortDsList[key]; ok {
		return fmt.Errorf("duplicate key for list PortDsList %v", key)
	}

	t.PortDsList[key] = v
	return nil
}

// GetOrCreateDefaultDs retrieves the value of the DefaultDs field
// or returns the existing field if it already exists.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetOrCreateDefaultDs() *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs {
	if t.DefaultDs != nil {
		return t.DefaultDs
	}
	t.DefaultDs = &SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs{}
	return t.DefaultDs
}

// GetDefaultDs returns the value of the DefaultDs struct pointer
// from SrlNokiaSystem_System_Sync_Ptp_Instance. If the receiver or the field DefaultDs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetDefaultDs() *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs {
	if t != nil && t.DefaultDs != nil {
		return t.DefaultDs
	}
	return nil
}

// GetInstanceIndex retrieves the value of the leaf InstanceIndex from the SrlNokiaSystem_System_Sync_Ptp_Instance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceIndex is set, it can
// safely use t.GetInstanceIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceIndex == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) GetInstanceIndex() uint32 {
	if t == nil || t.InstanceIndex == nil {
		return 0
	}
	return *t.InstanceIndex
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DefaultDs.PopulateDefaults()
	for _, e := range t.PortDsList {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sync_Ptp_Instance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InstanceIndex == nil {
		return nil, fmt.Errorf("nil value for key InstanceIndex")
	}

	return map[string]interface{}{
		"instance-index": *t.InstanceIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs represents the /srl_nokia-system/system/sync/ptp/instance/default-ds YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs struct {
	DomainNumber   *uint8                                                           `path:"domain-number" module:"srl_nokia-sync"`
	InstanceEnable *bool                                                            `path:"instance-enable" module:"srl_nokia-sync"`
	InstanceType   E_SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs_InstanceType `path:"instance-type" module:"srl_nokia-sync"`
	LocalPriority  *uint8                                                           `path:"local-priority" module:"srl_nokia-sync"`
	Priority1      *uint8                                                           `path:"priority1" module:"srl_nokia-sync"`
	Priority2      *uint8                                                           `path:"priority2" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) IsYANGGoStruct() {}

// GetDomainNumber retrieves the value of the leaf DomainNumber from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DomainNumber is set, it can
// safely use t.GetDomainNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DomainNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetDomainNumber() uint8 {
	if t == nil || t.DomainNumber == nil {
		return 24
	}
	return *t.DomainNumber
}

// GetInstanceEnable retrieves the value of the leaf InstanceEnable from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceEnable is set, it can
// safely use t.GetInstanceEnable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceEnable == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetInstanceEnable() bool {
	if t == nil || t.InstanceEnable == nil {
		return false
	}
	return *t.InstanceEnable
}

// GetInstanceType retrieves the value of the leaf InstanceType from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InstanceType is set, it can
// safely use t.GetInstanceType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InstanceType == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetInstanceType() E_SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs_InstanceType {
	if t == nil || t.InstanceType == 0 {
		return 0
	}
	return t.InstanceType
}

// GetLocalPriority retrieves the value of the leaf LocalPriority from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalPriority is set, it can
// safely use t.GetLocalPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetLocalPriority() uint8 {
	if t == nil || t.LocalPriority == nil {
		return 128
	}
	return *t.LocalPriority
}

// GetPriority1 retrieves the value of the leaf Priority1 from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority1 is set, it can
// safely use t.GetPriority1() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority1 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetPriority1() uint8 {
	if t == nil || t.Priority1 == nil {
		return 128
	}
	return *t.Priority1
}

// GetPriority2 retrieves the value of the leaf Priority2 from the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority2 is set, it can
// safely use t.GetPriority2() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority2 == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) GetPriority2() uint8 {
	if t == nil || t.Priority2 == nil {
		return 128
	}
	return *t.Priority2
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DomainNumber == nil {
		var v uint8 = 24
		t.DomainNumber = &v
	}
	if t.InstanceEnable == nil {
		var v bool = false
		t.InstanceEnable = &v
	}
	if t.LocalPriority == nil {
		var v uint8 = 128
		t.LocalPriority = &v
	}
	if t.Priority1 == nil {
		var v uint8 = 128
		t.Priority1 = &v
	}
	if t.Priority2 == nil {
		var v uint8 = 128
		t.Priority2 = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_DefaultDs) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList represents the /srl_nokia-system/system/sync/ptp/instance/port-ds-list YANG schema element.
type SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList struct {
	AdminState             E_SrlNokiaCommon_AdminState                                  `path:"admin-state" module:"srl_nokia-sync"`
	AnnounceReceiptTimeout *uint8                                                       `path:"announce-receipt-timeout" module:"srl_nokia-sync"`
	DestMac                E_SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac `path:"dest-mac" module:"srl_nokia-sync"`
	LocalPriority          *uint8                                                       `path:"local-priority" module:"srl_nokia-sync"`
	LogAnnounceInterval    *int8                                                        `path:"log-announce-interval" module:"srl_nokia-sync"`
	LogMinDelayReqInterval *int8                                                        `path:"log-min-delay-req-interval" module:"srl_nokia-sync"`
	LogSyncInterval        *int8                                                        `path:"log-sync-interval" module:"srl_nokia-sync"`
	MasterOnly             *bool                                                        `path:"master-only" module:"srl_nokia-sync"`
	PortNumber             *uint16                                                      `path:"port-number" module:"srl_nokia-sync"`
	UnderlyingInterface    *string                                                      `path:"underlying-interface" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_disable
	}
	return t.AdminState
}

// GetAnnounceReceiptTimeout retrieves the value of the leaf AnnounceReceiptTimeout from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AnnounceReceiptTimeout is set, it can
// safely use t.GetAnnounceReceiptTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AnnounceReceiptTimeout == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetAnnounceReceiptTimeout() uint8 {
	if t == nil || t.AnnounceReceiptTimeout == nil {
		return 3
	}
	return *t.AnnounceReceiptTimeout
}

// GetDestMac retrieves the value of the leaf DestMac from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestMac is set, it can
// safely use t.GetDestMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetDestMac() E_SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac {
	if t == nil || t.DestMac == 0 {
		return SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac_forwardable
	}
	return t.DestMac
}

// GetLocalPriority retrieves the value of the leaf LocalPriority from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalPriority is set, it can
// safely use t.GetLocalPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalPriority == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetLocalPriority() uint8 {
	if t == nil || t.LocalPriority == nil {
		return 128
	}
	return *t.LocalPriority
}

// GetLogAnnounceInterval retrieves the value of the leaf LogAnnounceInterval from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogAnnounceInterval is set, it can
// safely use t.GetLogAnnounceInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogAnnounceInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetLogAnnounceInterval() int8 {
	if t == nil || t.LogAnnounceInterval == nil {
		return -3
	}
	return *t.LogAnnounceInterval
}

// GetLogMinDelayReqInterval retrieves the value of the leaf LogMinDelayReqInterval from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogMinDelayReqInterval is set, it can
// safely use t.GetLogMinDelayReqInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogMinDelayReqInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetLogMinDelayReqInterval() int8 {
	if t == nil || t.LogMinDelayReqInterval == nil {
		return -4
	}
	return *t.LogMinDelayReqInterval
}

// GetLogSyncInterval retrieves the value of the leaf LogSyncInterval from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogSyncInterval is set, it can
// safely use t.GetLogSyncInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogSyncInterval == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetLogSyncInterval() int8 {
	if t == nil || t.LogSyncInterval == nil {
		return -4
	}
	return *t.LogSyncInterval
}

// GetMasterOnly retrieves the value of the leaf MasterOnly from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MasterOnly is set, it can
// safely use t.GetMasterOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MasterOnly == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetMasterOnly() bool {
	if t == nil || t.MasterOnly == nil {
		return true
	}
	return *t.MasterOnly
}

// GetPortNumber retrieves the value of the leaf PortNumber from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortNumber is set, it can
// safely use t.GetPortNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortNumber == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetPortNumber() uint16 {
	if t == nil || t.PortNumber == nil {
		return 0
	}
	return *t.PortNumber
}

// GetUnderlyingInterface retrieves the value of the leaf UnderlyingInterface from the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UnderlyingInterface is set, it can
// safely use t.GetUnderlyingInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UnderlyingInterface == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) GetUnderlyingInterface() string {
	if t == nil || t.UnderlyingInterface == nil {
		return ""
	}
	return *t.UnderlyingInterface
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_disable
	}
	if t.AnnounceReceiptTimeout == nil {
		var v uint8 = 3
		t.AnnounceReceiptTimeout = &v
	}
	if t.DestMac == 0 {
		t.DestMac = SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList_DestMac_forwardable
	}
	if t.LocalPriority == nil {
		var v uint8 = 128
		t.LocalPriority = &v
	}
	if t.LogAnnounceInterval == nil {
		var v int8 = -3
		t.LogAnnounceInterval = &v
	}
	if t.LogMinDelayReqInterval == nil {
		var v int8 = -4
		t.LogMinDelayReqInterval = &v
	}
	if t.LogSyncInterval == nil {
		var v int8 = -4
		t.LogSyncInterval = &v
	}
	if t.MasterOnly == nil {
		var v bool = true
		t.MasterOnly = &v
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PortNumber == nil {
		return nil, fmt.Errorf("nil value for key PortNumber")
	}

	return map[string]interface{}{
		"port-number": *t.PortNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList.
func (*SrlNokiaSystem_System_Sync_Ptp_Instance_PortDsList) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Sync_TimeClock represents the /srl_nokia-system/system/sync/time-clock YANG schema element.
type SrlNokiaSystem_System_Sync_TimeClock struct {
	TimeRef E_SrlNokiaSystem_System_Sync_TimeClock_TimeRef `path:"time-ref" module:"srl_nokia-sync"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Sync_TimeClock implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Sync_TimeClock) IsYANGGoStruct() {}

// GetTimeRef retrieves the value of the leaf TimeRef from the SrlNokiaSystem_System_Sync_TimeClock
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TimeRef is set, it can
// safely use t.GetTimeRef() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TimeRef == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Sync_TimeClock) GetTimeRef() E_SrlNokiaSystem_System_Sync_TimeClock_TimeRef {
	if t == nil || t.TimeRef == 0 {
		return SrlNokiaSystem_System_Sync_TimeClock_TimeRef_ptp
	}
	return t.TimeRef
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Sync_TimeClock
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Sync_TimeClock) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.TimeRef == 0 {
		t.TimeRef = SrlNokiaSystem_System_Sync_TimeClock_TimeRef_ptp
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_TimeClock) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sync_TimeClock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sync_TimeClock) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sync_TimeClock) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Sync_TimeClock.
func (*SrlNokiaSystem_System_Sync_TimeClock) ΛBelongingModule() string {
	return "srl_nokia-sync"
}

// SrlNokiaSystem_System_Tls represents the /srl_nokia-system/system/tls YANG schema element.
type SrlNokiaSystem_System_Tls struct {
	ServerProfile map[string]*SrlNokiaSystem_System_Tls_ServerProfile `path:"server-profile" module:"srl_nokia-tls"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Tls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Tls) IsYANGGoStruct() {}

// NewServerProfile creates a new entry in the ServerProfile list of the
// SrlNokiaSystem_System_Tls struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Tls) NewServerProfile(Name string) (*SrlNokiaSystem_System_Tls_ServerProfile, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerProfile == nil {
		t.ServerProfile = make(map[string]*SrlNokiaSystem_System_Tls_ServerProfile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ServerProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ServerProfile", key)
	}

	t.ServerProfile[key] = &SrlNokiaSystem_System_Tls_ServerProfile{
		Name: &Name,
	}

	return t.ServerProfile[key], nil
}

// RenameServerProfile renames an entry in the list ServerProfile within
// the SrlNokiaSystem_System_Tls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaSystem_System_Tls) RenameServerProfile(oldK, newK string) error {
	if _, ok := t.ServerProfile[newK]; ok {
		return fmt.Errorf("key %v already exists in ServerProfile", newK)
	}

	e, ok := t.ServerProfile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ServerProfile", oldK)
	}
	e.Name = &newK

	t.ServerProfile[newK] = e
	delete(t.ServerProfile, oldK)
	return nil
}

// GetOrCreateServerProfile retrieves the value with the specified keys from
// the receiver SrlNokiaSystem_System_Tls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaSystem_System_Tls) GetOrCreateServerProfile(Name string) *SrlNokiaSystem_System_Tls_ServerProfile {
	key := Name

	if v, ok := t.ServerProfile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewServerProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateServerProfile got unexpected error: %v", err))
	}
	return v
}

// GetServerProfile retrieves the value with the specified key from
// the ServerProfile map field of SrlNokiaSystem_System_Tls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaSystem_System_Tls) GetServerProfile(Name string) *SrlNokiaSystem_System_Tls_ServerProfile {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ServerProfile[key]; ok {
		return lm
	}
	return nil
}

// DeleteServerProfile deletes the value with the specified keys from
// the receiver SrlNokiaSystem_System_Tls. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaSystem_System_Tls) DeleteServerProfile(Name string) {
	key := Name

	delete(t.ServerProfile, key)
}

// AppendServerProfile appends the supplied SrlNokiaSystem_System_Tls_ServerProfile struct to the
// list ServerProfile of SrlNokiaSystem_System_Tls. If the key value(s) specified in
// the supplied SrlNokiaSystem_System_Tls_ServerProfile already exist in the list, an error is
// returned.
func (t *SrlNokiaSystem_System_Tls) AppendServerProfile(v *SrlNokiaSystem_System_Tls_ServerProfile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerProfile == nil {
		t.ServerProfile = make(map[string]*SrlNokiaSystem_System_Tls_ServerProfile)
	}

	if _, ok := t.ServerProfile[key]; ok {
		return fmt.Errorf("duplicate key for list ServerProfile %v", key)
	}

	t.ServerProfile[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Tls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Tls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ServerProfile {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Tls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Tls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Tls.
func (*SrlNokiaSystem_System_Tls) ΛBelongingModule() string {
	return "srl_nokia-tls"
}

// SrlNokiaSystem_System_Tls_ServerProfile represents the /srl_nokia-system/system/tls/server-profile YANG schema element.
type SrlNokiaSystem_System_Tls_ServerProfile struct {
	AuthenticateClient *bool                      `path:"authenticate-client" module:"srl_nokia-tls"`
	Certificate        *string                    `path:"certificate" module:"srl_nokia-tls"`
	CipherList         []E_SrlNokiaTls_CipherType `path:"cipher-list" module:"srl_nokia-tls"`
	Key                *string                    `path:"key" module:"srl_nokia-tls"`
	Name               *string                    `path:"name" module:"srl_nokia-tls"`
	TrustAnchor        *string                    `path:"trust-anchor" module:"srl_nokia-tls"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_Tls_ServerProfile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_Tls_ServerProfile) IsYANGGoStruct() {}

// GetAuthenticateClient retrieves the value of the leaf AuthenticateClient from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticateClient is set, it can
// safely use t.GetAuthenticateClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticateClient == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetAuthenticateClient() bool {
	if t == nil || t.AuthenticateClient == nil {
		return false
	}
	return *t.AuthenticateClient
}

// GetCertificate retrieves the value of the leaf Certificate from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Certificate is set, it can
// safely use t.GetCertificate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Certificate == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetCertificate() string {
	if t == nil || t.Certificate == nil {
		return ""
	}
	return *t.Certificate
}

// GetCipherList retrieves the value of the leaf CipherList from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CipherList is set, it can
// safely use t.GetCipherList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CipherList == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetCipherList() []E_SrlNokiaTls_CipherType {
	if t == nil || t.CipherList == nil {
		return []E_SrlNokiaTls_CipherType{
			SrlNokiaTls_CipherType_ecdhe_rsa_aes128_gcm_sha256,
			SrlNokiaTls_CipherType_ecdhe_rsa_aes256_gcm_sha384,
		}
	}
	return t.CipherList
}

// GetKey retrieves the value of the leaf Key from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// GetName retrieves the value of the leaf Name from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetTrustAnchor retrieves the value of the leaf TrustAnchor from the SrlNokiaSystem_System_Tls_ServerProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrustAnchor is set, it can
// safely use t.GetTrustAnchor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrustAnchor == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) GetTrustAnchor() string {
	if t == nil || t.TrustAnchor == nil {
		return ""
	}
	return *t.TrustAnchor
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_Tls_ServerProfile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AuthenticateClient == nil {
		var v bool = false
		t.AuthenticateClient = &v
	}
	if t.CipherList == nil {
		t.CipherList = []E_SrlNokiaTls_CipherType{
			SrlNokiaTls_CipherType_ecdhe_rsa_aes128_gcm_sha256,
			SrlNokiaTls_CipherType_ecdhe_rsa_aes256_gcm_sha384,
		}
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Tls_ServerProfile struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Tls_ServerProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_Tls_ServerProfile.
func (*SrlNokiaSystem_System_Tls_ServerProfile) ΛBelongingModule() string {
	return "srl_nokia-tls"
}

// SrlNokiaSystem_System_WarmReboot represents the /srl_nokia-system/system/warm-reboot YANG schema element.
type SrlNokiaSystem_System_WarmReboot struct {
	BgpMaxWait *uint16 `path:"bgp-max-wait" module:"srl_nokia-bgp"`
}

// IsYANGGoStruct ensures that SrlNokiaSystem_System_WarmReboot implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaSystem_System_WarmReboot) IsYANGGoStruct() {}

// GetBgpMaxWait retrieves the value of the leaf BgpMaxWait from the SrlNokiaSystem_System_WarmReboot
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BgpMaxWait is set, it can
// safely use t.GetBgpMaxWait() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BgpMaxWait == nil' before retrieving the leaf's value.
func (t *SrlNokiaSystem_System_WarmReboot) GetBgpMaxWait() uint16 {
	if t == nil || t.BgpMaxWait == nil {
		return 600
	}
	return *t.BgpMaxWait
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaSystem_System_WarmReboot
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaSystem_System_WarmReboot) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BgpMaxWait == nil {
		var v uint16 = 600
		t.BgpMaxWait = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_WarmReboot) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_WarmReboot"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_WarmReboot) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_WarmReboot) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaSystem_System_WarmReboot.
func (*SrlNokiaSystem_System_WarmReboot) ΛBelongingModule() string {
	return "srl_nokia-system-reboot"
}

// SrlNokiaTunnelInterfaces_TunnelInterface represents the /srl_nokia-tunnel-interfaces/tunnel-interface YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface struct {
	Name           *string                                                             `path:"name" module:"srl_nokia-tunnel-interfaces"`
	VxlanInterface map[uint32]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface `path:"vxlan-interface" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface) IsYANGGoStruct() {}

// NewVxlanInterface creates a new entry in the VxlanInterface list of the
// SrlNokiaTunnelInterfaces_TunnelInterface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) NewVxlanInterface(Index uint32) (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VxlanInterface == nil {
		t.VxlanInterface = make(map[uint32]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VxlanInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VxlanInterface", key)
	}

	t.VxlanInterface[key] = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface{
		Index: &Index,
	}

	return t.VxlanInterface[key], nil
}

// RenameVxlanInterface renames an entry in the list VxlanInterface within
// the SrlNokiaTunnelInterfaces_TunnelInterface struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) RenameVxlanInterface(oldK, newK uint32) error {
	if _, ok := t.VxlanInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in VxlanInterface", newK)
	}

	e, ok := t.VxlanInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VxlanInterface", oldK)
	}
	e.Index = &newK

	t.VxlanInterface[newK] = e
	delete(t.VxlanInterface, oldK)
	return nil
}

// GetOrCreateVxlanInterface retrieves the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) GetOrCreateVxlanInterface(Index uint32) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface {
	key := Index

	if v, ok := t.VxlanInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVxlanInterface(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVxlanInterface got unexpected error: %v", err))
	}
	return v
}

// GetVxlanInterface retrieves the value with the specified key from
// the VxlanInterface map field of SrlNokiaTunnelInterfaces_TunnelInterface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) GetVxlanInterface(Index uint32) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.VxlanInterface[key]; ok {
		return lm
	}
	return nil
}

// DeleteVxlanInterface deletes the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) DeleteVxlanInterface(Index uint32) {
	key := Index

	delete(t.VxlanInterface, key)
}

// AppendVxlanInterface appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface struct to the
// list VxlanInterface of SrlNokiaTunnelInterfaces_TunnelInterface. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface already exist in the list, an error is
// returned.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) AppendVxlanInterface(
	v *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VxlanInterface == nil {
		t.VxlanInterface = make(map[uint32]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface)
	}

	if _, ok := t.VxlanInterface[key]; ok {
		return fmt.Errorf("duplicate key for list VxlanInterface %v", key)
	}

	t.VxlanInterface[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the SrlNokiaTunnelInterfaces_TunnelInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VxlanInterface {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface.
func (*SrlNokiaTunnelInterfaces_TunnelInterface) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface struct {
	BridgeTable *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable `path:"bridge-table" module:"srl_nokia-tunnel-interfaces" yangPresence:"true"`
	Egress      *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress      `path:"egress" module:"srl_nokia-tunnel-interfaces"`
	Index       *uint32                                                              `path:"index" module:"srl_nokia-tunnel-interfaces"`
	Ingress     *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress     `path:"ingress" module:"srl_nokia-tunnel-interfaces"`
	Type        E_SrlNokiaInterfaces_SiType                                          `path:"type" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) IsYANGGoStruct() {}

// GetOrCreateBridgeTable retrieves the value of the BridgeTable field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetOrCreateBridgeTable() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable {
	if t.BridgeTable != nil {
		return t.BridgeTable
	}
	t.BridgeTable = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable{}
	return t.BridgeTable
}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetOrCreateEgress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress {
	if t.Egress != nil {
		return t.Egress
	}
	t.Egress = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress{}
	return t.Egress
}

// GetOrCreateIngress retrieves the value of the Ingress field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetOrCreateIngress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress {
	if t.Ingress != nil {
		return t.Ingress
	}
	t.Ingress = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress{}
	return t.Ingress
}

// GetBridgeTable returns the value of the BridgeTable struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface. If the receiver or the field BridgeTable is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetBridgeTable() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable {
	if t != nil && t.BridgeTable != nil {
		return t.BridgeTable
	}
	return nil
}

// GetEgress returns the value of the Egress struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetEgress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress {
	if t != nil && t.Egress != nil {
		return t.Egress
	}
	return nil
}

// GetIngress returns the value of the Ingress struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface. If the receiver or the field Ingress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetIngress() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress {
	if t != nil && t.Ingress != nil {
		return t.Ingress
	}
	return nil
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetIndex() uint32 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetType retrieves the value of the leaf Type from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) GetType() E_SrlNokiaInterfaces_SiType {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.BridgeTable.PopulateDefaults()
	t.Egress.PopulateDefaults()
	t.Ingress.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/bridge-table YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable struct{}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_BridgeTable) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress struct {
	DestinationGroups   *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups   `path:"destination-groups" module:"srl_nokia-tunnel-interfaces"`
	InnerEthernetHeader *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader `path:"inner-ethernet-header" module:"srl_nokia-tunnel-interfaces" yangPresence:"true"`
	SourceIp            E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum      `path:"source-ip" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) IsYANGGoStruct() {}

// GetOrCreateDestinationGroups retrieves the value of the DestinationGroups field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetOrCreateDestinationGroups() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups {
	if t.DestinationGroups != nil {
		return t.DestinationGroups
	}
	t.DestinationGroups = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups{}
	return t.DestinationGroups
}

// GetOrCreateInnerEthernetHeader retrieves the value of the InnerEthernetHeader field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetOrCreateInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader {
	if t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	t.InnerEthernetHeader = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader{}
	return t.InnerEthernetHeader
}

// GetDestinationGroups returns the value of the DestinationGroups struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress. If the receiver or the field DestinationGroups is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetDestinationGroups() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups {
	if t != nil && t.DestinationGroups != nil {
		return t.DestinationGroups
	}
	return nil
}

// GetInnerEthernetHeader returns the value of the InnerEthernetHeader struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress. If the receiver or the field InnerEthernetHeader is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader {
	if t != nil && t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	return nil
}

// GetSourceIp retrieves the value of the leaf SourceIp from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceIp is set, it can
// safely use t.GetSourceIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceIp == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) GetSourceIp() E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum {
	if t == nil || t.SourceIp == 0 {
		return SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum_use_system_ipv4_address
	}
	return t.SourceIp
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SourceIp == 0 {
		t.SourceIp = SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_SourceIp_Enum_use_system_ipv4_address
	}
	t.DestinationGroups.PopulateDefaults()
	t.InnerEthernetHeader.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups struct {
	Group map[string]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group `path:"group" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) IsYANGGoStruct() {
}

// NewGroup creates a new entry in the Group list of the
// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) NewGroup(
	Name string,
) (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// RenameGroup renames an entry in the list Group within
// the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) RenameGroup(oldK, newK string) error {
	if _, ok := t.Group[newK]; ok {
		return fmt.Errorf("key %v already exists in Group", newK)
	}

	e, ok := t.Group[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Group", oldK)
	}
	e.Name = &newK

	t.Group[newK] = e
	delete(t.Group, oldK)
	return nil
}

// GetOrCreateGroup retrieves the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) GetOrCreateGroup(
	Name string,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group {
	key := Name

	if v, ok := t.Group[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGroup(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGroup got unexpected error: %v", err))
	}
	return v
}

// GetGroup retrieves the value with the specified key from
// the Group map field of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) GetGroup(
	Name string,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group {
	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Group[key]; ok {
		return lm
	}
	return nil
}

// DeleteGroup deletes the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) DeleteGroup(Name string) {
	key := Name

	delete(t.Group, key)
}

// AppendGroup appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct to the
// list Group of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group already exist in the list, an error is
// returned.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) AppendGroup(
	v *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group,
) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group)
	}

	if _, ok := t.Group[key]; ok {
		return fmt.Errorf("duplicate key for list Group %v", key)
	}

	t.Group[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Group {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups/group YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct {
	AdminState  E_SrlNokiaCommon_AdminState                                                                                    `path:"admin-state" module:"srl_nokia-tunnel-interfaces"`
	Destination map[uint16]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination `path:"destination" module:"srl_nokia-tunnel-interfaces"`
	Esi         *string                                                                                                        `path:"esi" module:"srl_nokia-tunnel-interfaces"`
	Name        *string                                                                                                        `path:"name" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) IsYANGGoStruct() {
}

// NewDestination creates a new entry in the Destination list of the
// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) NewDestination(
	Index uint16,
) (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination, error) {
	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[uint16]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Destination[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Destination", key)
	}

	t.Destination[key] = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination{
		Index: &Index,
	}

	return t.Destination[key], nil
}

// RenameDestination renames an entry in the list Destination within
// the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) RenameDestination(oldK, newK uint16) error {
	if _, ok := t.Destination[newK]; ok {
		return fmt.Errorf("key %v already exists in Destination", newK)
	}

	e, ok := t.Destination[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Destination", oldK)
	}
	e.Index = &newK

	t.Destination[newK] = e
	delete(t.Destination, oldK)
	return nil
}

// GetOrCreateDestination retrieves the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetOrCreateDestination(
	Index uint16,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination {
	key := Index

	if v, ok := t.Destination[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDestination(Index)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDestination got unexpected error: %v", err))
	}
	return v
}

// GetDestination retrieves the value with the specified key from
// the Destination map field of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetDestination(
	Index uint16,
) *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination {
	if t == nil {
		return nil
	}

	key := Index

	if lm, ok := t.Destination[key]; ok {
		return lm
	}
	return nil
}

// DeleteDestination deletes the value with the specified keys from
// the receiver SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If there is no such element, the function
// is a no-op.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) DeleteDestination(Index uint16) {
	key := Index

	delete(t.Destination, key)
}

// AppendDestination appends the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination struct to the
// list Destination of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group. If the key value(s) specified in
// the supplied SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination already exist in the list, an error is
// returned.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) AppendDestination(
	v *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination,
) error {
	if v.Index == nil {
		return fmt.Errorf("invalid nil key received for Index")
	}

	key := *v.Index

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[uint16]*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination)
	}

	if _, ok := t.Destination[key]; ok {
		return fmt.Errorf("duplicate key for list Destination %v", key)
	}

	t.Destination[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetEsi retrieves the value of the leaf Esi from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esi is set, it can
// safely use t.GetEsi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esi == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetEsi() string {
	if t == nil || t.Esi == nil {
		return ""
	}
	return *t.Esi
}

// GetName retrieves the value of the leaf Name from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	for _, e := range t.Destination {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups/group/destination YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination struct {
	AdminState          E_SrlNokiaCommon_AdminState                                                                                             `path:"admin-state" module:"srl_nokia-tunnel-interfaces"`
	Index               *uint16                                                                                                                 `path:"index" module:"srl_nokia-tunnel-interfaces"`
	InnerEthernetHeader *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader `path:"inner-ethernet-header" module:"srl_nokia-tunnel-interfaces"`
	Vni                 *uint32                                                                                                                 `path:"vni" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) IsYANGGoStruct() {
}

// GetOrCreateInnerEthernetHeader retrieves the value of the InnerEthernetHeader field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetOrCreateInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader {
	if t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	t.InnerEthernetHeader = &SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader{}
	return t.InnerEthernetHeader
}

// GetInnerEthernetHeader returns the value of the InnerEthernetHeader struct pointer
// from SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination. If the receiver or the field InnerEthernetHeader is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetInnerEthernetHeader() *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader {
	if t != nil && t.InnerEthernetHeader != nil {
		return t.InnerEthernetHeader
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetAdminState() E_SrlNokiaCommon_AdminState {
	if t == nil || t.AdminState == 0 {
		return SrlNokiaCommon_AdminState_enable
	}
	return t.AdminState
}

// GetIndex retrieves the value of the leaf Index from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Index is set, it can
// safely use t.GetIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Index == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetIndex() uint16 {
	if t == nil || t.Index == nil {
		return 0
	}
	return *t.Index
}

// GetVni retrieves the value of the leaf Vni from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = SrlNokiaCommon_AdminState_enable
	}
	t.InnerEthernetHeader.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination struct, which is a YANG list entry.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/destination-groups/group/destination/inner-ethernet-header YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader struct {
	DestinationMac *string `path:"destination-mac" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) IsYANGGoStruct() {
}

// GetDestinationMac retrieves the value of the leaf DestinationMac from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationMac is set, it can
// safely use t.GetDestinationMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) GetDestinationMac() string {
	if t == nil || t.DestinationMac == nil {
		return ""
	}
	return *t.DestinationMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_DestinationGroups_Group_Destination_InnerEthernetHeader) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/egress/inner-ethernet-header YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader struct {
	SourceMac E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum `path:"source-mac" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) IsYANGGoStruct() {
}

// GetSourceMac retrieves the value of the leaf SourceMac from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceMac is set, it can
// safely use t.GetSourceMac() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceMac == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) GetSourceMac() E_SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum {
	if t == nil || t.SourceMac == 0 {
		return SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum_use_system_mac
	}
	return t.SourceMac
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SourceMac == 0 {
		t.SourceMac = SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader_SourceMac_Enum_use_system_mac
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Egress_InnerEthernetHeader) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress represents the /srl_nokia-tunnel-interfaces/tunnel-interface/vxlan-interface/ingress YANG schema element.
type SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress struct {
	Vni *uint32 `path:"vni" module:"srl_nokia-tunnel-interfaces"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) IsYANGGoStruct() {}

// GetVni retrieves the value of the leaf Vni from the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vni is set, it can
// safely use t.GetVni() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vni == nil' before retrieving the leaf's value.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) GetVni() uint32 {
	if t == nil || t.Vni == nil {
		return 0
	}
	return *t.Vni
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress.
func (*SrlNokiaTunnelInterfaces_TunnelInterface_VxlanInterface_Ingress) ΛBelongingModule() string {
	return "srl_nokia-tunnel-interfaces"
}

// SrlNokiaTunnel_Tunnel represents the /srl_nokia-tunnel/tunnel YANG schema element.
type SrlNokiaTunnel_Tunnel struct {
	VxlanTunnel *SrlNokiaTunnel_Tunnel_VxlanTunnel `path:"vxlan-tunnel" module:"srl_nokia-vxlan-tunnel-vtep"`
}

// IsYANGGoStruct ensures that SrlNokiaTunnel_Tunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnel_Tunnel) IsYANGGoStruct() {}

// GetOrCreateVxlanTunnel retrieves the value of the VxlanTunnel field
// or returns the existing field if it already exists.
func (t *SrlNokiaTunnel_Tunnel) GetOrCreateVxlanTunnel() *SrlNokiaTunnel_Tunnel_VxlanTunnel {
	if t.VxlanTunnel != nil {
		return t.VxlanTunnel
	}
	t.VxlanTunnel = &SrlNokiaTunnel_Tunnel_VxlanTunnel{}
	return t.VxlanTunnel
}

// GetVxlanTunnel returns the value of the VxlanTunnel struct pointer
// from SrlNokiaTunnel_Tunnel. If the receiver or the field VxlanTunnel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *SrlNokiaTunnel_Tunnel) GetVxlanTunnel() *SrlNokiaTunnel_Tunnel_VxlanTunnel {
	if t != nil && t.VxlanTunnel != nil {
		return t.VxlanTunnel
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnel_Tunnel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnel_Tunnel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.VxlanTunnel.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnel_Tunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnel_Tunnel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnel_Tunnel.
func (*SrlNokiaTunnel_Tunnel) ΛBelongingModule() string {
	return "srl_nokia-tunnel"
}

// SrlNokiaTunnel_Tunnel_VxlanTunnel represents the /srl_nokia-tunnel/tunnel/vxlan-tunnel YANG schema element.
type SrlNokiaTunnel_Tunnel_VxlanTunnel struct{}

// IsYANGGoStruct ensures that SrlNokiaTunnel_Tunnel_VxlanTunnel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*SrlNokiaTunnel_Tunnel_VxlanTunnel) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the SrlNokiaTunnel_Tunnel_VxlanTunnel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaTunnel_Tunnel_VxlanTunnel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaTunnel_Tunnel_VxlanTunnel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of SrlNokiaTunnel_Tunnel_VxlanTunnel.
func (*SrlNokiaTunnel_Tunnel_VxlanTunnel) ΛBelongingModule() string {
	return "srl_nokia-vxlan-tunnel-vtep"
}
